https://juejin.im/post/6844903903822086151

## 步骤

1. 实现一个监听器 Observer：用来劫持并监听所有属性，如果属性发生变化，就通知订阅者；
2. 实现一个订阅器 Dep：用来收集订阅者，对监听器 Obsever 和订阅者 Watcher 进行统一管理；
3. 实现一个订阅者 Watcher：可以收到属性变化通知并执行相应的方法，从而更新视图；
4. 实现一个解析器 Compile：可以解析每个节点相关指令，对模板数据和订阅器进行初始化；

![3.png](https://user-gold-cdn.xitu.io/2019/8/1/16c4a3ce0bcb0d91?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

## 监听器 Observer

> 监听器 Observer 的主要是指让数据对象变得“可观测”，即每次数据读或写时，能感知到数据被读取了或数据被改写了；
>
> Vue 2.0 源码中用到 Object.defineProperty()  来劫持各个数据属性的 setter / getter；

```
Object.defineProperty() 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性， 并返回这个对象；
```

### Object.defineProperty() 定义对象

```javascript
function defineReactive(obj, key, val) {
    Object.defineProperty(obj, key, {
        get() {
            console.log(`${key}属性被读取了...`);
            return val;
        },
        set(newVal) {
            console.log(`${key}属性被修改了...`);
            val = newVal;
        }
    })
}
```

### 改进

```javascript
/**
  * 循环遍历数据对象的每个属性
  */
function observable(obj) {
    if (!obj || typeof obj !== 'object') {
        return;
    }
    let keys = Object.keys(obj);
    keys.forEach((key) => {
        defineReactive(obj, key, obj[key])
    })
    return obj;
}
/**
 * 将对象的属性用 Object.defineProperty() 进行设置
 */
function defineReactive(obj, key, val) {
    Object.defineProperty(obj, key, {
        get() {
            console.log(`${key}属性被读取了...`);
            return val;
        },
        set(newVal) {
            console.log(`${key}属性被修改了...`);
            val = newVal;
        }
    })
}
```

### initState 方法

在 Vue 初始化阶段，_init 方法执行的时候，执行 initState（vm）方法;

initState 方法主要对 props、methods、data、computed、watcher 等属性做了初始化的操作；

```javascript
export function initState (vm: Component) {
  vm._watchers = []
  const opts = vm.$options
  if (opts.props) initProps(vm, opts.props)
  if (opts.methods) initMethods(vm, opts.methods)
  if (opts.data) {
    initData(vm)
  } else {
    observe(vm._data = {}, true /* asRootData */)
  }
  if (opts.computed) initComputed(vm, opts.computed)
  if (opts.watch && opts.watch !== nativeWatch) {
    initWatch(vm, opts.watch)
  }
}
```

### initData 方法

1. 对定义 data 函数返回对象的遍历，通过 proxy 把每一个值 vm._data.xxx 都代理到 vm.xxx 上；
2. 调用 observe 方法观测整个 data 的变化，把 data 也变成响应式；

```javascript

function initData (vm: Component) {
  let data = vm.$options.data
  data = vm._data = typeof data === 'function'
    ? getData(data, vm)
    : data || {}
  if (!isPlainObject(data)) {
    data = {}
    process.env.NODE_ENV !== 'production' && warn(
      'data functions should return an object:\n' +
      'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function',
      vm
    )
  }
  // proxy data on instance
  const keys = Object.keys(data)
  const props = vm.$options.props
  const methods = vm.$options.methods
  let i = keys.length
  while (i--) {
    const key = keys[i]
    if (process.env.NODE_ENV !== 'production') {
      if (methods && hasOwn(methods, key)) {
        warn(
          `Method "${key}" has already been defined as a data property.`,
          vm
        )
      }
    }
    if (props && hasOwn(props, key)) {
      process.env.NODE_ENV !== 'production' && warn(
        `The data property "${key}" is already declared as a prop. ` +
        `Use prop default value instead.`,
        vm
      )
    } else if (!isReserved(key)) {
      proxy(vm, `_data`, key)
    }
  }
  // observe data
  observe(data, true /* asRootData */)
}
```

### observe 方法

> observe 方法就是用来检测数据的变化 ；

observe 方法就是给非 VNode 的对象数据类型添加一个 Observer , 如果已经添加过则直接返回，否则在满足一定条件下去实例化一个 Observer 对象实例；

```javascript
export function observe (value: any, asRootData: ?boolean): Observer | void {
  if (!isObject(value) || value instanceof VNode) {
    return
  }
  let ob: Observer | void
  if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {
    ob = value.__ob__
  } else if (
    shouldObserve &&
    !isServerRendering() &&
    (Array.isArray(value) || isPlainObject(value)) &&
    Object.isExtensible(value) &&
    !value._isVue
  ) {
    ob = new Observer(value)
  }
  if (asRootData && ob) {
    ob.vmCount++
  }
  return ob
}
```

### Observer 方法

> Observer 是一个类，它的作用是给对象属性添加 getter 和 setter，用于依赖收集和派发更新；

```javascript
export class Observer {
  value: any;
  dep: Dep;
  vmCount: number; // number of vms that have this object as root $data

  constructor (value: any) {
    this.value = value
    this.dep = new Dep()
    this.vmCount = 0
    def(value, '__ob__', this)
    if (Array.isArray(value)) {
      if (hasProto) {
        protoAugment(value, arrayMethods)
      } else {
        copyAugment(value, arrayMethods, arrayKeys)
      }
      this.observeArray(value)
    } else {
      this.walk(value)
    }
  }

  /**
   * Walk through all properties and convert them into
   * getter/setters. This method should only be called when
   * value type is Object.
   */
  walk (obj: Object) {
    const keys = Object.keys(obj)
    for (let i = 0; i < keys.length; i++) {
      defineReactive(obj, keys[i])
    }
  }

  /**
   * Observe a list of Array items.
   */
  observeArray (items: Array<any>) {
    for (let i = 0, l = items.length; i < l; i++) {
      observe(items[i])
    }
  }
}

```

### defineReactive 方法

> defineReactive 的功能就是定义一个响应式对象，给对象动态添加 getter 和 setter；

1. 初始化 Dep 对象的实例，拿到 obj 的属性描述符；
2. 对子对象递归调用 observe 方法，保证无论 obj 的结构多复杂，所有的子属性也能变成响应式对象；

```javascript
export function defineReactive (
  obj: Object,
  key: string,
  val: any,
  customSetter?: ?Function,
  shallow?: boolean
) {
  const dep = new Dep()

  const property = Object.getOwnPropertyDescriptor(obj, key)
  if (property && property.configurable === false) {
    return
  }

  // cater for pre-defined getter/setters
  const getter = property && property.get
  const setter = property && property.set
  if ((!getter || setter) && arguments.length === 2) {
    val = obj[key]
  }

  let childOb = !shallow && observe(val)
  Object.defineProperty(obj, key, {
    enumerable: true,
    configurable: true,
    get: function reactiveGetter () {
      const value = getter ? getter.call(obj) : val
      if (Dep.target) {
        dep.depend()
        if (childOb) {
          childOb.dep.depend()
          if (Array.isArray(value)) {
            dependArray(value)
          }
        }
      }
      return value
    },
    set: function reactiveSetter (newVal) {
      const value = getter ? getter.call(obj) : val
      /* eslint-disable no-self-compare */
      if (newVal === value || (newVal !== newVal && value !== value)) {
        return
      }
      /* eslint-enable no-self-compare */
      if (process.env.NODE_ENV !== 'production' && customSetter) {
        customSetter()
      }
      // #7981: for accessor properties without setter
      if (getter && !setter) return
      if (setter) {
        setter.call(obj, newVal)
      } else {
        val = newVal
      }
      childOb = !shallow && observe(newVal)
      dep.notify()
    }
  })
}
```

## 订阅器 Dep

> 订阅器 Dep 主要负责收集订阅者，然后当数据变化的时候后执行对应订阅者的更新函数；

Dep 是一个 Class，它定义的静态属性 target，是一个全局唯一的 Watcher，因为在同一时间只能有一个全局的 Watcher 被计算，它的另一个属性 subs 也是 Watcher 的数组；

Dep 实际上是对 Wather 的一种管理；

```javascript
export default class Dep {
  static target: ?Watcher;
  id: number;
  subs: Array<Watcher>;

  constructor () {
    this.id = uid++
    this.subs = []
  }

  addSub (sub: Watcher) {
    this.subs.push(sub)
  }

  removeSub (sub: Watcher) {
    remove(this.subs, sub)
  }

  depend () {
    if (Dep.target) {
      Dep.target.addDep(this)
    }
  }

  notify () {
    // stabilize the subscriber list first
    const subs = this.subs.slice()
    if (process.env.NODE_ENV !== 'production' && !config.async) {
      // subs aren't sorted in scheduler if not running async
      // we need to sort them now to make sure they fire in correct
      // order
      subs.sort((a, b) => a.id - b.id)
    }
    for (let i = 0, l = subs.length; i < l; i++) {
      subs[i].update()
    }
  }
}

// The current target watcher being evaluated.
// This is globally unique because only one watcher
// can be evaluated at a time.
Dep.target = null
```

## 订阅者 Watcher

> 订阅者 Watcher 在初始化的时候需要将自己添加到订阅器 Dep 中；

监听器 Observer 是在 get 函数执行了添加订阅者 Watcher 的操作的，所以只要在订阅者 Watcher 初始化的时候触发相应的 get 函数去执行添加订阅者操作即可；

```javascript
/**
  1. vm： 一个 Vue 的实例对象；
  2. exp:  node 节点的 v-model 等指令的属性值 或者插值符号中的属性;
  3. cb：Watcher 绑定的更新函数；
**/
function Watcher(vm, exp, cb) {
    this.vm = vm;
    this.exp = exp;
    this.cb = cb;
  	// 将自己添加到订阅器的操作
    this.value = this.get();  
}

Watcher.prototype = {
    update: function() {
        this.run();
    },
    run: function() {
        var value = this.vm.data[this.exp];
        var oldVal = this.value;
        if (value !== oldVal) {
            this.value = value;
            this.cb.call(this.vm, value, oldVal);
        }
    },
    get: function() {
      	// 把 Dep.target 赋值为当前的渲染 Watcher
        Dep.target = this; 
      	// 对 vm 进行数据上的访问，为了触发数据对象的 getter
        var value = this.vm.data[this.exp];
      	// 恢复 Dep.target 状态
        Dep.target = null; 
        return value;
    }
};
```

```
export default class Watcher {
  vm: Component;
  expression: string;
  cb: Function;
  id: number;
  deep: boolean;
  user: boolean;
  lazy: boolean;
  sync: boolean;
  dirty: boolean;
  active: boolean;
  deps: Array<Dep>;
  newDeps: Array<Dep>;
  depIds: SimpleSet;
  newDepIds: SimpleSet;
  before: ?Function;
  getter: Function;
  value: any;

  constructor (
    vm: Component,
    expOrFn: string | Function,
    cb: Function,
    options?: ?Object,
    isRenderWatcher?: boolean
  ) {
    this.vm = vm
    if (isRenderWatcher) {
      vm._watcher = this
    }
    vm._watchers.push(this)
    // options
    if (options) {
      this.deep = !!options.deep
      this.user = !!options.user
      this.lazy = !!options.lazy
      this.sync = !!options.sync
      this.before = options.before
    } else {
      this.deep = this.user = this.lazy = this.sync = false
    }
    this.cb = cb
    this.id = ++uid // uid for batching
    this.active = true
    this.dirty = this.lazy // for lazy watchers
    this.deps = []
    this.newDeps = []
    this.depIds = new Set()
    this.newDepIds = new Set()
    this.expression = process.env.NODE_ENV !== 'production'
      ? expOrFn.toString()
      : ''
    // parse expression for getter
    if (typeof expOrFn === 'function') {
      this.getter = expOrFn
    } else {
      this.getter = parsePath(expOrFn)
      if (!this.getter) {
        this.getter = noop
        process.env.NODE_ENV !== 'production' && warn(
          `Failed watching path: "${expOrFn}" ` +
          'Watcher only accepts simple dot-delimited paths. ' +
          'For full control, use a function instead.',
          vm
        )
      }
    }
    this.value = this.lazy
      ? undefined
      : this.get()
  }
   。。。。。。
}

```

## 解析器 Compile

> 解析器 Compile 来做解析和绑定工作；

解析模板指令，对每个节点元素进行扫描和解析，将相关指令对应初始化成一个订阅者 Watcher，并替换模板数据或者绑定相应的函数；

1. 为了解析模板，需要获得 DOM 元素，对 DOM 元素上含有指令的节点进行处理，这个环节需要对 Dom 操作频繁，可以先建一个 fragment 片段；

```javascript
function nodeToFragment (el) {
    var fragment = document.createDocumentFragment();
    var child = el.firstChild;
    while (child) {
        // 将Dom元素移入fragment中
        fragment.appendChild(child);
        child = el.firstChild
    }
    return fragment;
}
```

2. 遍历各个节点，对含有相关指定的节点进行特殊处理，先对带有 '{{变量}}' 这种形式的指令进行处理；

```javascript
function compileElement (el) {
  	// 获取所有子节点
    var childNodes = el.childNodes;
    var self = this;
    [].slice.call(childNodes).forEach(function(node) {
        var reg = /\{\{(.*)\}\}/;
        var text = node.textContent;
 ·		// 判断节点是文本节点且匹配{{}}这种形式指令的节点
        if (self.isTextNode(node) && reg.test(text)) { 
            self.compileText(node, reg.exec(text)[1]);
        }
 		// 继续递归遍历子节点
        if (node.childNodes && node.childNodes.length) {
            self.compileElement(node);  
        }
    });
},
function compileText (node, exp) {
    var self = this;
    var initText = this.vm[exp];
  	// 初始化的数据初始化到视图中
    updateText(node, initText);  
  	// 生成一个并绑定更新函数的订阅器
    new Watcher(this.vm, exp, function (value) { 
        self.updateText(node, value);
    });
},
function updateText (node, value) {
    node.textContent = typeof value == 'undefined' ? '' : value;
}
```

## 原理图

![4.png](https://user-gold-cdn.xitu.io/2019/8/1/16c4a3ce0cc709da?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)