> SSR 就是 Vue 在客户端将标签渲染成整个html 片段的工作在服务端完成，服务端形成的 html 片段直接返回给客户端的过程叫做服务端渲染；

## 构建流程

![img](https://user-gold-cdn.xitu.io/2018/5/24/16390509c83aef03?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

### 入口文件

app.js 是通用 entry，它就是构建一个Vue的实例以供服务端和客户端使用；

#### Client entry

Client entry 就是挂载我们的 Vue 实例到指定的 dom 元素上；

#### Server entry

Server entry 是一个使用 export 导出的函数，主要负责调用组件内定义的获取数据的方法，获取到 SSR 渲染所需要的数据，并存储到上下文环境中，这个函数会在每一次渲染中重复的调用；

### webpack打包构建

服务端代码和客户端代码通过 webpack 分别打包，生成 Server Bundle 和 Client Bundle；

- Server Bundle 会运行在服务器上通过 node 生成预渲染的 HTML 字符串，发送到客户端完成初始化，客户端拿到服务端返回的HTML字符串后，会去“激活”这些静态HTML，使其变成由 Vue 动态管理的 DOM，以便响应后续数据的变化；
- Client Bundle 初始化渲染完不依赖它；

## 独特之处

1. 在 SSR 中，创建 Vue 实例、创建 store 和创建 router 都是套了一层工厂函数，目的就是避免数据的交叉污染；
2. 在服务端只能执行生命周期中的created和beforeCreate，原因是在服务端是无法操纵dom的，所以其他的周期也就是不能执行的了；
3. 服务端渲染和客户端渲染不同，需要创建两个 entry 分别跑在服务端和客户端，并且需要webpack对其分别打包；
4. SSR服务端请求不带cookie，需要手动拿到浏览器的cookie传给服务端的请求；
5. SSR 要求 dom 结构规范，因为浏览器会自动给 HTML 添加一些结构比如 tbody，但是客户端进行混淆服务端放回的 HTML 时，不会添加这些标签，导致混淆后的 HTML 和浏览器渲染的 HTML 不匹配；

## 优缺点

### 优点

1. 更好的 SEO：搜索引擎爬虫抓取工具可以直接查看完全渲染的页面；
2. 更快的内容到达时间（首屏加载更快）：SPA 会等待所有vue编译后的 js 文件都下载完成后，才开始进行页面的渲染，文件下载等需要一定的时间等，所以首屏渲染需要一定的时间；SSR 直接由服务端渲染好页面直接返回显示，无需等待下载 js 文件及再去渲染等，所以 SSR 有更快的内容到达时间；

### 缺点

1. 更多的开发条件限制： 
   - 浏览器特定的代码，只能在某些生命周期钩子函数中使用；
   - 一些外部扩展库需要特殊处理才能在服务器渲染应用程序中运行；
2. 涉及构建设置和部署的更多要求：与可以部署在任何静态文件服务器上的完全静态单页面应用程序 (SPA) 不同，服务器渲染应用程序，需要处于 Node.js server 运行环境；
3. 更多的服务器负载：在 Node.js 中渲染完整的应用程序，会比仅仅提供静态文件的 server 更加大量占用 CPU 资源，因此如果在高流量环境下使用，要准备相应的服务器负载，并明智地采用缓存策略；