## ctx属性

1. 开发环境的 ctx 有 `$router、$store ` 和声明的变量和方法等；
2. 生产环境的 ctx、 `$router、$store ` 和其它的属性都没有了；
3. 避免在代码中使用 ctx 和 通过 `ctx.$router、ctx.$store ` 访问 router 和 store；

```javascript
import { getCurrentInstance } from 'vue'
import { useRouter, useRoute } from 'vue-router'
import { useStore } from 'vuex'

export default {
  setup () {
    const { ctx } = getCurrentInstance()
    const router = useRouter()
    const route = useRoute()
    const store = userStore()
    console.log(router, route, store)
    console.log(router.currentRoute.value)
    const userId = computed(() => store.state.userId)
    return {
      userId
    }
  }
}
```



## 执行顺序

1. vue3.x 中会先执行 setup 方法，再执行兼容 2.x 的其它方法，比如 data、computed、watch 等；
2. 在 setup 执行的过程中，无法访问到 data 中定义的属性；

## mount 挂载

1. 2.x会使用挂载元素的 outerHTML 作为 template，并替换挂载元素；
2. 3.x会使用挂载元素的 innerHTML 作为template，并且只替换挂载元素的子元素；

## $el & refs

1. 2.x可以在组件挂载之后通过 this.$el 访问组件根元素；
2. 3.x去掉this，并且支持 fragment，所以 this.$el 没有存在的意义，建议通过 refs 访问 DOM；
3. 当使用组合式 API 时，reactive refs 和 template refs 的概念都是为了获得对模板内元素或组件实例的引用，可以在 setup() 中声明一个 ref 并返回它；

```javascript
<template>
  <div ref="root"></div>
</template>

<script>
import { ref, onMounted, getCurrentInstance } from 'vue'

export default {
  setup() {
    const vm = getCurrentInstance()
    const root = ref(null)

    onMounted(() => {
      // 渲染完成后, 这个 div DOM 会被赋值给 root ref 对象
      console.log(root.value) // <div/>
      console.log(vm.refs.root) // <div/>
      console.log(root.value === vm.refs.root) // true
    })

    return {
      root
    }
  }
}
</script>
```

### 在 v-for 中使用

2.x 在 v-for 里使用的 ref 属性，this.$refs 会得到一个数组；

3.x 不会自动创建数组，要从单个绑定获取多个 ref ，需要将 ref 绑定到一个函数上；

```javascript
<template>
  <div v-for="(item, i) in list" :key="i" :ref="setItemRef">
    {{ item }}
  </div>
</template>

<script>
import { ref, reactive, onMounted } from 'vue'
export default {
  setup() {
    const list = reactive([1, 2, 3])
    const divs = ref([])

    const setItemRef = (el) => {
      divs.value.push(el)
    }

    onMounted(() => {
      console.log(divs) // [div, div, div]
    })

    return {
      list,
      divs,
      setItemRef
    }
  },
}
</script>
```

## $attr

1. 2.x 中 class 和 style 不属于 $attr，会应用到组件的根元素；
2. 2.x 中 $attr 中的 attribute 不是自动添加到根元素中，是由开发者决定在哪添加；
3. 3.x $attr 包含所有的 attribute，包括 class 和 style，是由开发者决定在哪添加；

## $children

1. 2.x 中，可以使用 this.$children 直接访问当前实例的子组件；
2. 3.x 中，$children property 已移除，不再支持。如果访问子组件实例，建议使用 refs；

## setup返回普通对象

1. setup 返回普通对象的时候，和 reactive 对象一样具备响应式；
2. 为了代码可读性，建议通过 reactive 方法包装；

## directive

3.x 对指令的生命周期钩子进行了改造，类似普通组件的钩子；

```javascript
// 2.x
export default {
  name: 'YourDirectiveName',
  bind(el, binding, vnode, oldVnode) {},
  inserted(...) {},
  update(...) {},
  componentUpdated(...) {},
  unbind(...) {}
}

// 3.x
export default {
  beforeMount(el, binding, vnode, oldVnode) {},
  mounted(...) {},
  beforeUpdate(...) {},
  updated(...) {},
  beforeUnmount(...) {},
  unmounted() {...}
}
```

## Mixin

3.x 当来自组件的 data() 及其 mixin 或 extends 基类被合并时只是将浅层次执行合并；

```javascript
const Mixin = {
  data() {
    return {
      user: {
        name: 'Jack',
        id: 1
      }
    }
  }
}
const CompA = {
  mixins: [Mixin],
  data() {
    return {
      user: {
        id: 2
      }
    }
  }
}

// 2.x 生成的 data
{
  user: {
    id: 2,
    name: 'Jack'
  }
}

// 3.x 生成的 data
{
  user: {
    id: 2
  }
}
```

## $emit

3.x 提供了一个 emits 选项，类似于 props 选项，用于定义组件发送给其父组件的事件；

```javascript
<template>
  <div>
    <p>{{ text }}</p>
    <button v-on:click="handleSubmit()">OK</button>
  </div>
</template>
<script>
  export default {
    props: ['text'],
    emits: ['accepted'],
    setup(props, { emit }) {
      const handleSubmit = ()=>{
        emit('accepted')
      }
      
      return {
        handleSubmit
      }
    }
  }
</script>
```



## render方法

```javascript
// 2.x
export default {
  render(h) {
    return h('div')
  }
}

// 3.x
import { h } from 'vue'
export default {
  render() {
    return h('div')
  }
}
```

## 3.x 移除特性

### on & off & $once

2.x 可以通过 EventBus 来实现组件间的通信；

```javascript
// 声明实例
var EventBus = new Vue()
Vue.prototype.$globalBus = EventBus
// 组件内调用
this.$globalBus.$emit('my-event-name', data)
this.$globalBus.$on('my-event-name', callback)
```

3.x 中移除了 `$on、$off` 等方法，推荐使用 mitt 方案来替代；

```javascript
// 声明实例
import mitt from 'mitt'
const emitter = mitt()
// 组件内调用
emitter.on('*', (type, e) => console.log(type, e))
emitter.on('my-event-name', callback)
emitter.emit('my-event-name', data)
emitter.all.clear()
```

### filters

3.x 移除了组件的 filters 项，可以使用 methods 的或者 computed 来替代；

如果需要全局过滤器，可以通过全局属性在所有组件中使用它；

```javascript
// main.js
const app = createApp(App)

app.config.globalProperties.$filters = {
  currencyUSD(value) {
    return '$' + value
  }
}

// xxx.vue
<template>
  <h1>Bank Account Balance</h1>
  <p>{{ $filters.currencyUSD(accountBalance) }}</p>
</template>
```

## 3.x 新增特性

### 片段