## 生命周期

### beforeCreate

> 在实例初始化后，数据观测（data observer）的 event/watcher 事件配置之前被调用；

### created

> 在实例创建完成后被立即调用，挂载阶段还没开始，$el property 不可用；

在这一步，实例已经完成以下配置：

- 数据观测（data observer）;
- property 和方法的运算；
- watch/event 事件回调；

### beforeMount

> 在挂载之前被调用，相关的 render 函数首次被调用，在钩子在服务器端渲染期间不被调用；

### mounted

> 实例被挂载之后被调用，这时 el 被新建的 vm.$el 替换；

如果根实例挂载到了一个文档内的元素上，当 mounted 被调用时 vm.$el 也在文档内；

mounted 不会保证所有的子组件也都一起被挂载，如果希望等到整个视图都渲染完毕，可以在 mounted 内部使用 vm.$nextTick；

### beforeUpdate

> 数据更新时调用，发生在虚拟 DOM 打补丁之前；

这里适合在更新之前访问现有的 DOM，比如手动移除已添加的事件监听器；

该钩子在服务器端渲染期间不被调用，因为只有初次渲染会在服务端进行；

### updated

> 由于数据更改导致的虚拟 DOM 重新渲染和打补丁，在这之后会调用该钩子；

该钩子在服务器端渲染期间不被调用；

### activated

> 被 keep-alive 缓存的组件激活时调用；

该钩子在服务器端渲染期间不被调用；

### deactivated

> 被 keep-alive 缓存的组件停用时调用；

该钩子在服务器端渲染期间不被调用；

### beforeDestroy

> 实例销毁之前调用，在这一步，实例仍然完全可用；

该钩子在服务器端渲染期间不被调用；

### destroyed

> 实例销毁后调用，该钩子被调用后，对应 Vue 实例的所有指令都被解绑，所有的事件监听器都被移除，所有的子实例也都被销毁；

该钩子在服务器端渲染期间不被调用；

## 组件调用顺序

> 组件的调用顺序是先父后子，渲染完成的顺序是先子后父；

insertedVnodeQueue 被插入的虚拟节点队列；

- 在第一次 patch ,创建新的 vnode 节点时，会先定义一个 insertedVnodeQueue（被插入的虚拟节点队列）
- 然后调用 createElm 创建 DOM 元素，并且收集了 vnode 到 insertedVnodeQueue 队列；
- 如果有子 vnode，就先完成创建子 vnode 的 DOM 生成即优先挂载，最后才是父 vnode 进行挂载；
- parent 将生成的 DOM 插入到目标元素下，最后 patch 的末尾调用了 invokeInsertHook ，用于清空 insertedVnodeQueue 队列；

```javascript
function patch(vnode) {
  // 1.虚拟节点队列
  const insertedVnodeQueue = [];
  
  // 2.创建新节点
  createElm(
    vnode,
    insertedVnodeQueue,
    oldElm._leaveCb ? null : parentElm,
    nodeOps.nextSibling(oldElm)
  )
  
  // 3.清空insertedVnodeQueue队列
  invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch)
}

/** 创建DOM元素，并且append到父元素 */
function createElm (
 vnode,
 insertedVnodeQueue,
 parentElm,
 refElm,
 nested,
 ownerArray,
 index
) {
  const data = vnode.data
  const children = vnode.children
  const tag = vnode.tag
  
  // 1.创建了DOM
  vnode.elm = vnode.ns
    ? nodeOps.createElementNS(vnode.ns, tag)
  	: nodeOps.createElement(tag, vnode)
   setScope(vnode)

   // 2.递归创建子vnode的DOM
   createChildren(vnode, children, insertedVnodeQueue)
   // 3.递归创建好了子vnode，才把自己的vnode推到虚拟节点队列，此时，父虚拟节点在子虚拟节点后面
   if (isDef(data)) {
     // 实质：insertedVnodeQueue.push(vnode)
     invokeCreateHooks(vnode, insertedVnodeQueue)
   }
   
   /** DOM操作了 将生成的DOM append到target DOM（parentVnode.elm） */
   insert(parentElm, vnode.elm, refElm)
}


/** 将DOM append到父元素 */
function insert (parent, elm, ref) {
  if (isDef(parent)) {
    if (isDef(ref)) {
      if (nodeOps.parentNode(ref) === parent) {
        nodeOps.insertBefore(parent, elm, ref)
      }
    } else {
      nodeOps.appendChild(parent, elm)
    }
  }
}
// 清空insertedVnodeQueue队列
function invokeInsertHook (vnode, queue, initial) {
  if (isTrue(initial) && isDef(vnode.parent)) {
    vnode.parent.data.pendingInsert = queue
  } else {
    for (let i = 0; i < queue.length; ++i) {
      queue[i].data.hook.insert(queue[i])
    }
  }
}
```

> 组件的销毁操作是先父后子，销毁完成的顺序是先子后父；

销毁组件的方式是调用组件实例的销毁方法 vm.$destory（）；

1. 先调用 beforeDestory 钩子；
2. 调用 patch 函数来销毁 vnode；
3. 调用销毁完成钩子 destoryed；

```javascript
Vue.prototype.$destroy = function () {
  const vm: Component = this
  
  // 开始销毁组件
  callHook(vm, 'beforeDestroy')
  
  // call the last hook...
  vm._isDestroyed = true
  // invoke destroy hooks on current rendered tree
  vm.__patch__(vm._vnode, null)
  
  // 销毁完成
  callHook(vm, 'destroyed')
}
```

调用 patch 函数来销毁 vnode；

```javascript
function patch() {
  /** 如果 newVnode传了null和oldVnode有传说明销毁oldVnode节点 */
  if (isUndef(vnode)) {
    if (isDef(oldVnode)) invokeDestroyHook(oldVnode)
    return
  }
}
```

invokeDestroyHook 函数先是调用当前的 vnode 的 destory hook，然后再递归子节点 vnode 一一进行实例销毁，但是父 vnode 只有等子 vnode 销毁完成后，才会调用 destoryed 钩子，所以组件销毁的顺序是先父后子，销毁完成的顺序是先子后父；

```javascript
// 销毁vnode和子vnode
function invokeDestroyHook (vnode) {
  let i, j
  const data = vnode.data
  if (isDef(data)) {
    // 销毁vnode
    if (isDef(i = data.hook) && isDef(i = i.destroy)) i(vnode)
  }
  // 递归子节点vnode，进行销毁操作
  if (isDef(i = vnode.children)) {
    for (j = 0; j < vnode.children.length; ++j) {
      invokeDestroyHook(vnode.children[j])
    }
  }
}

componentVNodeHooks = {
  destroy (vnode: MountedComponentVNode) {
    const { componentInstance } = vnode
    if (!componentInstance._isDestroyed) {
      	// 调用的是实例的销毁方法
        componentInstance.$destroy()
    }
  }
}
```

## 访问操作DOM阶段

> 在 mounted 阶段就可以访问操作 DOM 了；

在组件执行挂载 $mount 方法时，会调用 beforemount 钩子，此时 DOM 还未生成，然后开始准备生成 DOM ；

1. 执行 _ render 方法，生成 vnode；
2. 执行 _ patch 方法生成实际 DOM，并被 insert 到父元素，DOM 已挂载，调用 mounted 钩子；

