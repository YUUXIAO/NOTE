## 生命周期

![preview](https://pic2.zhimg.com/v2-8ed5f9b516d6b4b50c91bf46e2935859_r.jpg)

### beforeCreate

> 在实例初始化后，数据观测（data observer）的 event/watcher 事件配置之前被调用；

### created

> 在实例创建完成后被立即调用，挂载阶段还没开始，$el property 不可用；

在这一步，实例已经完成以下配置：

- 数据观测（data observer）;
- property 和方法的运算；
- watch/event 事件回调；

### beforeMount

> 在挂载之前被调用，相关的 render 函数首次被调用，在钩子在服务器端渲染期间不被调用；

### mounted

> 实例被挂载之后被调用，这时 el 被新建的 vm.$el 替换；

如果根实例挂载到了一个文档内的元素上，当 mounted 被调用时 vm.$el 也在文档内；

mounted 不会保证所有的子组件也都一起被挂载，如果希望等到整个视图都渲染完毕，可以在 mounted 内部使用 vm.$nextTick；

### beforeUpdate

> 数据更新时调用，发生在虚拟 DOM 打补丁之前；

这里适合在更新之前访问现有的 DOM，比如手动移除已添加的事件监听器；

该钩子在服务器端渲染期间不被调用，因为只有初次渲染会在服务端进行；

### updated

> 由于数据更改导致的虚拟 DOM 重新渲染和打补丁，在这之后会调用该钩子；

该钩子在服务器端渲染期间不被调用；

### activated

> 被 keep-alive 缓存的组件激活时调用；

该钩子在服务器端渲染期间不被调用；

### deactivated

> 被 keep-alive 缓存的组件停用时调用；

该钩子在服务器端渲染期间不被调用；

### beforeDestroy

> 实例销毁之前调用，在这一步，实例仍然完全可用；

该钩子在服务器端渲染期间不被调用；

### destroyed

> 实例销毁后调用，该钩子被调用后，对应 Vue 实例的所有指令都被解绑，所有的事件监听器都被移除，所有的子实例也都被销毁；

该钩子在服务器端渲染期间不被调用；

### 源码分析

#### callhook 函数

- callhook 函数就是在当前vue组件实例中，调用某个生命周期钩子注册的所有回调函数；
- invokeWithErrorHandling 方法中使用了 apply 和 call 改变了 this 指向，在箭头函数中 this 指向无法改变，所以在编写生命周期函数不能使用箭头函数；

```javascript
export function callHook (vm: Component, hook: string) {
  pushTarget()
  const handlers = vm.$options[hook] 
  // 初始化合并 options 的过程，将各个生命周期函数合并到 options 里
  const info = `${hook} hook`
  if (handlers) {
    for (let i = 0, j = handlers.length; i < j; i++) {
      invokeWithErrorHandling(handlers[i], vm, null, vm, info)
    }
  }
  if (vm._hasHookEvent) {
    vm.$emit('hook:' + hook)
  }
  popTarget()
}

// src/core/util/error.js
export function invokeWithErrorHandling (
  handler: Function,
  context: any,
  args: null | any[],
  vm: any,
  info: string
) {
  let res
  try {
    res = args ? handler.apply(context, args) : handler.call(context)
    if (res && !res._isVue && isPromise(res) && !res._handled) {
      res._handled = true
    }
  } catch (e) {
    handleError(e, vm, info)
  }
  return res
}
```

#### beforeCreate 和 created

- beforeCreate 钩子的调用是在 initState 之前，initState 是对 props、methods、data、computed、watch 等属性进行初始化，所以 beforeCreate 没有以上数据的访问权限；

```javascript
export function initMixin (Vue: Class<Component>) {
  Vue.prototype._init = function (options?: Object) {
    const vm: Component = this
    ...
    // 给vm对象添加了 $parent、$root、$children 属性和其它的生命周期相关的标识
    initLifecycle(vm)  
    // 初始化事件相关的属性
    initEvents(vm) 
    // vm 添加了一些虚拟 dom、slot 等相关的属性和方法
    initRender(vm)  
    // 调用 beforeCreate 钩子
    callHook(vm, 'beforeCreate')  
    // initInjections(vm) 和 initProvide(vm) 配套使用，用于将父组件 _provided 中定义的值，通过 inject 注入到子组件，且这些属性不会被观察
    initInjections(vm) 
    // props、methods、data、watch、computed等数据初始化
    initState(vm)   
    initProvide(vm) 
    // 调用 created 钩子
    callHook(vm, 'created')  
  }
}

// src/core/instance/state
export function initState (vm: Component) {
  vm._watchers = []
  const opts = vm.$options
  if (opts.props) initProps(vm, opts.props)
  if (opts.methods) initMethods(vm, opts.methods)
  if (opts.data) {
    initData(vm)
  } else {
    observe(vm._data = {}, true /* asRootData */)
  }
  if (opts.computed) initComputed(vm, opts.computed)
  if (opts.watch && opts.watch !== nativeWatch) {
    initWatch(vm, opts.watch)
  }
}
```

#### beforeMount 和 mounted

- vm._ render 函数渲染 Vnode 之前执行了 beforeMount 钩子函数，在执行完 vm._update 把 Vnode  patch 到真实 DOM 后，执行 mounted 钩子，所以在 mounted 阶段才拿到 DOM；

```javascript
// mountComponent 核心就是先实例化一个渲染Watcher
// 在它的回调函数中会调用 updateComponent 方法
// 两个核心方法 vm._render(生成虚拟Dom) 和 vm._update(映射到真实Dom)
export function mountComponent (
  vm: Component,
  el: ?Element,
  hydrating?: boolean
): Component {
  vm.$el = el
  if (!vm.$options.render) {
    vm.$options.render = createEmptyVNode
    ...
  }
  callHook(vm, 'beforeMount')  // 调用 beforeMount 钩子

  let updateComponent
  if (process.env.NODE_ENV !== 'production' && config.performance && mark) {
    updateComponent = () => {
    // 将虚拟 Dom 映射到真实 Dom 的函数。
    // vm._update 之前会先调用 vm._render() 函数渲染 VNode
      ...
      const vnode = vm._render()
      ...
      vm._update(vnode, hydrating)
    }
  } else {
    updateComponent = () => {
      vm._update(vm._render(), hydrating)
    }
  }

  new Watcher(vm, updateComponent, noop, {
    before () {
     // 先判断是否 mouted 完成 并且没有被 destroyed
      if (vm._isMounted && !vm._isDestroyed) {
        callHook(vm, 'beforeUpdate')
      }
    }
  }, true /* isRenderWatcher */)

  if (vm.$vnode == null) {
    vm._isMounted = true
    callHook(vm, 'mounted')  //调用 mounted 钩子
  }
  return vm
}
```

#### beforeUpdate和updated

Vue 是通过 watcher 来监听实例上的数据变化，进而控制渲染流程；

```javascript
 new Watcher(vm, updateComponent, noop, {
    before () {
     // 先判断是否 mouted 完成 并且没有被 destroyed
      if (vm._isMounted && !vm._isDestroyed) {
        // 调用 beforeUpdate 钩子
        callHook(vm, 'beforeUpdate')  
      }
    }
  }, true /* isRenderWatcher */)
 
 // src/core/observer/scheduler 
 function callUpdatedHooks (queue) {
   let i = queue.length
   while (i--) {
     const watcher = queue[i]
     const vm = watcher.vm
     if (vm._watcher === watcher && vm._isMounted && !vm._isDestroyed) {
       // 只有满足当前 watcher 为 vm._watcher（也就是当前的渲染watcher）
       // 以及组件已经 mounted 并且没有被 destroyed 才会执行 updated 钩子函数
       callHook(vm, 'updated')  
       }
     }
 }
```

```javascript
export default class Watcher {
  ...
  constructor (
    vm: Component,
    expOrFn: string | Function,
    cb: Function,
    options?: ?Object,
    // 在它的构造函数里会判断 isRenderWatcher，
    // 接着把当前 watcher 的实例赋值给 vm._watcher
    isRenderWatcher?: boolean
  ) {
    // 还把当前 wathcer 实例 push 到 vm._watchers 中，
    // vm._watcher 是专门用来监听 vm 上数据变化然后重新渲染的,所以它是一个渲染相关的 watcher，因此在 callUpdatedHooks 函数中，
    // 只有 vm._watcher 的回调执行完毕后，才会执行 updated 钩子函数
    this.vm = vm
    if (isRenderWatcher) {
      vm._watcher = this
    }
    vm._watchers.push(this)
    ...
}
```

#### beforeDestroy和destroyed

```javascript
  // 在 $destroy 的执行过程中，它会执行 vm.__patch__(vm._vnode, null)
  // 触发它子组件的销毁钩子函数，这样一层层的递归调用，所以 destroy 钩子函数执行顺序是先子后父，和 mounted 过程一样
  Vue.prototype.$destroy = function () {
    const vm: Component = this
    if (vm._isBeingDestroyed) {
      return
    }
    // 调用 beforeDestroy 钩子
    callHook(vm, 'beforeDestroy')  
    vm._isBeingDestroyed = true
    // 一些销毁工作
    const parent = vm.$parent
    if (parent && !parent._isBeingDestroyed && !vm.$options.abstract) {
      remove(parent.$children, vm)
    }
    // 拆卸 watchers
    if (vm._watcher) {
      vm._watcher.teardown()
    }
    let i = vm._watchers.length
    while (i--) {
      vm._watchers[i].teardown()
    }
    ...
    vm._isDestroyed = true
    // 调用当前 rendered tree 上的 destroy 钩子
    // 发现子组件，会先去销毁子组件
    vm.__patch__(vm._vnode, null)
    // 调用 destroyed 钩子
    callHook(vm, 'destroyed')  
    // 关闭所有实例侦听器。
    vm.$off()
    // 删除 __vue__ 引用
    if (vm.$el) {
      vm.$el.__vue__ = null
    }
    // 释放循环引用
    if (vm.$vnode) {
      vm.$vnode.parent = null
    }
  }
}
```

## 组件调用顺序

> 组件的调用顺序是先父后子，渲染完成的顺序是先子后父；

insertedVnodeQueue 被插入的虚拟节点队列；

- 在第一次 patch ,创建新的 vnode 节点时，会先定义一个 insertedVnodeQueue（被插入的虚拟节点队列）
- 然后调用 createElm 创建 DOM 元素，并且收集了 vnode 到 insertedVnodeQueue 队列；
- 如果有子 vnode，就先完成创建子 vnode 的 DOM 生成即优先挂载，最后才是父 vnode 进行挂载；
- parent 将生成的 DOM 插入到目标元素下，最后 patch 的末尾调用了 invokeInsertHook ，用于清空 insertedVnodeQueue 队列；

```javascript
function patch(vnode) {
  // 1.虚拟节点队列
  const insertedVnodeQueue = [];
  
  // 2.创建新节点
  createElm(
    vnode,
    insertedVnodeQueue,
    oldElm._leaveCb ? null : parentElm,
    nodeOps.nextSibling(oldElm)
  )
  
  // 3.清空insertedVnodeQueue队列
  invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch)
}

/** 创建DOM元素，并且append到父元素 */
function createElm (
 vnode,
 insertedVnodeQueue,
 parentElm,
 refElm,
 nested,
 ownerArray,
 index
) {
  const data = vnode.data
  const children = vnode.children
  const tag = vnode.tag
  
  // 1.创建了DOM
  vnode.elm = vnode.ns
    ? nodeOps.createElementNS(vnode.ns, tag)
  	: nodeOps.createElement(tag, vnode)
   setScope(vnode)

   // 2.递归创建子vnode的DOM
   createChildren(vnode, children, insertedVnodeQueue)
   // 3.递归创建好了子vnode，才把自己的vnode推到虚拟节点队列，此时，父虚拟节点在子虚拟节点后面
   if (isDef(data)) {
     // 实质：insertedVnodeQueue.push(vnode)
     invokeCreateHooks(vnode, insertedVnodeQueue)
   }
   
   /** DOM操作了 将生成的DOM append到target DOM（parentVnode.elm） */
   insert(parentElm, vnode.elm, refElm)
}


/** 将DOM append到父元素 */
function insert (parent, elm, ref) {
  if (isDef(parent)) {
    if (isDef(ref)) {
      if (nodeOps.parentNode(ref) === parent) {
        nodeOps.insertBefore(parent, elm, ref)
      }
    } else {
      nodeOps.appendChild(parent, elm)
    }
  }
}
// 清空insertedVnodeQueue队列
function invokeInsertHook (vnode, queue, initial) {
  if (isTrue(initial) && isDef(vnode.parent)) {
    vnode.parent.data.pendingInsert = queue
  } else {
    for (let i = 0; i < queue.length; ++i) {
      queue[i].data.hook.insert(queue[i])
    }
  }
}
```

> 组件的销毁操作是先父后子，销毁完成的顺序是先子后父；

销毁组件的方式是调用组件实例的销毁方法 vm.$destory（）；

1. 先调用 beforeDestory 钩子；
2. 调用 patch 函数来销毁 vnode；
3. 调用销毁完成钩子 destoryed；

```javascript
Vue.prototype.$destroy = function () {
  const vm: Component = this
  
  // 开始销毁组件
  callHook(vm, 'beforeDestroy')
  
  // call the last hook...
  vm._isDestroyed = true
  // invoke destroy hooks on current rendered tree
  vm.__patch__(vm._vnode, null)
  
  // 销毁完成
  callHook(vm, 'destroyed')
}
```

调用 patch 函数来销毁 vnode；

```javascript
function patch() {
  /** 如果 newVnode传了null和oldVnode有传说明销毁oldVnode节点 */
  if (isUndef(vnode)) {
    if (isDef(oldVnode)) invokeDestroyHook(oldVnode)
    return
  }
}
```

invokeDestroyHook 函数先是调用当前的 vnode 的 destory hook，然后再递归子节点 vnode 一一进行实例销毁，但是父 vnode 只有等子 vnode 销毁完成后，才会调用 destoryed 钩子，所以组件销毁的顺序是先父后子，销毁完成的顺序是先子后父；

```javascript
// 销毁vnode和子vnode
function invokeDestroyHook (vnode) {
  let i, j
  const data = vnode.data
  if (isDef(data)) {
    // 销毁vnode
    if (isDef(i = data.hook) && isDef(i = i.destroy)) i(vnode)
  }
  // 递归子节点vnode，进行销毁操作
  if (isDef(i = vnode.children)) {
    for (j = 0; j < vnode.children.length; ++j) {
      invokeDestroyHook(vnode.children[j])
    }
  }
}

componentVNodeHooks = {
  destroy (vnode: MountedComponentVNode) {
    const { componentInstance } = vnode
    if (!componentInstance._isDestroyed) {
      	// 调用的是实例的销毁方法
        componentInstance.$destroy()
    }
  }
}
```

## 访问操作DOM阶段

> 在 mounted 阶段就可以访问操作 DOM 了；

在组件执行挂载 $mount 方法时，会调用 beforemount 钩子，此时 DOM 还未生成，然后开始准备生成 DOM ；

1. 执行 _ render 方法，生成 vnode；
2. 执行 _ patch 方法生成实际 DOM，并被 insert 到父元素，DOM 已挂载，调用 mounted 钩子；

