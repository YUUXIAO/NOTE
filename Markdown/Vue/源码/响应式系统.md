## 数据初始化

initState 的过程是对数据进行响应式设计的过程，会针对 props，methods，data，computed 和 watch 做数据的初始化处理，并将它们转换为响应式对象；

```javascript
function initState (vm) {
  vm._watchers = [];
  var opts = vm.$options;
  // 初始化props
  if (opts.props) { initProps(vm, opts.props); }
  // 初始化methods
  if (opts.methods) { initMethods(vm, opts.methods); }
  // 初始化data
  if (opts.data) {
    initData(vm);
  } else {
    // 如果没有定义data，则创建一个空对象，并设置为响应式
    observe(vm._data = {}, true /* asRootData */);
  }
  // 初始化computed
  if (opts.computed) { initComputed(vm, opts.computed); }
  // 初始化watch
  if (opts.watch && opts.watch !== nativeWatch) {
    initWatch(vm, opts.watch);
  }
}
```

## initProps

> 父组件通过属性的形式将数据传递给子组件，子组件通过 props 属性接收父组件传递的值；

```javascript
// 父组件
<child :test="test"></child>
var vm = new Vue({
  el: '#app',
  data() {
    return {
      test: 'child'
    }
  }
})
// 子组件
Vue.component('child', {
  template: '<div>{{test}}</div>',
  props: ['test']
})
```

- 父组件优先进行模板编译得到一个 render 函数，在解析过程中遇到子组件的属性，：test = test 会被解析成 { attrs: {test： test}} 并作为子组件的 render 函数存在：

  ```javascript
  with(){..._c('child',{attrs:{"test":test}})}
  ```

- render 解析 Vnode 过程遇到 child 这个子点位符节点，进入创建子组件 Vnode 的过程，过程是调用 createComponent，最终会调用 new Vnode 去创建子 Vnode；

- 对于 props 的处理，extractPropsFromVNodeData 会对 attrs 属性进行规范校验后，最后会把校验后的结果以 propsData 属性的形式传入 Vnode 构造器中；

- props 传递给点位符组件的写法，会以 propsData 的形式作为子组件 Vnode 的属性存在；

```javascript
// 创建子组件过程
function createComponent() {
  // props校验
  var propsData = extractPropsFromVNodeData(data, Ctor, tag);
  ···
  // 创建子组件vnode
  var vnode = new VNode(
    ("vue-component-" + (Ctor.cid) + (name ? ("-" + name) : '')),
    data, undefined, undefined, undefined, context,
    { Ctor: Ctor, propsData: propsData, listeners: listeners, tag: tag, children: children },
    asyncFactory
  );
}
```

### props的命名规范

```javascript
function extractPropsFromVNodeData (data,Ctor,tag) {
  // Ctor为子类构造器
  ···
  var res = {};
  // 子组件props选项
  var propOptions = Ctor.options.props;
  // data.attrs针对编译生成的render函数，data.props针对用户自定义的render函数
  var attrs = data.attrs;
  var props = data.props;
  if (isDef(attrs) || isDef(props)) {
    for (var key in propOptions) {
      // aB 形式转成 a-b
      var altKey = hyphenate(key);
      {
          var keyInLowerCase = key.toLowerCase();
          if (
            key !== keyInLowerCase &&
            attrs && hasOwn(attrs, keyInLowerCase)
          ) {
            // 警告
          }
        }
    }
  }
}
```

###  响应式数据props

- 子组件处理 props 的过程是发生在父组件 _update 阶段，这个阶段是 Vnode 生成真实节点的过程；
- 期间会遇到子 Vnode，这时会调用 createComponent 去实例化组件；
- 实例化子组件的过程又回到了 _init 初始化，此时会经历选项的合并，针对 props 选项，最终会统一成 {props: { test: { type: null }}} 的写法；
- 接着调用 initProps, initProps 做的事情，将组件的 props 数据设置为响应式数据；

```javascript
function initProps (vm, propsOptions) {
  var propsData = vm.$options.propsData || {};
  var loop = function(key) {
    ···
    defineReactive(props,key,value,cb)；
    if (!(key in vm)) {
      proxy(vm, "_props", key);
    }
  }
  // 遍历props，执行loop设置为响应式数据。
  for (var key in propsOptions) loop( key );
}
```

proxy(vm, "_props", key) 为 props 做了一层代理，用户通过 vm.xxx 可以代理访问到 vm._props 上的值；

## initMethods

> initMethods 方法主要是保证 methods 方法定义必须是函数，且命名不能和 props 重复，最终会将定义的方法都挂载到根实例上；

```javascript
function initMethods (vm, methods) {
  var props = vm.$options.props;
  for (var key in methods) {
    {
      // method必须为函数形式
      if (typeof methods[key] !== 'function') {
        warn(
          "Method \"" + key + "\" has type \"" + (typeof methods[key]) + "\" in the component definition. " +
          "Did you reference the function correctly?",
          vm
        );
      }
      // methods方法名不能和props重复
      if (props && hasOwn(props, key)) {
        warn(
          ("Method \"" + key + "\" has already been defined as a prop."),
          vm
        );
      }
      //  不能以_ or $.这些Vue保留标志开头
      if ((key in vm) && isReserved(key)) {
        warn(
          "Method \"" + key + "\" conflicts with an existing Vue instance method. " +
          "Avoid defining component methods that start with _ or $."
        );
      }
    }
    // 直接挂载到实例的属性上,可以通过vm[method]访问。
    vm[key] = typeof methods[key] !== 'function' ? noop : bind(methods[key], vm);
  }
}
```

## initData

- data 在初始化选项合并时会生成一个函数，只有在执行函数时才会返回真正的数据，所以 initData 方法会执行拿到组件的 data 数据，并且会对对象每个属性的命名进行校验，保证不能和 props，methods 重复；
- 核心的方法是 observe，observe 方法是将数据对象标记为响应式对象，并对对象的每个属性进行响应式处理；