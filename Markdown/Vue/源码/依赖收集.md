参考：https://zhuanlan.zhihu.com/p/45081605

## 响应式系统

每个组件实例都有相应的 Watcher 实例对象，它会在组件渲染的过程中把属性记录为依赖，之后当依赖项的 setter 被调用时，会通知 watcher 重新计算，使它关联的组件更新；

![img](https://user-gold-cdn.xitu.io/2018/7/7/164750f108b480ad?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

## Observe 类

> Observe 类主要给响应式对象的属性添加 getter/setter，用于添加依赖收集与派发更新；

1. 将 Observer 类的实例挂载在 _ ob _ 属性上，提供后续观测数据使用，以及避免被重复实例化；
2. 实例化 Dep 实例，并且将对象/数组做为 value 属性保存下来；
3. 如果 value 是个对象，就执行 walk 过程，遍历对象把每一项数据都变成可观测数据；
4. 如果 value 是个数组，就执行 observeArray 过程，递归地对数组元素调用 observe，以便能够对元素还是数组的情况进行处理；

Observer 的构造函数使用 defineReactive 方法给对象的键响应式化，给对象的属性递归添加  getter/setter，当 data 被取值时触发 getter 并搜集依赖，当被修改值时先触发 getter 再触发 setter 并派发更新；

```javascript
// src/core/observer/index.js
export class Observer {
  value: any;
  dep: Dep;

  constructor (value: any) {
    value: any;
    this.dep = new Dep()
    // def方法保证不可枚举
    def(value, '__ob__', this)    
    this.walk(value)
  }

  // 遍历对象的每一个属性并将它们转换为getter/setter
  walk (obj: Object) {
    const keys = Object.keys(obj)
    // 把所有可遍历的对象响应式化
    for (let i = 0; i < keys.length; i++) { 
      defineReactive(obj, keys[i])
    }
  }
}

export function defineReactive ( obj: Object, key: string, val: any, customSetter?: ?Function, shallow?: boolean) {
  // 在每个响应式键值的闭包中定义一个dep对象
  const dep = new Dep()         

  // 如果之前该对象已经有getter/setter则将其缓存，新定义的getter/setter中会将其执行
  const getter = property && property.get
  const setter = property && property.set

  let childOb = !shallow && observe(val)
  Object.defineProperty(obj, key, {
    enumerable: true,
    configurable: true,
    get: function reactiveGetter () {
      // 如果原本对象拥有getter方法则执行
      const value = getter ? getter.call(obj) : val   
      // 如果当前有watcher在读取当前值
      if (Dep.target) {
        // 那么进行依赖收集，dep.addSub
        dep.depend()                       
      }
      return value
    },
    set: function reactiveSetter (newVal) {
      // 先getter
      const value = getter ? getter.call(obj) : val   
      // 如果跟原来值一样则不管
      if (newVal === value || (newVal !== newVal && value !== value)) {   
        return
      }
      // 如果原本对象拥有setter方法则执行
      if (setter) { setter.call(obj, newVal) }         
      else { val = newVal }
      // 发生变更则通知更新，调用watcher.update()
      dep.notify()                                     
    }
  })
}
```

### getter

getter 的时候进行依赖的收集，只有在 Dep.target 中有值的时候才会进行依赖收集，Dep.target 是在 Watcher 实例的 get 方法调用时通过 pushTarget 会把当前取值的 watcher 推入 Dep.target；

原先的 watcher 压栈到 targetStack 栈中，当前取值的 watcher 取值结束后出栈并把原先的 watcher 值赋给  Dep.target，cleanupDeps 最后把新的 newDeps 里已经没有的 watcher 清空，以防视图上已经不需要的无用的 watcher 触发；

### setter

setter 的时候首先 getter,并且比对新旧值没有变化则 return，如果发生变更，则 dep 通知所有 subs 中存放的依赖本数据的 Watcher 实例 update 进行更新；

update 会 queueWatcher( ) 异步推送到调度者观察队列 queue 中，在 nextTick 时 flushSchedulerQueue（）把 队列中的 watcher 取出来执行 watcher.run 且执行相关钩子函数；

### observe 方法

> observe 方法主要用 data 作为参数去实例化一个 Observer 对象实例 _ ob _，成功创建则返回新的 Observer 实例，如果已有 Observer 实例则返回现有 Observer 实例；

在生产每个组件的 Component 类的构造函数里，会进行一个组件实例化前的一系列动作，其中与依赖收集的相关如下：

```javascript
this._ob = observe(options.data)
this._watchers = []
this._watcher = new Watcher(this, render, this._update)
this._update(this._watcher.value)
```

observe 方法只为对象/数组实例一个 Observer 类的实例，而且只实例化一次，并且需要数据是可配置时才会实例化 Observer 实例；

```javascript
// src/core/observer/index.js
export function observe (value: any, asRootData: ?boolean): Observer | void {
   if (!value || typeof value !== 'object') {
      return
    }
    var ob
    if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {
      ob = value.__ob__
    } else if (shouldConvert && (isArray(value) || isPlainObject(value)) && Object.isExtensible(value) && !value._isVue) {
      ob = new Observer(value)
    }
    if (ob && vm) {
      ob.addVm(vm)
    }
    return ob
}
```

### 观测数组

Object.defineProperty 方法在处理数组拦截上存在问题，只有在对数组重新赋值操作时才会被 setter 检测到；

```javascript
data.arr; // 取值过程被拦截了
data.arr[0] = 1;  // 取值过程被拦截了
data.arr.push(4); // 取值过程被拦截了
data.arr.pop(); // 取值过程被拦截了
data.arr.shift(); // 取值过程被拦截了
data.arr.unshift(5); // 取值过程被拦截了
data.arr.splice(0, 1); // 取值过程被拦截了
data.arr.sort((a, b) => a - b); // 取值过程被拦截了
data.arr.reverse(); // 取值过程被拦截了
data.arr = [4, 5, 6] // 新的值是4,5,6
```

为了能检测到数组的变更操作，在传入的数据是一个数组时，Vue 会进行处理；

1. 在数组的原型链上定义一系列操作方法，以此实现数组的变更检测；
2. 定义一组原型方法在 arr._ proto _ 指向的那个原型对象上；
3. 如果浏览器不支持 _ proto _ ，就直接挂载在数组对象本身上；
4. 再进行数组项的观测操作；

```javascript
var augment = hasProto
  ? protoAugment
  : copyAugment
augment(value, arrayMethods, arrayKeys)
this.observeArray(value)
```

1. 保留数组原来的操作：push、unshift、splice 等方法，会带来新的数据元素；
2. 新增的元素也需要被配置为可观测数据；
3. 对新增元素调用 observer 实例上的 observeArray 方法进行一遍观测处理；
4. 数组变更了，通过 ob.dep.notify 方法对数组的 watchers 进行通知；

```javascript
;[
  'push',
  'pop',
  'shift',
  'unshift',
  'splice',
  'sort',
  'reverse'
]
.forEach(function (method) {
  var original = arrayProto[method]
  def(arrayMethods, method, function mutator () {
    var i = arguments.length
    var args = new Array(i)
    while (i--) {
      args[i] = arguments[i]
    }
    var result = original.apply(this, args)
    var ob = this.__ob__
    var inserted
    switch (method) {
      case 'push':
        inserted = args
        break
      case 'unshift':
        inserted = args
        break
      case 'splice':
        inserted = args.slice(2)
        break
    }
    if (inserted) ob.observeArray(inserted)
    ob.dep.notify()
    return result
  })
})
```

## Dep 类

> Dep 类用于收集当前响应式对象的依赖关系，是依赖收集的容器，它记录了哪些 Watcher 订阅了自己的变化；

- Dep 类实例依附每个数据而出来，用来管理依赖数据的 Watcher 实例；
- 由于 JS 是单线程模型，虽然有多个观察者函数，但是一个时刻内只会有一个观察者函数在执行，此时正在执行的观察者函数对应的 watcher 实例，会赋值给 Dep.target 这个变量，只要访问Dep.target就能知道当前的观察者是谁，在后续的依赖收集工作里， getter 里会调用dep.depend()，而 setter 里则会调用 dep.notify()；
- 只要会被别的观察者（watchers）依赖，比如 data，data 的属性，计算属性，props 等，就会在闭包里生成一个 Dep 实例 dep，并在调用 getter 时 dep.depend 收集它被谁依赖了，并把被依赖的 watcher 存放到自己的 subs 中，以便在自身改变时通知 subs 数组中依赖自己的 watcher 及时 update；

```javascript
// src/core/observer/dep.js
let uid = 0            // Dep实例的id，为了方便去重

export default class Dep {
  static target: ?Watcher           // 当前是谁在进行依赖的收集
  id: number
  subs: Array<Watcher>              // 观察者集合
  
  constructor() {
    this.id = uid++            
    // 存储收集器中需要通知的Watcher
    this.subs = []                              
  }
  // 添加一个观察者对象
  addSub(sub: Watcher) { 
  	this.subs.push(watcher);
  }  
  // 移除一个观察者对象
  removeSub(sub: Watcher) { ... }  
  // 依赖收集，当存在Dep.target的时候把自己添加观察者的依赖中
  depend() { 
  	if(Dep.target){
      Dep.target.addDep(this);
    }
  } 
  // 通知所有订阅者
  notify() { 
  	this.subs.forEach(watcher=>watcher.update());
  } 
}

const targetStack = []  // watcher栈          

// 将watcher观察者实例设置给Dep.target，用以依赖收集,同时将该实例存入target栈中
export function pushTarget(_target: ?Watcher) { 
  Dep.target = watcher;
} 
// 将观察者实例从target栈中取出并设置给Dep.target
export function popTarget() { 
  Dep.target = null
} 
```



### 配置数据观测

每个数据都会有一个 Dep 类的实例：

```javascript
// 配置前数据
{
    a: 1,
    b: [2, 3, 4],
    c: {
        d: 5
    }
}

// 配置完数据
{
    __ob__,   // dep(uid:0)
    a: 1,   // dep(uid:1)
    b: [2, 3, 4],  // dep(uid:2), b.__ob__.dep(uid:3)
    c: {
        __ob__,  // dep(uid:4), c.__ob__.dep(uid:5)
        d: 5， // dep(uid:6)
    }
}
```

- 对于数组和对象，配置依赖观测后，会实例化两个 Dep 类实例；

- 数组和对象是引用数据类型，存在两种操作：改变引用和改变内容；

  ```javascript
  data.b = [4, 5, 6]; // 改变引用
  data.b.push(7); // 改变内容
  ```

- 改变引用的情况，在 Object.defineProperty 方法是可以被检测到的，闭包里的 dep 可以收集这种依赖；

- 改变内容不能被 Object.defineProperty 方法检测到，所以对数组变异操作进行了封装，就需要在数组上挂 _ ob _ 属性，在 _ ob _ 上挂载 dep 实例，用来处理改变内容的情况，形成追踪链路；

## Watcher 类

> Watcher 类是观察者角色，它关心数据，在数据变化后能够获得通知并作出处理；

一个组件可以有多个 Watcher 类实例， Watcher 类包装观察者函数，观察者函数使用数据；

```javascript
computed: {
    name() {
        return `${this.firstName} ${this.lastName}`;
    }
}

// 会形成
new Watcher(this, function name() {
    return `${this.firstName} ${this.lastName}`
}, callback);
```

```
只要依赖别的响应式化对象的对象，都会生成一个观察者 watcher，用来统计这个 watcher 依赖了哪些响应式对象，在这个 watcher 求值前把当前 watcher 设置到全局 Dep.target，并在自己依赖的响应式对象发生改变时及时 update;
```

get 方法中执行的 getter 就是在开始 new 渲染 watcher 时传入的 ：

```
updateComponent = () => { vm._update(vm._render(), hydrating) }
```

这个方法首先 vm._ render 生成渲染 Vnode，在这个过程中完成对当前 Vue 实例 vm 上的数据访问，触发相应响应式对象的 getter，然后 vm._ update 方法去 patch；

get 方法最后执行了 getAndInvoke 方法，这个方法首先遍历 watcher 中存的 deps，移除 newDep 中已经没有的订阅，然后 depIds = newDepIds; deps = newDeps，清空 newDepIds 和 newDeps；

每次添加完新的订阅后移除旧的已经不需要的订阅，这样在某些情况，比如 v-if 已经不需要的模板依赖的数据发生变化时就不会通知 watcher 去 update；

- deps：缓存上一轮执行观察者函数用到的 dep 实例；
- depIds：Hash 表，用于快速查找；
- newDeps：存储本轮执行观察者函数用到的 dep 实例；
- newDepIds：Hash 表，用于快速查找

```javascript
// 一个解析表达式，进行依赖收集的观察者，同时在表达式数据变更时触发回调函数。它被用于$watch api以及指令
export default class Watcher {
  constructor(
    vm: Component,
    expOrFn: string | Function,
    cb: Function,
    options?: ?Object,
    isRenderWatcher?: boolean      // 是否是渲染watcher的标志位
  ) {
    // 在get方法中执行
    this.getter = expOrFn     
    // 是否是计算属性,计算属性创建过程中并未求值
    if (this.computed) {                   
      this.value = undefined
      this.dep = new Dep()                 
    } else {   
      // 不是计算属性会立刻求值
      this.value = this.get()
    }
  }

  // 获得getter的值并且重新进行依赖收集 
  get() {
    // 设置Dep.target = this
    pushTarget(this)                
    let value
    value = this.getter.call(vm, vm)
    // 将观察者实例从target栈中取出并设置给Dep.target
    popTarget()                      
    this.cleanupDeps()
    return value
  }
  // 添加一个依赖关系到Deps集合中
  addDep(dep: Dep) { ... } 
  // 清理newDeps里没有的无用watcher依赖 
  cleanupDeps() { ... } 
  // 调度者接口，当依赖发生改变的时候进行回调
  update() { 
     queueWatcher(this);
  } 
  // 调度者工作接口，将被调度者回调
  run() { ... } 
  getAndInvoke(cb: Function) { ... }
  // 收集该watcher的所有deps依赖
  evaluate() { ... }
  // 收集该watcher的所有deps依赖，只有计算属性使用
  depend() { ... }  
  // 将自身从所有依赖收集订阅列表删除
  teardown() { ... } 
}
```

### addDep

Dep.target 是 Watcher 类的实例，调用 dep.depend（）相当于调用了 watcher.addDep 方法；

1. 判断本轮计算中是否收集过这个依赖，收集过就不再收集，没有收集过就加入 newDeps；
2. 判断有无缓存过依赖，缓存过就不再加入 dep.subs 里；

```javascript
Watcher.prototype.addDep = function (dep) {
    var id = dep.id
    if (!this.newDepIds[id]) {
        this.newDepIds[id] = true
        this.newDeps.push(dep)
        if (!this.depIds[id]) {
            dep.addSub(this)
        }
    }
}
```



### 使用场景

Watcher 实例有三种类型：

1. render watcher：渲染 watcher，渲染视图用的 watcher；
2. computed watcher：计算属性 watcher，计算属性依赖别人也被别人依赖，因此也会持有一个 Dep 实例；
3. watch watcher：侦听器 watcher；

### 工作流程

1. 传入组件实例、观察者函数、回调函数、选项配置；
2. 进入初始求值，会调用 watcher.get 方法；
3. watcher.get 方法会做这些处理：初始准备工作，调用观察者函数计算，事后清理工作；
4. 初始准备工作中，会将当前 Watcher 实例赋值给 Dep.target，清空 new Deps、newDepIds；
5. 执行观察者函数进行计算，由于数据观测阶段执行了 defineReactive 方法，所以计算中用到的数据会得以访问，从而触发数据的 getter，从而执行 watcher.addDep 方法，将特定的数据记为依赖；
6. 对每个数据执行 watcher.addDep 方法后，数据对应的 dep 如果在 newDeps 里不存在，就会加入到 newDeps 里，因为一次计算过程中数据可能被多次使用，但是同样的依赖只能收集一次，并且如果在 deps 不存在，表示上一轮计算中，当前 watcher 未依赖过某个数据，那个数据对应的 dep.subs 里也不存在当前 watcher，所以要将当前 watcher  加入到数据的 dep.subs 中；
7. 进行事后清理工作，首先释放 Dep.target，然后拿 newDeps 和 deps 进行对比，deps 里存的数据表示是过期的缓存数据，相应的，从数据对应的 dep.subs 移除掉当前 watcher，将 newDeps 赋值给 deps，表示缓存本轮的计算结果，这样子下轮计算如果再依赖同一个数据就不需要再收集了；
8. 当某个数据更新时，由于进行了 setter 拦截，所以会对该数据的 dep.subs 这一观察者队列时的 watchers 进行通知，从而执行了 watcher.update 方法，而 update 方法会重复求值的过程（步骤3-7），从而使观察者函数重新计算，而 render 方法这种观察者函数重新计算的结果，就使得视图同步了更新的数据；

## defineReative

Vue 使用 Object.defineProperty 方法来拦截数据的操作，封装在了 defineReative 方法里；

1. Object.defineProperty() 里的 get/set 方法相对于 var dep = new Dep() 形成了闭包，保存了 dep 实例；

2. getter 里面进行了依赖的收集工作，如果某个观察者函数访问了某个数据就认为这个观察者函数是依赖这个数据的；

   ```html
   <template>
       <div>I am {{a}}，plus 1 is {{newValue}}</div>
   </template>
   ```

   - 对应了两个观察者函数：计算属性 newValue 和 render（）函数，它们会被包装为两个 watcher；
   - 在执行 render 函数渲染的过程中，访问了 data.a，从而使 data.a 的 dep.subs 里加入了 render@watcher，又访问了计算属性 newValue，计算属性里访问了 data.a，使得 data.a 的 dep.subs 里加入了 newValue@watcher，所以 data.a 的 dep.subs 里就有了[render@watcher, newValue@watcher ]；
   - 在访问 getter 之前，就已经进入了某个 watcher 的上下文了，Watcher 类的实例 watcher 已经准备好了，并且已经调用了 watcher.get（），Dep.target 是有值的，所以 getter 里面进入依赖收集的写法是 dep.depend（）并没有传入参数，因为只需要把 Dep.target 加入当前 dep.subs 就好了；
   - Dep.prototype.depend 方法是调用 Dep.target.addDep(this) 而不是直接将 Dep.target 加入 dep.subs，因为要保证 subs 里每一个 watcher 是唯一的；

3. setter 里面进行的是在值变更后，通知 watcher 进行重新计算，由于setter 能访问到闭包中的 dep，所以就能获得 dep.subs，知道有哪些 watcher 依赖于当前数据，通过调用 dep.notify 来遍历 subs 里的 watcher，执行每个  watcher 的 update 方法，让每个 watcher 重新进行计算；

```javascript
function defineReactive (obj, key, val) {
    var dep = new Dep()
    var property = Object.getOwnPropertyDescriptor(obj, key)
    if (property && property.configurable === false) {
        return
    }
    var getter = property && property.get
    var setter = property && property.set

    var childOb = observe(val)
    Object.defineProperty(obj, key, {
        enumerable: true,
        configurable: true,
        get: function reactiveGetter () {
            var value = getter ? getter.call(obj) : val
            if (Dep.target) {
                dep.depend()
                if (childOb) {
                    childOb.dep.depend()
                }
                if (isArray(value)) {
                    for (var e, i = 0, l = value.length; i < l; i++) {
                        e = value[i]
                        e && e.__ob__ && e.__ob__.dep.depend()
                    }
                }
            }
            return value
        },
        set: function reactiveSetter (newVal) {
            var value = getter ? getter.call(obj) : val
            if (newVal === value) {
                return
            }
            if (setter) {
                setter.call(obj, newVal)
            } else {
                val = newVal
            }
            childOb = observe(newVal)
            dep.notify()
        }
    })
}
```

## 总结

Vue的依赖收集，是 观察者 模式的一种应用：



![preview](https://pic4.zhimg.com/v2-22c29a1c5ab746ad942e0c02417b05db_r.jpg)

### 配置依赖观测

![img](https://pic2.zhimg.com/80/v2-8b0bb8bc216cb96ae46c21ba190aceb5_720w.jpg)

### 收集依赖

![img](https://pic4.zhimg.com/80/v2-e0608a870de75fcf3abccbd5af8ffcc7_720w.jpg)

### 数据值变更

![img](https://pic1.zhimg.com/80/v2-13f90743f55bfaf6d427c192451bc070_720w.jpg)

