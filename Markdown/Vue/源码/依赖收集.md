## 响应式系统

每个组件实例都有相应的 Watcher 实例对象，它会在组件渲染的过程中把属性记录为依赖，之后当依赖项的 setter 被调用时，会通知 watcher 重新计算，使它关联的组件更新；

![img](https://user-gold-cdn.xitu.io/2018/7/7/164750f108b480ad?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

## Observe 类

> Observe 类主要给响应式对象的属性添加 getter/setter，用于添加依赖收集与派发更新；

## Dep 类

> Dep 类用于收集当前响应式对象的依赖关系；

## Watcher 类

> Watcher 类是观察者，实例分为渲染 watcher，计算属性 watcher，侦听器 watcher 三种；

## 源码实现

### initState

响应式化的入口在 initState 方法中；

```javascript
// src/core/instance/state.js
export function initState(vm: Component) {
  const opts = vm.$options
  // 初始化props
  if (opts.props) initProps(vm, opts.props)    
  // 初始化methods
  if (opts.methods) initMethods(vm, opts.methods)     
  // 初始化data
  if (opts.data) initData(vm)        
  // 初始化computed
  if (opts.computed) initComputed(vm, opts.computed)    
  // 初始化watch
  if (opts.watch) initWatch(vm, opts.watch)              
  }
}
```

#### initData

1. 首先判断 data 是否为函数，是则取返回值不是则取自身；
2. observe 方法对 data 进行处理，这个方法尝试创建一个 Observer 实例 _ ob _，如果成功创建则返回新的 Observer 实例，如果已有 Observer 实例则返回现有 Observer 实例；

```javascript
// src/core/instance/state.js

function initData(vm: Component) {
  let data = vm.$options.data
  data = vm._data = typeof data === 'function'
                    ? getData(data, vm)
                    : data || {}
  // 给data做响应式处理
  observe(data, true /* asRootData */)             
}
```



## 创建渲染watcher

将更新视图的功能封装了一个 watcher；

```javascript
export function lifecycleMixin() {
  Vue.prototype._update = function (vnode) {}
}
export function mountComponent(vm, el) {
  vm.$el = el;
  let updateComponent = () => {
      // 将虚拟节点 渲染到页面上
      vm._update(vm._render());
  }
  new Watcher(vm, updateComponent, () => {}, true);
}
```

```javascript
class Watcher {
  // vm,updateComponent,()=>{ console.log('更新视图了')},true
  constructor(vm,exprOrFn,cb,options){
      this.vm = vm;
      this.exprOrFn = exprOrFn;
      this.cb = cb;
      this.options = options;
      this.id = id++;
      // 默认应该让exprOrFn执行：render （去vm上了取值）
      this.getter = exprOrFn; 
      this.deps = []; 
      this.depsId = new Set();

      this.get(); // 默认初始化，要取值
  }
  // 用户更新时可以重新调用getter方法
  get(){ 
      // defineProperty.get, 每个属性都可以收集自己的watcher
      // 一个属性可以对应多个watcher，一个watcher可以对应多个属性
      pushTarget(this); // Dep.target = watcher
      this.getter(); // vm._update(vm._render)
      popTarget(); // Dep.target = null; 如果Dep.target有值说明这个变量在模板中使用了
  }
  
  // vue中的更新操作是异步的
  update(){ 
     // 每次更新时 this，多次调用update,先将watcher缓存下来，稍后一起更新
     queueWatcher(this); 
  }
  
  run(){ 
      this.get();
  }
  
  addDep(dep){
      let id = dep.id;
      if(!this.depsId.has(id)){
          this.depsId.add(id);
          this.deps.push(dep);
          dep.addSub(this)
      }
  }
}
```

## 渲染时存储watcher

调用 dep 的 pushTarget 方法存储 watcher；

```javascript
class Watcher{
    ...
    get(){
     //调用dep的pushTarget方法储存当前的watcher
      pushTarget(this); // Dep.target = watcher
      this.getter();
      popTarget();
    }
}
```

```javascript
let id = 0;
class Dep{
  constructor(){
    this.id = id++;
  }
}
let stack = [];
export function pushTarget(watcher){
    Dep.target = watcher;
    stack.push(watcher);
}
export function popTarget(){
    stack.pop();
    Dep.target = stack[stack.length-1];
}
export default Dep;
```

## 对象的依赖收集

1. 在页面中渲染使用的属性，需要进行依赖收集，收集对象的渲染 watcher；
2. 取值时，给每个属性都添加了 dep 属性，用于存储这个渲染 watcher；
   - watcher 的 get 方法调用 render，render 方法去 vm 上取值，取值就调用了 defineProperty 的 get 方法；
3. dep.depend（）方法用于通知 watcher 保存 dep，并且让 dep 保存 watcher；

```javascript
let dep = new Dep();
Object.defineProperty(data, key, {
  get() {
  	// 如果取值时有watcher
    if(Dep.target){ 
      dep.depend(); // 让watcher保存dep，并且让dep 保存watcher
    }
    return value
  },
  set(newValue) {
    if (newValue == value) return;
    observe(newValue);
    value = newValue;
    dep.notify(); // 通知渲染watcher去更新
  }
});
```

### Dep 实现

- 每个 dep 都有一个 id 作为唯一标志，向 watcher 中添加 dep 可以通过 id 去重；
- 用 dep 做关系的收集，每个属性都有一个 dep，dep 用来存放 watcher；

```javascript
let id = 0;
class Dep{ 
  // 每个属性都分配一个dep，dep可以来存放watcher，watcher中也要存放这个dep
  constructor(){
    this.id = id++;
    this.subs = []; // 用来存放watcher的
  }
  depend(){
    if(Dep.target){
      Dep.target.addDep(this);
    }
  }
  addSub(watcher){
     this.subs.push(watcher);
  }
  notify(){
    this.subs.forEach(watcher=>watcher.update());
  }
}
Dep.target = null;

export function pushTarget(watcher) {
    Dep.target = watcher;
}

export function popTarget(){
    Dep.target = null
}

export default Dep
```

### watcher 实现

- watcher 中存放 dep，一个属性一个 dep，多个属性多个 dep；

```javascript
import { popTarget, pushTarget } from "./dep";
import { queueWatcher } from "./scheduler";

let id = 0;
class Watcher {
  constructor(vm,exprOrFn,cb,options){
      this.vm = vm;
      this.exprOrFn = exprOrFn;
      this.cb = cb;
      this.options = options;
      this.id = id++;
      this.getter = exprOrFn; 
      this.deps = []; 
      this.depsId = new Set();

      this.get(); // 默认初始化,要取值
  }
  // 用户更新时可以重新调用getter方法
  get(){ 
      // defineProperty.get, 每个属性都可以收集自己的watcher
      // 一个属性可以对应多个watcher，一个watcher可以对应多个属性
      pushTarget(this); // Dep.target = watcher
      this.getter(); // render() 方法会去vm上取值 
      popTarget(); // Dep.target = null; 如果Dep.target有值说明这个变量在模板中使用了
  }
  // vue中的更新操作是异步的
  update(){ 
     // 多次调用update 我希望先将watcher缓存下来，稍后一起更新
     queueWatcher(this); 
  }
  run(){ 
      this.get();
  }
  addDep(dep){
      let id = dep.id;
      if(!this.depsId.has(id)){
          this.depsId.add(id);
          this.deps.push(dep);
          dep.addSub(this)
      }
  }
}
```

## 数组的依赖收集

1. 给数组的 _ ob _ 添加一个 dep，用于存放 watcher；
2. 当调用数组变异方法时，调用 dep.notify（）来通知 watcher 更新；
3. 如果是数组嵌套数组，通过 dependArray（）递归收集 watcher；

```javascript
this.dep = new Dep(); // 专门为数组设计的
if (Array.isArray(value)) {
  value.__proto__ = arrayMethods;
  this.observeArray(value);
} else {
  this.walk(value);
}	

function defineReactive(data, key, value) {
  let childOb = observe(value);
  let dep = new Dep();
  Object.defineProperty(data, key, {
    get() {
      if(Dep.target){
          dep.depend();
          if(childOb){ 
              childOb.dep.depend(); // 收集数组依赖
          }
      }
      return value
    },
    set(newValue) {
      if (newValue == value) return;
      observe(newValue);
      value = newValue;
      dep.notify();
    }
  })
}

arrayMethods[method] = function (...args) {
  // ...
  ob.dep.notify()
  return result;
}
```

### 递归收集数组依赖

```javascript
if(Dep.target){
  dep.depend();
  if(childOb){
    childOb.dep.depend(); // 收集数组依赖
    if(Array.isArray(value)){ // 如果内部还是数组
       dependArray(value);// 不停的进行依赖收集
    }
  }
}
function dependArray(value) {
  for (let i = 0; i < value.length; i++) {
    let current = value[i];
    current.__ob__ && current.__ob__.dep.depend();
    if (Array.isArray(current)) {
        dependArray(current)
    }
  }
}
```