## 异步组件

webpack 遇到异步组件，会将其从主脚本中分离，减少脚本体积，加快页面加载时间，当遇到场景需要使用该组件时，才会去加载组件脚本；

### 工厂函数

Vue 中允许通过工厂函数的形式定义组件，这个工厂函数会异步解析组件定义，组件需要渲染时才会触发该工厂函数，加载结果会进行缓存，以供下一次调用组件时使用；

```javascript
// 全局注册：
Vue.component('asyncComponent', function(resolve, reject) {
  require(['./test.vue'], resolve)
})
// 局部注册：
var vm = new Vue({
  el: '#app',
  template: '<div id="app"><asyncComponent></asyncComponent></div>',
  components: {
    asyncComponent: (resolve, reject) => require(['./test.vue'], resolve),
    // 另外写法
    asyncComponent: () => import('./test.vue'),
  }
})
```

### 流程分析

在实例挂载创建 Vnode 的过程，如果遇遇到子的占位符节点会调用 creatComponent ,这里会为子组件做选项合并和钩子挂载的操作，并创建一个以 vue-component- 为标记的子 Vnode ,异步组件的处理逻辑也是在这个阶段处理；

- 工厂函数的用法使 Vue.component（name，options）的第二个参数不是一个对象，因此不论是全局注册还是局部注册，都不会执行 Vue.extend 生成一个子组件的构造器，所以 Ctor.cid 不会存在，代码进入异步组件分支；

```javascript
// 创建子组件过程
function createComponent (
  Ctor, // 子类构造器
  data,
  context, // vm实例
  children, // 子节点
  tag // 子组件占位符
) {
  ···
  // 针对局部注册组件创建子类构造器
  if (isObject(Ctor)) {
    Ctor = baseCtor.extend(Ctor);
  }
  // 异步组件分支
  var asyncFactory;
  if (isUndef(Ctor.cid)) {
    // 异步工厂函数
    asyncFactory = Ctor;
    // 创建异步组件函数
    Ctor = resolveAsyncComponent(asyncFactory, baseCtor);
    if (Ctor === undefined) {
      // 创建注释节点
      return createAsyncPlaceholder(
        asyncFactory,
        data,
        context,
        children,
        tag
      )
    }
  }
  ···
  // 创建子组件vnode
  var vnode = new VNode(
    ("vue-component-" + (Ctor.cid) + (name ? ("-" + name) : '')),
    data, undefined, undefined, undefined, context,
    { Ctor: Ctor, propsData: propsData, listeners: listeners, tag: tag, children: children },
    asyncFactory
  );

  return vnode
}
```

#### resolveAsyncComponent函数

1. 定义异步请求成功的函数处理，定义异步请求失败的函数处理；
2. 执行组件定义的工厂函数；
3. 同步返回请求成功的函数处理；

```javascript
function resolveAsyncComponent (
  factory,
  baseCtor
) {
  if (!isDef(factory.owners)) {

    // 异步请求成功处理
    var resolve = function() {}
    // 异步请求失败处理
    var reject = function() {}

    // 创建子组件时会先执行工厂函数，并将resolve和reject传入
    var res = factory(resolve, reject);

    // resolved 同步返回
    return factory.loading
      ? factory.loadingComp
      : factory.resolved
  }
}
```

#### once函数

> once 函数是为了防止多个地方调用异步组件时，reject，reject 不会重复执行，保证了函数在代码只执行一次，once 缓存了已经请求过的异步组件；

```javascript
// once函数保证了这个调用函数只在系统中调用一次
function once (fn) {
  // 利用闭包特性将called作为标志位
  var called = false;
  return function () {
    // 调用过则不再调用
    if (!called) {
      called = true;
      fn.apply(this, arguments);
    }
  }
}
```

成功 resolve 和失败 reject 的处理逻辑如下：

```javascript
// 成功处理
var resolve = once(function (res) {
  // 转成组件构造器，并将其缓存到resolved属性中
  factory.resolved = ensureCtor(res, baseCtor);
  if (!sync) {
    // 强制更新渲染视图
    forceRender(true);
  } else {
    owners.length = 0;
  }
});
// 失败处理
var reject = once(function (reason) {
  warn(
    "Failed to resolve async component: " + (String(factory)) +
    (reason ? ("\nReason: " + reason) : '')
  );
  if (isDef(factory.errorComp)) {
    factory.error = true;
    forceRender(true);
  }
});
```

#### ensureCtor函数

异步组件加载完毕会调用 resolve 定义的方法，方法会通过 ensureCtor 将加载完成的组件转换为组件构造器，并存储在 resolved 属性中：

```javascript
function ensureCtor (comp, base) {
  if (comp.__esModule ||(hasSymbol && comp[Symbol.toStringTag] === 'Module')) {
    comp = comp.default;
  }
  // comp结果为对象时，调用extend方法创建一个子类构造器
  return isObject(comp)
    ? base.extend(comp)
    : comp
}
```

组件构造器创建完毕，会进行一次视图的重新渲染，由于 Vue 是数据驱动视图渲染的，而组件在加载到完毕的过程中，并没有发生数据的变化，因此需要手动强制更新视图；

forceRender 函数内部会拿到每个调用异步组件的实例，执行原型上的 $forceUpdate 方法；

异步组件加载失败后，会调用 reject 定义的方法，方法会提示并标记错误，最后同样会强制更新视图；

#### createAsyncPlaceholder函数

异步组件创建的流程，执行异步过程会同步为加载中的异步组件创建一个注释节点 Vnode；

```
function createComponent (){
  ···
  // 创建异步组件函数
  Ctor = resolveAsyncComponent(asyncFactory, baseCtor);
  if (Ctor === undefined) {
    // 创建注释节点
    return createAsyncPlaceholder(asyncFactory,data,context,children,tag)
  }
}
```

- asyncFactory，asyncMeta 都是用来标注该节点为异步组件的临时节点和相关属性；

```javascript
// 创建注释Vnode
function createAsyncPlaceholder (factory,data,context,children,tag) {
  var node = createEmptyVNode();
  node.asyncFactory = factory;
  node.asyncMeta = { data: data, context: context, children: children, tag: tag };
  return node
}
```

执行 forceRender 触发组件的重新渲染过程时，又会再次调用 resolveAsyncComponent ，这时返回值 Ctor 不再是 undefined，会走正常组件的 render，patch 过程，此时旧的注释节点也会被取代；

### Promise异步组件

```
Vue.component('asyncComponent', () => import('./test.vue'))
```

源码依然走异步组件的处理分支，且大部分的处理过程还是工厂函数的逻辑处理，区别在于执行异步函数后会返回一个 promise 对象，成功加载则执行 resovle，失败加载则执行 reject；

```javascript
var res = factory(resolve, reject);
// res是返回的promise
if (isObject(res)) {
  if (isPromise(res)) {
    if (isUndef(factory.resolved)) {
      // 核心处理
      res.then(resolve, reject);
    }
  }
}
```

#### import 和 import()

- import 是 es6 引入模块加载的用法，它是一个静态加载的方法，会优先模块内的其他语句执行；
- import（）是一个运行时加载模块的方法，且 import（）会返回一个 promise 对象；