## 栈

> 栈是一种后入先出的有序集合，例如 JS 的的执行栈；
>
> 新添加的元素放入栈顶，要删除元素也必须只能从栈顶删除；

### 实现

```javascript
let Stack = (function() {
    // 定义成WeakMap就是为了将items属性变成私有属性，在外部调用Stack对象的时候无法访问到items属性
    let items = new WeakMap()
    class Stack {
        constructor() {
            items.set(this, [])
        };
        // 移除栈顶的元素，同时返回被移除的元素
        pop() {
            return items.get(this).pop()
        };
        // 添加新元素到栈顶
        push(element) {
            items.get(this).push(element)
        };
        // 返回栈顶的元素，不对栈做任何修改
        peek() {
            return items.get(this)[items.get(this).length - 1]
        };
        // 返回栈里的元素个数
        size() {
            return items.get(this).length
        };
        // 如果栈里没有任何元素就返回true，否则返回false
        isEmpty() {
            return items.get(this).length === 0
        };
        // 移除栈里的所有元素
        clear() {
            items.get(this).length = 0
        }
    }
    return Stack
})();
```

### 应用

栈的实际应用非常广泛，例如用来存储访问过的任务或路径、撤销的操作。

```javascript
 // 十进制转换二进制
 function baseConverter(number, base) {
      let remStack = new Stack();
      let result = '';
      while (number > 0) {
          remStack.push(number % base);
          number = Math.floor(number / base);
      }
      while (!remStack.isEmpty()) {
          result += remStack.pop()
      }
      return result
  }
```

## 队列

> 队列数据结构是遵循先进先出的有序集合，例如 js 的任务队列；

### 实现

```javascript
let Queue = (function() {
  let items = new WeakMap()
  class Queue {
    constructor () {
      items.set(this, [])
    }
    // 入列
    enqueue (element) { 
      items.get(this).push(element)
    }
    // 出列
    dequeue () { 
      return items.get(this).shift()
    }
    // 获取当前队列首位
    front () { 
      return items.get(this)[0]
    }
    // 栈长度
    size () { 
      return items.get(this).length
    }
    // 栈是否为空
    isEmpty () { 
      return items.get(this).length === 0
    }
    // 清空栈
    clear () { 
      items.get(this).length = 0
    }
  }
  return Queue
})()
```

### 应用

击鼓传花是指所有人围成一个圈，游戏开始时把花尽快传给挨着的人，游戏结束时花在谁手中谁就出局。直到剩下最后一个人就是赢家；

```javascript
function hotPotato (nameList) {
  let queue = new Queue()
  nameList.map(name => queue.enqueue(name))
  return function (num) {
    if (queue.isEmpty()) {
      console.log('游戏已经结束')
      return
    }
    // 让队列能围成一个圈
    for (let i = 0; i < num; i++) {
      queue.enqueue(queue.dequeue())
    }
    let outer = queue.dequeue()
    console.log(outer + '出局了')
    if (queue.size() === 1) {
      let winner = queue.dequeue()
      // 让垃圾回收机制能自动清除弱引用内存
      queue = null 
      console.log(winner + '获胜')
      return winner
    } else {
      return outer
    }
  }
}
let nameList = ['鼠', '牛', '虎', '兔', '龙', '蛇', '马', '羊', '猴', '鸡', '狗', '猪']
let game = hotPotato(nameList)
game(12) // 鼠出局了
game(22) // 牛出局了
...
game(32) // 龙获胜
```

无论是栈还是队列，本质上都是利用数组实现的变种。通过封装只暴露出结构该有的方法，保证了数据结构的稳定性和安全性。

## 链表

> 和数组相比，链表的优势在于：添加或者删除元素不需要移动其他元素,劣势在与链表相对于数组结构更复杂，需要一个指向下一个元素的指针，在访问链表中的某个元素也需要从头迭代，而不是像数组一样直接访问

### 单向链表

> 单向链表是指只有 next 没有 prev 的链表数据结构。

#### 实现

```javascript
 const LinkedList = (function() {
    const Node = function(element) {
        this.element = element;
        this.next = null;
    };

    class LinkedList {
        constructor() {
            this.head = null;
            this.length = 0;
        };
        // 从尾部添加节点
        append(element) {
            const newNode = new Node(element);
            // 没有头节点，将新节点设为头节点
            if (!this.head) {
                this.head = newNode;
            } else {
                // 存在头节点，就在链表尾部添加新节点
                let current = this.head;
                // 遍历找到链表尾部
                while (current.next) {
                    current = current.next;
                }
                current.next = newNode
            };
            this.length++
        };
        // 按位置插入节点
        insert(position, element) {
            // 边界判断
            if (position < 0 || position > this.length) return;
            let newNode = new Node(element);
            // 头部插入
            if (position === 0) {
                newNode.next = this.head;
                this.head = newNode
            } else {
                let current = this.head;
                // index 索引判断是否是当前 position
                let index = 0;
                let previous;
                while (index++ < position) {
                    previous = current
                    current = current.next
                }
                newNode.next = current
                previous.next = newNode;
            }
            this.length++;
            return true
        };
        // 按照位置删除节点
        removeAt(position) {
            // 边界处理
            if (position < 0 || position > this.length) return null;
            let newNode = new Node(element);
            let current = this.head;
            let index = 0;
            let previous;
            // 删除头部
            if (position === 0) {
                this.head = this.head.next;
            } else {
                while (index++ < position) {
                    previous = current
                    current = current.next
                }
                previous.next = current.next
            };
            this.length--;
            return current.element
        };
        // 将链表的值字符串化
        toString(joint) {
            let current = this.head,
                str = '';
            while (current) {
                str += current.element;
                current = current.next;
                if (current) {
                    str += joint ? joint : ','
                }
            }
            return str
        };
        // 找到值第一次出现的位置
        indexOf(element) {
            let current = this.head;
            let index = 0;
            while (current) {
                if (current.element === element) {
                    return index
                }
                current = current.next
                index++
            }
            return -1
        };
        // 找到第一次出现该值的节点
        find(element) {
            let current = this.head;
            while (current) {
                if (current.element === element) {
                    return current
                }
                current.next = current
            }
            return false
        };
        // 判断链表是否为空
        isEmpty() {
            return this.length === 0
        };
        // 返回链表长度
        size() {
            return this.length
        };
        // 获取链表头节点
        getHead() {
            return this.head
        }
    }
    return LinkedList
})();
```

### 双向链表

> 双向链表中节点除了有 next 指向下一个节点，还有 prev 指向前一个节点；
>
> 优点在于能够从头到尾迭代，也能够从尾到头迭代；
>
> 最大的好处是删除给定指针操作时不用再遍历一遍找到其 prev 指向的节点，所以此时的删除操作单向链表时间复杂度是 O(n)，双向链表的时间复杂度是 O(1)；

#### 实现

```javascript
const DoubleLinkedList = (function() {
    let Node = function(element) {
        this.element = element;
        this.pre = this.next = null;
    }

    class DoubleLinkedList {
        constructor() {
            this.length = 0;
            this.head = this.tail = null;
        };
        // 从尾部添加节点
        append(element) {
            let newNode = new Node(element);
            if (!this.head) {
                this.head = this.tail = newNode
            } else {
                let current = this.head
                while (current) {
                    current = current.next
                }
                current = this.tail
                current.next = this.tail = newNode
                newNode.pre = current
            }
            this.length++
        };
        // 按位置插入节点
        insert(position, element) {
            // 边界处理
            if (position < 0 || position > this.length) {
                return false
            }
            let newNode = new Node(element)
            let previous, current = this.head,
                index = 0
            if (position === 0) {
                // 头部插入
                if (!this.head) {
                    this.head = this.tail = newNode
                } else {
                    newNode.next = current;
                    current.prev = newNode
                    this.head = newNode
                }
            } else if (position === this.length) {
                // 尾部插入
                this.tail.next = newNode
                newNode.pre = this.tail
                this.tail = newNode
            } else {
                // 中间插入
                while (index++ < position) {
                    previous = current
                    current = current.next
                }
                currentnewNode.next
                newNode.pre = previous
                previous.next = newNode
                current.pre = newNode
            }
            this.length++;
            return true
        };
        // 按位置删除
        removeAt(position) {
            if (position < 0 || position >= this.length) return false;
            let curent = this.head,
                previous,
                index = 0;
            // 删除头部
            if (position === 0) {
                this.head = current.next;
                if (this.length === 1) {
                    // 若只有一项，则 current.next 为 null ，所以只需要将尾部设为 null
                    this.tail = null
                } else {
                    this.head.prev = null
                }
            } else if (position === this.length - 1) {
                // 删除尾部
                curent = this.tail;
                this.tail = curent.pre
                this.tail.next = null
            } else {
                // 中间删除 
                while (index++ < position) {
                    previous = current;
                    curent = curent.next
                }
                previous.next = curent.next
                curent.next.pre = previous
            }
            this.length--;
            return current.element
        };
        // 删除指定节点
        removeByNode(node) {
            // 删除头部
            if (!node.pre) {
                this.head = node.next;
                this.head.prev = null;
                return
            }
            // 删除尾部
            if (!node.next) {
                this.tail = node.pre
                this.tail.next = null;
                return
            }
            node.pre.next = node.next;
            node.next.pre = node.pre
        };
        // 其他方法实现和单向链表相同
    }
    return DoubleLinkedList
})()
```

### 循环链表

> 循环链表是指链表的头部和尾部之间存在相互引用，形成了一个循环；
>
> 单向循环链表的实现方法和单向链表几乎一样，但在增加和头部和尾部节点的时候需要注意设置current.next = this.head；