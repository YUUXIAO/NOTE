## CommonJS

模块的意义在于将类聚的方法和变量等限定在私有的作用域中，同时支持引入和导出功能以顺畅地连接上下游依赖着；

### 模块引用 

在 CommonJS 中，存在 require（）方法，接受模块标识，以此引入一个模块的 API 到当前上下文中；

```javascript
let math = require('math')
```

### 模块定义

1. 对应导出功能，上下文提供了 exports 对象用于导出当前模块的方法和变量，并且它是唯一导出的出口；
2. 在模块中，还存在一个 module 对象，它代表模块自身；
3. exports 是 module 的属性；

### 模块标识

模块标识就是传递给 require（）方法的参数，它必须符合：

1. 小驼峰命名的字符串；
2. 以 . 或 .. 开头的相对路径；
3. 绝对路径；

可以没有文件后缀名 .js；

## Node 的模块实现

Node 在实现中对模块规范进行了取舍，增加了自身需要的特性；

在 Node 中引入模块，需要经历3个步骤：

1. 路径分析；
2. 文件定位；
3. 编译执行；

### 核心模块

> 核心模块一般是指 Node 提供的模块，核心模块部分在 Node 源码的编译过程中，编译进了二进制执行文件；

在 Node 进程启动时，部分核心模块就被直接加载进内存中，这部分模块在引入时，文件定位和编译执行这两个步骤可以省略，并在路径分析中优先判断，所以加载速度是最快的；

### 文件模块

> 文件模块一般是指用户编写的模块；

文件模块则是在运行时动态加载，需要完整的路径分析、文件定位、编译执行过程；

### 优先从缓存加载

> Node 对引入过的模块都会进行缓存，减少二次引入时的开销；

区别于前端浏览器缓存静态脚本文件：Node 缓存的是编译和执行过后的对象；

不论是核心模块还是文件模块，require 方法对于相同模块的二次加载都一律采用缓存优先的方式，这是第一优先级；

核心模块的缓存检查先于文件模块的缓存检查；

### 路径分析和文件定位

对于不同的标识符，模块的查找和定位有不同程度上的差别；

#### 模块标识符分析

模块标识符在 Node 主要分为：

1. 核心模块，如 http、fs、path 等；
   - 优先级仅次于缓存加载，在 Node 源码编译过程中已经编译为二进制代码，加载过程最快；
   - 试图加载一个与核心模块标识符相同的自定义模块是不会成功的；
   - 想要加载成功必须选择一个不同的标识符或者换用路径；

2. . 或 .. 开始的相对路径文件模块；

3. 以 / 开始的绝对路径文件模块；
   - 相对路径和绝对路径的文件都被当作文件模块来处理；
   - 在分析路径模块时，require（）方法会将路径转化为真实路径，并以其作为索引，将编译过后的结果放到缓存中；

4. 自定义模块；

   > 模块路径：指的是 Node 在定位文件模块的具体文件时制定的查找策略，具体表现为一个路径组成的数组；

   - 指的是非路径形式的文件模块，也不是路径形式的标识符；
   - 是一种特殊的文件形式，可能是一个文件或者包的形式；
   - 这类模块的查找是最费时的，也是所有方式中最慢的一种；
   - 在加载的过程中，逐个尝试模块路径中的路径，直到找到目标文件为止，当前文件的路径越深，模块查找耗时会越多；

#### 文件定位

从缓存加载的策略使得二次引入时不需要路径分析、文件定位和编译执行的过程，大大提高了再次加载模块的效率；

#### 文件扩展名分析

> CommonJs 模块规范允许在标识符中不包含文件扩展名，Node 会按 .js、.node、.json 的次序补充扩展名；

