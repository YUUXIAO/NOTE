## V8的垃圾回收机制与内存机制 

### 内存限制

1. Node基于V8构建，在Node中使用的 javascript 对象基本上都是通过V8自己的方式来进行分配和管理的；
2. 在Node 中通过 javascript 使用内存时只能使用部分内存（64位系统下只约1.4GB，32位系统下约0.7GB）;
3. V8对内存限制的设置于Chrome浏览器每个选项卡页面使用一个V8实例；

### 对象分配

> 在V8中，所有的 javascript 对象都是通过堆来进行分配的；

V8限制堆大小的原因：

1. 表层原因是V8最初为浏览器而设计，不太可能遇到用大量内存的场景；

2. 深层原因是V8的垃圾回收机制的限制；

   - 以1.5GB的垃圾回收内存为例；
   - V8做一次小的垃圾回收要50毫秒以上，做一次非增量式的垃圾回收要1秒以上；
   - 这是垃圾回收中引起 javascript 线程暂停执行的时间，在这样的时间花销下，应用的性能和响应能力会直线下降；

3. V8 提供了选项让我们使用更多的内存;

   - 下面参数只在V8初始化时生效，一旦生效不能动态改变；

   ```javascript
   node --max-old-space-size=1700 test.js  // 单位为MB，设置老生代内存空间的最大值
   或
   node --max-new-space-size=1024 test.js  // 单位为KB，设置新生代内存空间的最大值
   ```

Node提供了V8中内存使用量的查看方式：

```javascript
$ node
> process.memoryUsage();
{
  rss: 21450752, 
  heapTotal: 5656576,  // 已申请到的内存
  heapUsed: 3033872, // 当前使用的量
  external: 1395519
}
```

### 垃圾回收机制

#### 垃圾回收算法

> 现代的垃圾回收算法中按对象的存活时间将内存的垃圾回收进行不同的分代，然后对不同分代的内存施以不同的算法；

##### V8的内存分代

在V8中主要将内存分为新生代和老生代，V8堆整体大小就是新生代+老生代的内存空间；

1. 新生代：新生代的对象为存活时间较短的对象；
   - 它由两个 reserved_semispace_size_所构成；
   - 按照位数不同 reserved_semispace_size_ 在64位系统和32位系统分别为16MB 和 8MB;
   - 新生代内存的最大值在 64位系统和32位系统分别为32MB 和 16MB;
2. 老生代：老生代的对象为存活时间较长或长驻内存的对象；
3. V8堆内存的最大保留空间公式为 4* reserved_semispace_size_  + max_old_generation_size_；

##### Scavenge算法

> 新生代的对象主要通过 Scavenge 算法进行垃圾回收，在 Scavenge 的具体实现中，主要采用了 Cheney 算法；

1. Scavenge 是典型的牺牲空间换取时间的算法，所以无法大规模的应用到所有的垃圾回收中，但是非常适合应用在新生代中，因为新生代中的对象生命周期较短；
2. Scavenge 的缺点是只能利用堆内存中的一半，这是由划分空间和复制机制决定的，但只复制存活的对象，并且对生于命周期短的场景存活对象只占少部分，所以在时间效率上有优异的表现；

Cheney 算法是采用一种复制的方式实现的垃圾回收算法，就是通过将存活对象在两个 semispace 空间之间进行复制；

1. 将内存一分为二，每一部分空间称为 semispace；
2. 这两个 semispace 空间中只有一个处于使用中，一个处于闲置状态；
3. 处于使用中的空间称为 From 空间， 处于使用中的空间称为 To空间；
4. 当分配对象时，先在 From 空间进行分配；
5. 开始进行垃圾回收时，检查 From 空间中的存活对象，这些存活对象将被复制到 To空间中，非存活对象占用的空间将会被释放；
   - From 空间中的存活对象在复制到To空间之前需要检查；
   - 当一个对象经过多次复制依然存活时，它将会被认为是生命周期较长的对象，这种对象随后会被移到老生代中，用新的算法进行管理；
   - 对象从新生代移动到老生代中的过程称为晋升；
   - 晋升的条件主要有两个：一个是对象是否经历过 Scavenge 回收；一个是To空间内存占比超过限制，如果To空间已经使用超过了 25%；
6. 完成复制后，From空间和To空间的角色发生对换；

##### Mark-Sweep & Mark-Compact

> 老生代中主要采用了 Mark-Sweep & Mark-Compact 相结合的方式进行垃圾回收；

Mark-Sweep 是标记清除的意思，只清理死亡对象，它分为标记和清除两个阶段；

1. 在标记阶段遍历堆中所有对象，并标记活着的对象；
2. 在清除阶段，只清除没有标记的对象；
3. Mark-Sweep 的缺点是在进行一次标记清除回收后，会出现内存空间不连续的状态，这会对后续的内存分配造成问题，当需要分配一个在的对象可能碎片空间无法完成这次分配，会提前触发垃圾回收；

Mark-Compact 是标记整理的意思；

1. 在标记过程中，在对象标记为死亡后；
2. 在整理的过程中，将活着的对象往一端移动；
3. 移动完成后，直接清理掉边界的内存；

##### Incremental Marking

> 全停顿指的是在V8中的垃圾回收的3种基本算法都要将应用逻辑暂停下来，待执行完垃圾回收后再恢复执行应用逻辑；

为了降低全堆垃圾回收带来的停顿时间；

1. V8 将原本要一口气停顿完成的动作改为增量标记，也就是垃圾回收与应用逻辑交替执行，每做完一步进就让应用逻辑执行一会，直到标记阶段完成；
2. 延迟清理；
3. 增量式整理；
4. 计划引入并行标记和并行清理，进一步利用多核性能降低每次停顿的时间；

## 高效使用内存

### 作用域

> 在JS 中能形成作用域的有函数调用、with 以及全局作用域；

1. 标识符查找 ：标识符可以理解为变量名；

2. 作用域链：当在一个函数内访问变量时，会沿着向上的作用域查找，一直到全局作用域，如果查找一个不存在的变量，最后会抛出未定义的错误；

3. 变量的主动释放：

   - 如果变量是全局变量，由于全局作用域需要直到进程退出才能释放，此时将导致引用的对象常驻内存（常驻老生代中）；
   - 可以通过 delete 操作来删除引用关系，或将变量重新赋值，让旧的对象脱离引用关系；
     - delete 删除对象的属性有可能干扰V8的优化，建议通过赋值方式解除引用；
   - 在接下来老生代内存清除和整理的过程中，将会被回收释放；

   ```javascript
   global.foo = "i'm global object";
   console.log(global.foo)  // i'm global object"
   delete global.foo
   // 或重新赋值
   global.foo = undefined // or null
   console.log(global.foo)  // undefind
   ```

### 闭包



