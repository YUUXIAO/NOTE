## V8的垃圾回收机制与内存机制 

### 内存限制

1. Node基于V8构建，在Node中使用的 javascript 对象基本上都是通过V8自己的方式来进行分配和管理的；
2. 在Node 中通过 javascript 使用内存时只能使用部分内存（64位系统下只约1.4GB，32位系统下约0.7GB）;

### 对象分配

> 在V8中，所有的 javascript 对象都是通过堆来进行分配的；

V8限制堆大小的原因：

1. 表层原因是V8最初为浏览器而设计，不太可能遇到用大量内存的场景；

2. 深层原因是V8的垃圾回收机制的限制；

   - 以1.5GB的垃圾回收内存为例；
   - V8做一次小的垃圾回收要50毫秒以上，做一次非增量式的垃圾回收要1秒以上；
   - 这是垃圾回收中引起 javascript 线程暂停执行的时间，在这样的时间花销下，应用的性能和响应能力会直线下降；

3. V8 提供了选项让我们使用更多的内存;

   - 下面参数只在V8初始化时生效，一旦生效不能动态改变；

   ```javascript
   node --max-old-space-size=1700 test.js  // 单位为MB，设置老生代内存空间的最大值
   或
   node --max-new-space-size=1024 test.js  // 单位为KB，设置新生代内存空间的最大值
   ```

Node提供了V8中内存使用量的查看方式：

```javascript
$ node
> process.memoryUsage();
{
  rss: 21450752, 
  heapTotal: 5656576,  // 已申请到的内存
  heapUsed: 3033872, // 当前使用的量
  external: 1395519
}
```

### 垃圾回收机制

#### 垃圾回收算法

> 现代的垃圾回收算法中按对象的存活时间将内存的垃圾回收进行不同的分代，然后对不同分代的内存施以不同的算法；

##### V8的内存分代

在V8中主要将内存分为新生代和老生代，V8堆整体大小就是新生代+老生代的内存空间；

1. 新生代：新生代的对象为存活时间较短的对象；
   - 它由两个 reserved_semispace_size_所构成；
   - 按照位数不同 reserved_semispace_size_ 在64位系统和32位系统分别为16MB 和 8MB;
   - 新生代内存的最大值在 64位系统和32位系统分别为32MB 和 16MB;
2. 老生代：老生代的对象为存活时间较长或长驻内存的对象；
3. V8堆内存的最大保留空间公式为 4* reserved_semispace_size_  + max_old_generation_size_；

##### Scavenge算法

> 新生代的对象主要通过 Scavenge 算法进行垃圾回收，在 Scavenge 的具体实现中，主要采用了 Cheney 算法；

1. Scavenge 是典型的牺牲空间换取时间的算法，所以无法大规模的应用到所有的垃圾回收中，但是非常适合应用在新生代中，因为新生代中的对象生命周期较短；
2. Scavenge 的缺点是只能利用堆内存中的一半，这是由划分空间和复制机制决定的，但只复制存活的对象，并且对生于命周期短的场景存活对象只占少部分，所以在时间效率上有优异的表现；

Cheney 算法是采用一种复制的方式实现的垃圾回收算法，就是通过将存活对象在两个 semispace 空间之间进行复制；

1. 将内存一分为二，每一部分空间称为 semispace；
2. 这两个 semispace 空间中只有一个处于使用中，一个处于闲置状态；
3. 处于使用中的空间称为 From 空间， 处于使用中的空间称为 To空间；
4. 当分配对象时，先在 From 空间进行分配；
5. 开始进行垃圾回收时，检查 From 空间中的存活对象，这些存活对象将被复制到 To空间中，非存活对象占用的空间将会被释放；