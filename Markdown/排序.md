## 相关概念

> **稳定**：如果a原本在b前面，而a=b，排序之后a仍然在b的前面。
>
> **不稳定**：如果a原本在b的前面，而a=b，排序之后 a 可能会出现在 b 的后面。
>
> **时间复杂度**：对排序数据的总的操作次数。反映当n变化时，操作次数呈现什么规律。
>
> **空间复杂度：**是指算法在计算机内执行时所需存储空间的度量，它也是数据规模n的函数。 

## 冒泡排序

1. 比较相邻的元素，前者比后者大的话，两者交换位置
2. 对每一对相邻元素做相同操作，从开始第一对到最后一对，这样子最后的元素就是最大元素
3. 针对n个元素重复以上步骤，每次循环排除当前最后一个
4. 重复步骤1~3，直到排序完成

#### 动图演示

![冒泡排序](https://segmentfault.com/img/bVJwkj?w=826&h=257)

#### 代码实现

```javascript
function bubbleSort (array) {
  const len = arr.length - 1;
  // 需要遍历的轮数
  for (let i = 0; i < len; i++) {
    // 依次的比较相邻两个数的大小，遍历一次后，把数组中第i小的数放在第i个位置上
    // 每一轮都会把最大的元素放在最后，所以 len - i 后面的元素不用再比较
    // 声明一个变量，判断当前这一轮是否有过交换，一旦没有任何元素交换，排序结束
    var isSort = false;
    for (let j = 0; j < len - i; j++) {
      if (array[j] > array[j + 1]) {
        const temp = array[j];
        array[j] = array[j + 1];
        array[j + 1] = temp;
        isSort = true;
      }
    }
    if (!done) break
  }
  return array
}
```

#### 分析

1. 冒泡排序的时间复杂度是 `O(n^2)`；

   - 最好时间复杂度是 `O(n)`，即第一趟进行 `n-1` 次比较后，发现原数组是有序的，结束冒泡；
   - 最坏时间复杂度是 `O(n^2)`，当原数组刚好是倒序排列时，即需要进行 n 次冒泡，要进行 (n-1) + (n-2) ... + 1 次比较后，用等比数列求和公式求和后并化简，即可求出最坏时间复杂度；
   - 平均时间复杂度是 `O(n^2)`；

2. 冒泡排序是稳定的排序算法；

   这里的“稳定”指的是排序后，值相等的数据的前后顺序保持不变；

   相邻数据如果相等，不交换位置；

3. 冒泡排序是原地排序算法；

   - 原地排序指的是空间复杂度是 O(1) 的排序算法；
   - 冒泡排序只做了相邻数据交换，另外有两个临时变量（交换时的临时变量、flag），只需要常量级的临时空间，空间复杂度为 `O(1)`；

## 选择排序

> 选择排序也有一个 已排序区域和一个未排序区域；
>
> 插入排序不同的地方在于：选择排序是从未排序区域中找出最小的值，放到已排序区域的末尾；

#### 动图演示

![选择排序](https://segmentfault.com/img/bVJwkz?w=811&h=248)

#### 代码实现

```javascript
// 1. 有n个数,需要排序n-1次
// 2. 第一次选择最小值,放在第一位
// 3. 第二次选择最小值,放在第二位
// 4. …..重复该过程
// 5. 第n-1次选择最小值,放在第n-1位
function selectionSort(arr) {
    var len = arr.length;
    var minIndex, temp;
    for (var i = 0; i < len - 1; i++) {
        minIndex = i;
        for (var j = i + 1; j < len; j++) {
            if (arr[j] < arr[minIndex]) {    
                minIndex = j;                
            }
        }
        if(minIndex !== i){
          temp = arr[i];
          arr[i] = arr[minIndex];
          arr[minIndex] = temp;
        }
    }
    return arr;
} 
```

#### 分析

1. 选择排序的时间复杂度是 `O(n^2)`；
   - 最好时间复杂度是`O(n^2)`，因为每次从未排序区域内找出最小值，都要遍历未排序区域内的所有元素，一共要查找 n-1 次，所以时间复杂度是 O(n^2)；
   - 最坏时间复杂度也是 O(n^2)，理由同上；
2. 选择排序是不稳定的排序算法；
   - 因为每次都要找最小值和前面的元素进行交换，这样会破坏稳定性。举个反例来证明：3 3 2, 第一次交换后，为 2 3 3，此时两个 3 的相对顺序就改变了；
3. 选择排序是原地排序算法；
   - 我们找到未排序区域的最小元素，会交换该元素和 排序区域的下一个位置的元素（即排序区域的第一个元素），然后 i 后移。只做了元素的交换，且只用到了常数级的内存空间（交换两个数据需要的一个临时遍历）；

## 快速排序

> 1. 在数据集之中，选择一个元素作为"基准";
> 2. 所有小于"基准"的元素，都移到"基准"的左边；所有大于"基准"的元素，都移到"基准"的右边；
> 3. 对"基准"左边和右边的两个子集，不断重复第一步和第二步，直到所有子集只剩下一个元素为止；

#### 动图演示

![Quick Sort](https://user-gold-cdn.xitu.io/2018/7/18/164acd0f33702fe6?imageslim)

#### 代码实现

方法一：

```javascript
function quickSort(arr) {
    // 检查数组的元素个数，如果小于等于1，就返回
    if (arr.length <= 1) return arr;
    // 选择"基准"，并将其与原数组分离，再定义两个空数组，用来存放一左一右的两个子集;
    const pivotIndex = Math.floor(arr.length / 2);
    // 基准元素
    const pivot = arr.splice(pivotIndex, 1)[0];
    const left = [];
    const right = [];
    // 开始遍历数组，小于基准元素放入左边的子集，大于基准的元素放入右边的子集
    for (let i = 0; i < arr.length; i++) {
      if (arr[i] < pivot) {
        left.push(pivot);
      } else {
        right.push(pivot);
      }
    }
    return quickSort(left).concat([pivot], quickSort(right));
}

// 缺点：
// 1. 获取基准点使用了一个splice操作，在js中splice会对数组进行一次拷贝的操作，而它最坏的情况下复杂度为O(n)，而O(n)代表着针对数组规模的大小进行了一次循环操作;
// 2. 每次执行都会使用到两个数组空间，产生空间复杂度;
// 3. concat操作会对数组进行一次拷贝，而它的复杂度也会是O(n);
// 4. 对大量数据的排序来说相对会比较慢;
```

方法二：

```javascript
// 交换两个元素
function swap(array, a, b) {
  const temp = array[a];
  array[a] = array[b];
  array[b] = temp;
}

function partitionLomuto(array, left, right) {
  // 设置基准值
  const pivot = array[right];
  // 当前基准点
  let i = left;
  for (let j = left; j < right; j++) {
    if (array[j] <= pivot) {
      swap(array, i, j);
      i++;
    }
  }
  swap(array, i, right);
  return i;
}

function quickSort(array, left, right) {
  if (left < right) {
    const pivot = partitionLomuto(array, left, right);
    quickSort(array, left, pivot - 1);
    quickSort(array, pivot + 1, right);
  }
  return array;
}

const array = [88, 88, 9, 14, 6, 71, 24];
console.log(quickSort(array, 0, array.length - 1));
```

#### 分析

1. 快速择排序的时间复杂度是 `O(nlogn)`；
   - 平均复杂度也是`O(nlogn)`；
2. 快速排序是不稳定的排序算法；
   - 快速排序的分区过程，涉及到了交换操作，该交换操作类似选择排序，是不稳定的排序；
3. 快速排序是原地排序算法；

## 插入排序

> 本质是从未排序的区域内取出数据，放到已排序区域内，取出的数据会和已排序的区间内数据一一对比，找到正确的位置插入；

#### 动图演示

![img](https://img2018.cnblogs.com/blog/1230971/201906/1230971-20190606093850556-1940489422.gif)

#### 代码实现

```javascript
// 1. 从第一个元素开始，该元素可以被认为已经被排序;
// 2. 取出下一个元素，在已经排好序的序列中从后往前扫描;
// 3. 直到找到小于或者等于该元素的位置;
// 4. 将该位置后面的所有已排序的元素从后往前依次移一位;
// 5. 将该元素插入到该位置;
function insertSort(array) {
  if (array.length <= 1) return array;
  // i=1开始，留着0作为有序部分，也就是说，外层循环获取数组后面的元素，也就是上面所讲的无序部分
  for (var i = 1; i < len; i++) {
    // j=i-1，就是获取有序部分最后的一个元素作为对照，也就是有序部分
    for (var j = i - 1; j >= 0; j--) {
      // 注意，j--,就是从有序部分的后面元素开始和无序部分的元素作比较
      if (array[j] > array[j + 1]) {
        var temp = array[j];
        array[j] = array[j + 1];
        array[j + 1] = temp;
      }
    }
  }
  return array;
}
```

#### 分析

1. 插入排序的时间复杂度是 `O(n^2)`；
   - 最好时间复杂度是 `O(n)`，当要排序的数据是有序的，我们每次插入已排序的区域，只需要比较一次，一共比较 n-1 次就结束了（注意这里是从后往前遍历已排序区域）；
   - 最坏时间复杂度是 `O(n^2)`，是数据刚好是倒序的情况，每次都要遍历完 已排序区域的所有数据；
2. 插入排序是稳定的排序算法；
   - 遍历已排序区域时，值相同的时候，放到最后的位置即可；
3. 插入排序是原地排序算法；
   - 不需要额外空间，是在数组上进行数据交换，所以插入排序是原地排序算法；

## 希尔排序

## 归并排序

> 归并排序指的是将两个已经排序的序列合并成一个序列的操作；
>
> 采用了 分治思想，分治思想的核心是：将一个大问题分解成多个小的问题，解决后合并为原问题。分治通常用递归来实现。分治和递归的区别是，分治是一种解决问题的处理思想，递归是一种编程技巧

#### 动图演示

![img](https://upload-images.jianshu.io/upload_images/1867034-18c70f637b5c01c2.gif?imageMogr2/auto-orient/strip)

#### 代码实现

```javascript
function mergeSort(array) {
  if (array.length < 2) return array;
  const middle = Math.floor(array.length / 2);
  const left = array.slice(0, middle);
  const right = array.slice(middle);
  return merge(mergeSort(left), mergeSort(right));
}
function merge(left, right) {
  const result = [];
  while (left.length && right.length) {
    if (left[0] > right[0]) {
      result.push(right.shift());
    } else {
      result.push(left.shift());
    }
  }
  return result.concat(left, right);
}

const array = [9, 88, 14, 6, 88, 71, 24];
console.log(mergeSort(array));
```

#### 分析

1. 归并排序的时间复杂度是 `O(nlogn)`；
2. 归并排序是稳定的排序算法；
   - 归并交换元素的情况发生在合并过程，只要让比较左右两个子数组时发现相等时，取左边数组的元素，就可以保证有序了;
3. 归并排序不是原地排序算法；
   - 因为进行合并操作时，需要申请一个临时数组，该数组的长度最大不会超过 n。如果数据量很大，归并排序因为空间复杂度是 O(n)，会非常耗费内存。所以对大数据进行排序的时候，相比归并排序，我们更倾向于快速排序算法。虽然后者不稳定，但它是原地排序算法；

## 堆排序

> 堆是具有以下性质的完全二叉树：
>
> 每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆；
>
> 每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆；
>
> 一般升序采用大顶堆，降序采用小顶堆；

思想：

1. 将待排序序列构造成一个大顶堆，此时，整个序列的最大值就是堆顶的根节点；
2. 将其与末尾元素进行交换，此时末尾就为最大值；
3. 然后将剩余n-1个元素重新构造成一个堆，这样会得到n个元素的次小值；
4. 如此反复执行，便能得到一个有序序列了；

#### 代码实现

```javascript
let len;
// 构造一个所有节点都满足arr[parent[i]] > arr[i]的堆结构数组
function buildMaxHeap(array) {
  len = array.length;
  // 从树的最后一个有子节点的节点开始进行heapify处理
  const firstHeapifyIndex = Math.floor(len / 2 - 1);
  // 从0到firstHeapifyIndex都要进行heapify处理，才能把最大的那个节点换到根节点
  for (let i = firstHeapifyIndex; i >= 0; i--) {
    heapify(array, i);
  }
}

// 堆调整
function heapify(arr, i) {
  // 索引i的节点的左子节点索引
  let left = 2 * i + 1;
  // 索引i的节点的右子节点索引
  let right = 2 * i + 2;
  let largest = i;
  // 判断左节点是否存在且比父节点大
  if (left < len && arr[left] > arr[largest]) {
    largest = left;
  }
  // 判断右节点是否存在且与当前父子节点最大值比较
  if (right < len && arr[right] > arr[largest]) {
    largest = right;
  }
  // 如果biggestValueIndex是左子节点或右子节点，那么交换根节点与biggestValueIndex节点的值
  if (largest !== i) {
    swap(largest, i);
  }
}

function swap(arr, i, j) {
  var temp = arr[i];
  arr[i] = arr[j];
  arr[j] = temp;
}

function adjustHeap(array) {
  if (array.length > 1) {
    // 初始化堆
    buildMaxHeap(array);
    for (let i = len - 1; i > 0; i--) {
      // 把堆首(最大值)和堆尾互换
      swap(arr, 0, i);
      //当前树中最后一个节点已经是最大值，后面就不用再考虑这个节点
      len--;
      // 继续重新构建大顶堆
      if (len > 1) {
        heapify(array, 0);
      }
    }
  }
}

const array = [9, 88, 14, 6, 88, 71, 24];
console.log(adjustHeap(array));
```

## 计数排序

## 桶排序

## 基数排序







