## 相关概念

> **稳定**：如果a原本在b前面，而a=b，排序之后a仍然在b的前面。
>
> **不稳定**：如果a原本在b的前面，而a=b，排序之后 a 可能会出现在 b 的后面。
>
> **时间复杂度**：对排序数据的总的操作次数。反映当n变化时，操作次数呈现什么规律。
>
> **空间复杂度：**是指算法在计算机内执行时所需存储空间的度量，它也是数据规模n的函数。 

## 冒泡排序

1. 比较相邻的元素，前者比后者大的话，两者交换位置
2. 对每一对相邻元素做相同操作，从开始第一对到最后一对，这样子最后的元素就是最大元素
3. 针对n个元素重复以上步骤，每次循环排除当前最后一个
4. 重复步骤1~3，直到排序完成

#### 动图演示

![冒泡排序](https://segmentfault.com/img/bVJwkj?w=826&h=257)

#### 代码实现

```javascript
function bubbleSort (array) {
  const len = arr.length - 1;
  // 需要遍历的轮数
  for (let i = 0; i < len; i++) {
    // 依次的比较相邻两个数的大小，遍历一次后，把数组中第i小的数放在第i个位置上
    // 每一轮都会把最大的元素放在最后，所以 len - i 后面的元素不用再比较
    // 声明一个变量，判断当前这一轮是否有过交换，一旦没有任何元素交换，排序结束
    var isSort = false;
    for (let j = 0; j < len - i; j++) {
      if (array[j] > array[j + 1]) {
        const temp = array[j];
        array[j] = array[j + 1];
        array[j + 1] = temp;
        isSort = true;
      }
    }
    if (!done) break
  }
  return array
}
```

#### 性能

**时间复杂度：**平均时间复杂度O(n*n) 、最好情况O(n)、最差情况O(n*n)

1. 最好情况下，是数组基本有序

**空间复杂度：**O(1)

**稳定性：**稳定

## 选择排序

1. 有n个数,需要排序n-1次
2. 第一次选择最小值,放在第一位
3. 第二次选择最小值,放在第二位
4. …..重复该过程
5. 第n-1次选择最小值,放在第n-1位

#### 动图演示

![选择排序](https://segmentfault.com/img/bVJwkz?w=811&h=248)

#### 代码实现

```javascript
function selectionSort(arr) {
    var len = arr.length;
    var minIndex, temp;
    for (var i = 0; i < len - 1; i++) {
        minIndex = i;
        for (var j = i + 1; j < len; j++) {
            if (arr[j] < arr[minIndex]) {    
                minIndex = j;                
            }
        }
        if(minIndex !== i){
          temp = arr[i];
          arr[i] = arr[minIndex];
          arr[minIndex] = temp;
        }
    }
    return arr;
} 
```

## 快速排序

> 1. 在数据集之中，选择一个元素作为"基准";
> 2. 所有小于"基准"的元素，都移到"基准"的左边；所有大于"基准"的元素，都移到"基准"的右边；
> 3. 对"基准"左边和右边的两个子集，不断重复第一步和第二步，直到所有子集只剩下一个元素为止；

![Quick Sort](https://user-gold-cdn.xitu.io/2018/7/18/164acd0f33702fe6?imageslim)

#### 代码实现

方法一：

```javascript
function quickSort(arr) {
    // 检查数组的元素个数，如果小于等于1，就返回
    if (arr.length <= 1) return arr;
    // 选择"基准"，并将其与原数组分离，再定义两个空数组，用来存放一左一右的两个子集;
    const pivotIndex = Math.floor(arr.length / 2);
    // 基准元素
    const pivot = arr.splice(pivotIndex, 1)[0];
    const left = [];
    const right = [];
    // 开始遍历数组，小于基准元素放入左边的子集，大于基准的元素放入右边的子集
    for (let i = 0; i < arr.length; i++) {
      if (arr[i] < pivot) {
        left.push(pivot);
      } else {
        right.push(pivot);
      }
    }
    return quickSort(left).concat([pivot], quickSort(right));
}

// 缺点：
// 1. 获取基准点使用了一个splice操作，在js中splice会对数组进行一次拷贝的操作，而它最坏的情况下复杂度为O(n)，而O(n)代表着针对数组规模的大小进行了一次循环操作;
// 2. 每次执行都会使用到两个数组空间，产生空间复杂度;
// 3. concat操作会对数组进行一次拷贝，而它的复杂度也会是O(n);
// 4. 对大量数据的排序来说相对会比较慢;
```

方法二：

```javascript
// 交换两个元素
function swap(array, a, b) {
  const temp = array[a];
  array[a] = array[b];
  array[b] = temp;
}

function partitionLomuto(array, left, right) {
  // 设置基准值
  const pivot = array[right];
  // 当前基准点
  let i = left;
  for (let j = left; j < right; j++) {
    if (array[j] <= pivot) {
      swap(array, i, j);
      i++;
    }
  }
  swap(array, i, right);
  return i;
}

function quickSort(array, left, right) {
  if (left < right) {
    const pivot = partitionLomuto(array, left, right);
    quickSort(array, left, pivot - 1);
    quickSort(array, pivot + 1, right);
  }
  return array;
}

const array = [88, 88, 9, 14, 6, 71, 24];
console.log(quickSort(array, 0, array.length - 1));
```

## 插入排序

> 插入排序就是将未排序数据，对已排序数据序列从后向前扫描，找到对应的位置并插入；

#### 动图演示

![img](https://img2018.cnblogs.com/blog/1230971/201906/1230971-20190606093850556-1940489422.gif)

#### 代码实现

```javascript
// 1. 从第一个元素开始，该元素可以被认为已经被排序;
// 2. 取出下一个元素，在已经排好序的序列中从后往前扫描;
// 3. 直到找到小于或者等于该元素的位置;
// 4. 将该位置后面的所有已排序的元素从后往前依次移一位;
// 5. 将该元素插入到该位置;
function insertSort(array) {
  if (array.length <= 1) return array;
  // i=1开始，留着0作为有序部分，也就是说，外层循环获取数组后面的元素，也就是上面所讲的无序部分
  for (var i = 1; i < len; i++) {
    // j=i-1，就是获取有序部分最后的一个元素作为对照，也就是有序部分
    for (var j = i - 1; j >= 0; j--) {
      // 注意，j--,就是从有序部分的后面元素开始和无序部分的元素作比较
      if (array[j] > array[j + 1]) {
        var temp = array[j];
        array[j] = array[j + 1];
        array[j + 1] = temp;
      }
    }
  }
  return array;
}
```

## 希尔排序

## 归并排序

> 归并排序指的是将两个已经排序的序列合并成一个序列的操作；
>
>  采用分支法，递归地把当前序列平均分割成两半，然后再保证左右顺序情况下合并在一起；

#### 动图演示

![img](https://upload-images.jianshu.io/upload_images/1867034-18c70f637b5c01c2.gif?imageMogr2/auto-orient/strip)

#### 代码实现

```javascript
function mergeSort(array) {
  if (array.length < 2) return array;
  const middle = Math.floor(array.length / 2);
  const left = array.slice(0, middle);
  const right = array.slice(middle);
  return merge(mergeSort(left), mergeSort(right));
}
function merge(left, right) {
  const result = [];
  while (left.length && right.length) {
    if (left[0] > right[0]) {
      result.push(right.shift());
    } else {
      result.push(left.shift());
    }
  }
  return result.concat(left, right);
}

const array = [9, 88, 14, 6, 88, 71, 24];
console.log(mergeSort(array));
```

## 堆排序

> 堆是具有以下性质的完全二叉树：
>
> 每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆；
>
> 每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆；
>
> 一般升序采用大顶堆，降序采用小顶堆；

思想：

1. 将待排序序列构造成一个大顶堆，此时，整个序列的最大值就是堆顶的根节点；
2. 将其与末尾元素进行交换，此时末尾就为最大值；
3. 然后将剩余n-1个元素重新构造成一个堆，这样会得到n个元素的次小值；
4. 如此反复执行，便能得到一个有序序列了；

#### 代码实现

```javascript
let len;
// 构造一个所有节点都满足arr[parent[i]] > arr[i]的堆结构数组
function buildMaxHeap(array) {
  len = array.length;
  // 从树的最后一个有子节点的节点开始进行heapify处理
  const firstHeapifyIndex = Math.floor(len / 2 - 1);
  // 从0到firstHeapifyIndex都要进行heapify处理，才能把最大的那个节点换到根节点
  for (let i = firstHeapifyIndex; i >= 0; i--) {
    heapify(array, i);
  }
}

// 堆调整
function heapify(arr, i) {
  // 索引i的节点的左子节点索引
  let left = 2 * i + 1;
  // 索引i的节点的右子节点索引
  let right = 2 * i + 2;
  let largest = i;
  // 判断左节点是否存在且比父节点大
  if (left < len && arr[left] > arr[largest]) {
    largest = left;
  }
  // 判断右节点是否存在且与当前父子节点最大值比较
  if (right < len && arr[right] > arr[largest]) {
    largest = right;
  }
  // 如果biggestValueIndex是左子节点或右子节点，那么交换根节点与biggestValueIndex节点的值
  if (largest !== i) {
    swap(largest, i);
  }
}

function swap(arr, i, j) {
  var temp = arr[i];
  arr[i] = arr[j];
  arr[j] = temp;
}

function adjustHeap(array) {
  if (array.length > 1) {
    // 初始化堆
    buildMaxHeap(array);
    for (let i = len - 1; i > 0; i--) {
      // 把堆首(最大值)和堆尾互换
      swap(arr, 0, i);
      //当前树中最后一个节点已经是最大值，后面就不用再考虑这个节点
      len--;
      // 继续重新构建大顶堆
      if (len > 1) {
        heapify(array, 0);
      }
    }
  }
}

const array = [9, 88, 14, 6, 88, 71, 24];
console.log(adjustHeap(array));
```

## 计数排序

## 桶排序

## 基数排序







