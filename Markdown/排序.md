## 相关概念

> **稳定**：如果a原本在b前面，而a=b，排序之后a仍然在b的前面。
>
> **不稳定**：如果a原本在b的前面，而a=b，排序之后 a 可能会出现在 b 的后面。
>
> **时间复杂度**：对排序数据的总的操作次数。反映当n变化时，操作次数呈现什么规律。
>
> **空间复杂度：**是指算法在计算机内执行时所需存储空间的度量，它也是数据规模n的函数。 

## 冒泡排序

1. 比较相邻的元素，前者比后者大的话，两者交换位置
2. 对每一对相邻元素做相同操作，从开始第一对到最后一对，这样子最后的元素就是最大元素
3. 针对n个元素重复以上步骤，每次循环排除当前最后一个
4. 重复步骤1~3，直到排序完成

#### 动图演示

![冒泡排序](https://segmentfault.com/img/bVJwkj?w=826&h=257)

#### 代码实现

```javascript
function bubbleSort (array) {
  const len = arr.length - 1;
  // 需要遍历的轮数
  for (let i = 0; i < len; i++) {
    // 依次的比较相邻两个数的大小，遍历一次后，把数组中第i小的数放在第i个位置上
    // 每一轮都会把最大的元素放在最后，所以 len - i 后面的元素不用再比较
    // 声明一个变量，判断当前这一轮是否有过交换，一旦没有任何元素交换，排序结束
    var isSort = false;
    for (let j = 0; j < len - i; j++) {
      if (array[j] > array[j + 1]) {
        const temp = array[j];
        array[j] = array[j + 1];
        array[j + 1] = temp;
        isSort = true;
      }
    }
    if (!done) break
  }
  return array
}
```

#### 性能

**时间复杂度：**平均时间复杂度O(n*n) 、最好情况O(n)、最差情况O(n*n)

1. 最好情况下，是数组基本有序

**空间复杂度：**O(1)

**稳定性：**稳定

## 选择排序

1. 有n个数,需要排序n-1次
2. 第一次选择最小值,放在第一位
3. 第二次选择最小值,放在第二位
4. …..重复该过程
5. 第n-1次选择最小值,放在第n-1位

#### 动图演示

![选择排序](https://segmentfault.com/img/bVJwkz?w=811&h=248)

#### 代码实现

```javascript
function selectionSort(arr) {
    var len = arr.length;
    var minIndex, temp;
    for (var i = 0; i < len - 1; i++) {
        minIndex = i;
        for (var j = i + 1; j < len; j++) {
            if (arr[j] < arr[minIndex]) {    
                minIndex = j;                
            }
        }
        if(minIndex !== i){
          temp = arr[i];
          arr[i] = arr[minIndex];
          arr[minIndex] = temp;
        }
    }
    return arr;
} 
```

## 快速排序

> 通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。

## 插入排序

## 希尔排序

## 归并排序

## 堆排序

## 计数排序

## 桶排序

## 基数排序







