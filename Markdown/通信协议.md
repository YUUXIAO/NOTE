

## TCP



### 重传机制

> TCP 实现可靠传输的方式之一：是通过序列号与确认应答。

在 TCP 中，当发送端的数据到达接收主机时，接收端主机会返回一个确认应答消息，表示已收到消息。

![img](https://user-gold-cdn.xitu.io/2020/7/25/17384f114569c301?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

但在错综复杂的网络，并不一定能如上图那么顺利能正常的数据传输，万一数据在传输过程中丢失了呢？所以 TCP 针对数据包丢失的情况，会用重传机制解决：

#### 快速重传

> 快速重传（Fast Retransmit）机制，它不以时间为驱动，而是以数据驱动重传。

![img](https://user-gold-cdn.xitu.io/2020/7/25/17384f116656218a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)



在上图，发送方发出了 1，2，3，4，5 份数据：

- 第一份 Seq1 先送到了，于是就 Ack 回 2；
- 结果 Seq2 因为某些原因没收到，Seq3 到达了，于是还是 Ack 回 2；
- 后面的 Seq4 和 Seq5 都到了，但还是 Ack 回 2，因为 Seq2 还是没有收到；
- 发送端收到了三个 Ack = 2 的确认，知道了 Seq2 还没有收到，就会在定时器过期之前，重传丢失的 Seq2。
- 最后，接收到收到了 Seq2，此时因为 Seq3，Seq4，Seq5 都收到了，于是 Ack 回 6 。

所以，快速重传的工作方式是当收到三个相同的 ACK 报文时，会在定时器过期之前，重传丢失的报文段。

快速重传机制只解决了一个问题，就是超时时间的问题，但是它依然面临着另外一个问题。就是重传的时候，是重传之前的一个，还是重传所有的问题。

比如对于上面的例子，是重传 Seq2 呢？还是重传 Seq2、Seq3、Seq4、Seq5 呢？因为发送端并不清楚这连续的三个 Ack 2 是谁传回来的。

为了解决不知道该重传哪些 TCP 报文，于是就有 SACK 方法。

#### SACK

> SACK（ Selective Acknowledgment 选择性确认）；
>
> 这种方式需要在 TCP 头部「选项」字段里加一个 SACK 的东西，它可以将缓存的地图发送给发送方，这样发送方就可以知道哪些数据收到了，哪些数据没收到，知道了这些信息，就可以只重传丢失的数据；

![img](https://user-gold-cdn.xitu.io/2020/7/25/17384f117128506f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)



#### Duplicate  SACK

> Duplicate SACK 又称 D-SACK，主要使用了 SACK 来告诉「发送方」有哪些数据被重复接收了。

![img](https://user-gold-cdn.xitu.io/2020/7/25/17384f11748d020f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

ACK 丢包

- 「接收方」发给「发送方」的两个 ACK 确认应答都丢失了，所以发送方超时后，重传第一个数据包（3000 ~ 3499）。
- 于是「接收方」发现数据是重复收到的，于是回了一个 SACK = 3000~3500，告诉「发送方」 3000~3500 的数据早已被接收了，因为 ACK 都到了 4000 了，已经意味着 4000 之前的所有数据都已收到，所以这个 SACK 就代表着 D-SACK。
- 这样「发送方」就知道了，数据没有丢，是「接收方」的 ACK 确认报文丢了。

![img](https://user-gold-cdn.xitu.io/2020/7/25/17384f118232614c?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

网络延时

- 数据包（1000~1499） 被网络延迟了，导致「发送方」没有收到 Ack 1500 的确认报文。
- 而后面报文到达的三个相同的 ACK 确认报文，就触发了快速重传机制，但是在重传后，被延迟的数据包（1000~1499）又到了「接收方」；
- 所以「接收方」回了一个 SACK=1000~1500，因为 ACK 已经到了 3000，所以这个 SACK 是 D-SACK，表示收到了重复的包。
- 这样发送方就知道快速重传触发的原因不是发出去的包丢了，也不是因为回应的 ACK 包丢了，而是因为网络延迟了。

D-SACK 的好处：

1. 可以让「发送方」知道，是发出去的包丢了，还是接收方回应的 ACK 包丢了;
2. 可以知道是不是「发送方」的数据包被网络延迟了;
3. 可以知道网络中是不是把「发送方」的数据包给复制了;

### 滑动窗口协议

##### 窗口

> 窗口大小就是指无需等待确认应答，而可以继续发送数据的最大值；
>
> 窗口的实现实际上是操作系统开辟的一个缓存空间，发送方主机在等到确认应答返回之前，必须在缓冲区中保留已发送的数据。如果按期收到确认应答，此时数据就可以从缓存区清除。

假设窗口大小为 3 个 TCP 段，那么发送方就可以「连续发送」 3 个 TCP 段，并且中途若有 ACK 丢失，可以通过「下一个确认应答进行确认」。如下图：

![img](https://user-gold-cdn.xitu.io/2020/7/25/17384f118863234b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)



**窗口大小由哪一方决定？**

- 通常窗口的大小是由接收方的决定的。
- TCP 头里有一个字段叫 Window，也就是窗口大小。
- 这个字段是接收端告诉发送端自己还有多少缓冲区可以接收数据。于是发送端就可以根据这个接收端的处理能力来发送数据，而不会导致接收端处理不过来。
- 发送方发送的数据大小不能超过接收方的窗口大小，否则接收方就无法正常接收到数据。

**发送方的滑动窗口**

![img](https://user-gold-cdn.xitu.io/2020/7/25/17384f11a6572ab5?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

\#1 是已发送并收到 ACK 确认的数据：1~31 字节

\#2 是已发送但未收到 ACK 确认的数据：32~45 字节

\#3 是未发送但总大小在接收方处理范围内（接收方还有空间）：46~51 字节

\#4 是未发送但总大小超过接收方处理范围（接收方没有空间）：52 字节以后

当发送方把数据「全部」都一下发送出去后，可用窗口的大小就为 0 了，表明可用窗口耗尽，在没收到 ACK 确认之前是无法继续发送数据了。

![img](https://user-gold-cdn.xitu.io/2020/7/25/17384f119ca2a493?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

当收到之前发送的数据 32~36 字节的 ACK 确认应答后，如果发送窗口的大小没有变化，则滑动窗口往右边移动 5 个字节，因为有 5 个字节的数据被应答确认，接下来 52~56 字节又变成了可用窗口，那么后续也就可以发送 52~56这 5 个字节的数据了。

![img](https://user-gold-cdn.xitu.io/2020/7/25/17384f11a9324c17?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

**程序是如何表示发送方的四个部分的呢？**

TCP 滑动窗口方案使用三个指针来跟踪在四个传输类别中的每一个类别中的字节。其中两个指针是绝对指针（指特定的序列号），一个是相对指针（需要做偏移）。

![img](https://user-gold-cdn.xitu.io/2020/7/25/17384f11ace81178?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

SND.WND、SND.UN、SND.NXT

- SND.WND：表示发送窗口的大小；
- SND.UNA：是一个绝对指针，它指向的是已发送但未收到确认的第一个字节的序列号。
- SND.NXT：也是一个绝对指针，它指向未发送但可发送范围的第一个字节的序列号。
- 指向 #4 的第一个字节是个相对指针，它需要 SND.UNA 指针加上 SND.WND 大小的偏移量，就可以指向 #4 的第一个字节了。

**接收方的滑动窗口**

- \#1 + #2 是已成功接收并确认的数据（等待应用进程读取）；
- \#3 是未收到数据但可以接收的数据；
- \#4 未收到数据并不可以接收的数据；

![img](https://user-gold-cdn.xitu.io/2020/7/25/17384f11b680af2c?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)



其中三个接收部分，使用两个指针进行划分:

- RCV.WND：表示接收窗口的大小，它会通告给发送方。
- RCV.NXT：是一个指针，它指向期望从发送方发送来的下一个数据字节的序列号。
- 指向 #4 的第一个字节是个相对指针，它需要 RCV.NXT 指针加上RCV.WND 大小的偏移量，就可以指向 #4 的第一个字节了。

**接收窗口和发送窗口的大小是相等的吗？**

并不是完全相等，接收窗口的大小是约等于发送窗口的大小的。

因为滑动窗口并不是一成不变的。比如，当接收方的应用进程读取数据的速度非常快的话，这样的话接收窗口可以很快的就空缺出来。那么新的接收窗口大小，是通过 TCP 报文中的 Windows 字段来告诉发送方。那么这个传输过程是存在时延的，所以接收窗口和发送窗口是约等于的关系。

### 流量控制

发送方不能无脑的发数据给接收方，要考虑接收方处理能力；如果一直无脑的发数据给对方，但对方处理不过来，那么就会导致触发重发机制，从而导致网络流量的无端的浪费。

为了解决这种现象发生，TCP 提供一种机制可以让「发送方」根据「接收方」的实际接收能力控制发送的数据量，这就是所谓的流量控制。

#### 死锁状态

> 当接收端向发送端发送零窗口报文段后不久，接收端的接收缓存又有了一些存储空间，于是接收端向发送端发送了Windows size = 2的报文段，然而这个报文段在传输过程中丢失了。发送端一直等待收到接收端发送的非零窗口的通知，而接收端一直等待发送端发送数据，这样就死锁了。

解决方法：

```
TCP为每个连接设有一个持续计时器。只要TCP连接的一方收到对方的零窗口通知，就启动持续计时器，若持续计时器设置的时间到期，就发送一个零窗口探测报文段（仅携带1字节的数据），而对方就在确认这个探测报文段时给出了现在的窗口值。
```

#### Negle算法

Negle算法主要为了解决TCP的传输效率问题。Negle算法规定：

若要把发送的数据逐个字节缓存起来，则发送方需要把第一个字节发送出去，然后缓存后面的字节，在收到接收方第一个字节的确认，再将现有缓存中所有字节组成一个报文段发送出去，继续缓存后续数据。只有在收到前一个报文的确认之后发送后面的数据。这是为了减少所用带宽。当发送数据到达TCP发送窗口的一半或已达到报文段的最大长度也会立即发送报文段，而不是等待接收方确认。这是为了提高网络吞吐量。

#### 糊涂窗口综合征

TCP接收方的缓存已满，若上层一次从缓存中读取一个字节，这样接收方就可以继续接纳一个字节的窗口，然后向发送方发送确认，把窗口设为1个字节（上文所讲，IP数据报为41字节长）。如果这样持续下去，那么网络效率非常低。

所以有效的解决方法，就是让接收方等待一定时间，让缓存空间能够接纳一个最长的报文段，或者等待接收缓存已有一半的空闲空间，再发出确认报文和通知当前窗口大小。