目前常见的通信协议都是建立在 TCP 链接之上；

## TCP

> TCP是因特网中的传输层协议，使用三次握手协议建立连接。当主动方发出SYN连接请求后，等待对方回答；

### http 1.0

> Http 1.0 的致命缺点,就是无法复用 TCP 连接和并行发送请求，这样每次一个请求都需要三次握手，而且其实建立连接和释放连接的这个过程是最耗时的，传输数据相反却不那么耗时。还有本地时间被修改导致响应头expires的缓存机制失效的问题

1. 早先1.0的HTTP版本，是一种无状态、无连接的应用层协议。
   - 无连接：HTTP1.0规定浏览器和服务器保持短暂的连接，浏览器的每次请求都需要与服务器建立一个TCP连接，服务器处理完成后立即断开TCP连接；
   - 无状态：服务器不跟踪每个客户端也不记录过去的请求；
2. 这种无状态性可以借助cookie/session机制来做身份认证和状态记录。而下面两个问题就比较麻烦了：
   - 无连接的特性导致最大的性能缺陷就是无法复用连接：每次发送请求的时候，都需要进行一次TCP的连接，而TCP的连接释放过程又是比较费事的。这种无连接的特性会使得网络的利用率非常低。
   - 其次就是队头阻塞：由于HTTP1.0规定下一个请求必须在前一个请求响应到达之前才能发送。假设前一个请求响应一直不到达，那么下一个请求就不发送，同样的后面的请求也给阻塞了。

### Http 1.1

1. Http 1.1 出现，克服了它的缺点，出现了keep-alive这个头部字段，它表示会在建立 TCP 连接后，完成首次的请求，并不会立刻断开 TCP 连接，而是保持这个连接状态，进而可以复用这个通道

2. Http 1.1并且支持请求管道化，“并行”发送请求，但是这个并行，也不是真正意义上的并行，而是可以让我们把先进先出队列从客户端（请求队列）迁移到服务端（响应队列）

   > 例如：客户端同时发了两个请求分别来获取html和css，假如说服务器的css资源先准备就绪，服务器也会先发送html再发送css。

3. HTTP1.1好像还是无法解决队头阻塞的问题

缺点：

1. 通信使用明文（ 不加密） ， 内容可能会被窃听；
2. 还是没有解决无状态连接；
3. 当有多个请求同时被挂起的时候 就会拥塞请求通道，导致后面请求无法发送；
4. 臃肿的消息首部：HTTP/1.1能压缩请求内容,但是消息首部不能压缩;在现今请求中,消息首部占请求绝大部分(甚至是全部)也较为常见.

### Http 2.0

> 相较于HTTP1.1，HTTP2.0的主要优点有采用二进制帧封装，传输变成多路复用，流量控制算法优化，服务器端推送，首部压缩，优先级等特点

> HTTP1.x的解析是基于文本的，基于文本协议的格式解析存在天然缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多。而HTTP/2会将所有传输的信息分割为更小的消息和帧，然后采用二进制的格式进行编码，HTTP1.x的头部信息会被封装到HEADER frame，而相应的RequestBody则封装到DATAframe里面。不改动HTTP的语义，使用二进制编码，实现方便且健壮。

- 多路复用

  ```javascript
  所有的请求都是通过一个 TCP 连接并发完成。HTTP/1.x 虽然通过 pipeline 也能并发请求，但是多个请求之间的响应会被阻塞的;
  而 HTTP/2 做到了真正的并发请求。同时，流还支持优先级和流量控制。当流并发时，就会涉及到流的优先级和依赖。即：HTTP2.0对于同一域名下所有请求都是基于流的，不管对于同一域名访问多少文件，也只建立一路连接。优先级高的流会被优先发送。图片请求的优先级要低于 CSS 和 SCRIPT，这个设计可以确保重要的东西可以被优先加载完
  ```

- 流量控制

  ```javascript
  TCP协议通过sliding window的算法来做流量控制。发送方有个sending window，接收方有receive window。
  http2.0的flow control是类似receive window的做法，数据的接收方通过告知对方自己的flow window大小表明自己还能接收多少数据。只有Data类型的frame才有flow control的功能。
  对于flow control，如果接收方在flow window为零的情况下依然更多的frame，则会返回block类型的frame，这张场景一般表明http2.0的部署出了问题。
  ```

- 服务器端推送

  ```javascript
  服务器端的推送，就是服务器可以对一个客户端请求发送多个响应。除了对最初请求的响应外，服务器还可以额外向客户端推送资源，而无需客户端明确地请求。
  当浏览器请求一个html，服务器其实大概知道你是接下来要请求资源了，而不需要等待浏览器得到html后解析页面再发送资源请求。
  ```

- 首部压缩

  1. HTTP 2.0 在客户端和服务器端使用“首部表”来跟踪和存储之前发送的键-值对，对于相同的数据，不再通过每次请求和响应发送;通信期间几乎不会改变的通用键-值对(用户代理、可接受的媒体类型,等等)只 需发送一次。事实上,如果请求中不包含首部(例如对同一资源的轮询请求),那么 首部开销就是零字节。此时所有首部都自动使用之前请求发送的首部。
  2. 如果首部发生变化了，那么只需要发送变化了数据在Headers帧里面，新增或修改的首部帧会被追加到“首部表”。首部表在 HTTP 2.0 的连接存续期内始终存在,由客户端和服务器共同渐进地更新 。
  3. 本质上，当然是为了减少请求，通过多个js或css合并成一个文件，多张小图片拼合成Sprite图，可以让多个HTTP请求减少为一个，减少额外的协议开销，而提升性能。当然，一个HTTP的请求的body太大也是不合理的，有个度。文件的合并也会牺牲模块化和缓存粒度，可以把“稳定”的代码or 小图 合并为一个文件or一张Sprite，让其充分地缓存起来，从而区分开迭代快的文件。

#### TCP滑动窗口协议

>  滑动窗口通俗来讲就是一种流量控制技术；
>
> 本质上是描述接收方的TCP数据报缓冲区大小的数据，发送方根据这个数据来计算自己最多能发送多长的数据，如果发送方收到接收方的窗口大小为0的TCP数据报，那么发送方将停止发送数据，等到接收方发送窗口大小不为0的数据报的到来

在TCP协议当中窗口机制分为两种：

1. 固定的窗口大小：我们假设固定窗口的大小为1，也就是每次只能发送一个数据，只有接收方对数据进行了确认后才能发送第二个数据。发送方每发送一个数据接收方就要给发送方一个ACK对这个数据进行确认。只有接收了确认数据后发送方才能传输下个数据。

   **存在的问题：**如果窗口过小，当传输比较大的数据的时候需要不停的对数据进行确认，这个时候就会造成很大的延迟。

2. 滑动窗口

##### 工作原理

![img](https://img-blog.csdn.net/20180416152502401)

- 第一次发送数据这个时候的窗口大小是根据链路带宽的大小来决定的。

- 假设这时候的窗口是3.这个时候接收方收到数据以后会对数据进行确认告诉发送方我下次希望收到的数据是多少。

- 在上图中：我们看到接收方发送的ACK = 3（这是对发送方发送序列2的回答确认，下一次接收方期望接收到的是3序列信号），这个时候发送方收到这个数据以后就知道我第一次发送的3个数据对方只收到了两个，就知道第三个数据对方没有收到，下次返送的时候就从第3个数据开始发。这时候窗口大小就变为了2.

  ![img](https://img-blog.csdn.net/20180416153814545)

- 看到接收方发送的ACK是5就表示他下一次希望收到的数据是5，发送方就知道我刚才发送的2个数据对方收到了，这个时候开始发送第5个数据。

- 当链路变好或者变差，这个窗口还会发生变化，并不是第一次协商好了以后就永远不会变化了。

##### 死锁状态

>  当接收端向发送端发送零窗口报文段后不久，接收端的接收缓存又有了一些存储空间，于是接收端向发送端发送了Windows size = 2的报文段，然而这个报文段在传输过程中丢失了。发送端一直等待收到接收端发送的非零窗口的通知，而接收端一直等待发送端发送数据，这样就死锁了。

解决方法：

```
TCP为每个连接设有一个持续计时器。只要TCP连接的一方收到对方的零窗口通知，就启动持续计时器，若持续计时器设置的时间到期，就发送一个零窗口探测报文段（仅携带1字节的数据），而对方就在确认这个探测报文段时给出了现在的窗口值。
```

##### TCP报文段的发送时机（传输效率问题）

可以用以下三种不同的机制控制TCP报文段的发送时机：

1. TCP维持一个变量MSS，等于最大报文段的长度。只要缓冲区存放的数据达到MSS字节时，就组装成了一个TCP报文段发送出去；
2. 由发送方的应用进程指明要发送的报文段，即：TCP支持推送操作；
3. 发送方的一个计时器期限到了，这时就把当前已有的缓存数据装入报文段（但长度不能超过MSS）发送出去。

### https

> HTTP+ 加密 + 认证 + 完整性保护 =HTTPS
>
> 我们把添加了加密及认证机制的 HTTP 称为 HTTPS；

- 如果在 HTTP 协议通信过程中使用未经加密的明文，比如在 Web 页面中输入信用卡号，如果这条通信线路遭到窃听，那么信用卡号就暴露了；
- 对于 HTTP 来说，服务器也好，客户端也好，都是没有办法确认通信方的。

因为很有可能并不是和原本预想的通信方在实际通信。并且还需要考虑到接收到的报文在通信途中已经遭到篡改这一可能性，为了统一解决这些问题，需要在 HTTP 上再加入加密处理和认证等机制。

#### HTTPS 是身披 SSL 外壳的 HTTP

HTTPS 并非是应用层的一种新协议。只是 HTTP 通信接口部分用 SSL（SecureSocket Layer）和 TLS（Transport Layer Security）协议代替而已。

通常，HTTP 直接和 TCP 通信

- 当使用 SSL 时，则演变成先和 SSL 通信，再由 SSL和 TCP 通信了。
- 在采用 SSL 后，HTTP 就拥有了 HTTPS 的加密、证书和完整性保护这些功能。
- SSL 是独立于 HTTP 的协议，所以不光是 HTTP 协议，其他运行在应用层的 SMTP和 Telnet 等协议均可配合 SSL 协议使用。可以说 SSL 是当今世界上应用最为广泛的网络安全术。

#### 相互交换密钥的公开密钥加密技术 -----对称加密

> 加密和解密都会用到密钥。没有密钥就无法对密码解密，反过来说，任何人只要持有密钥就能解密了。如果密钥被攻击者获得，那加密也就失去了意义。

- SSL 采用一种叫做公开密钥加密（Public-key cryptography）的加密处理方式。
- 近代的加密方法中加密算法是公开的，而密钥却是保密的。通过这种方式得以保持加密方法的安全性。

#### HTTPS 采用混合加密机制

- HTTPS 采用共享密钥加密和公开密钥加密两者并用的混合加密机制。
- 但是公开密钥加密与共享密钥加密相比，其处理速度要慢。所以应充分利用两者各自的优势，将多种方法组合起来用于通信。在交换密钥环节使用公开密钥加密方式，之后的建立通信交换报文阶段则使用共享密钥加密方式。

#### 存在的问题

HTTPS 也存在一些问题，那就是当使用 SSL 时，它的处理速度会变慢。

SSL 的慢分两种：一种是指通信慢；另一种是指由于大量消耗 CPU 及内存等资源，导致处理速度变慢。

- 和使用 HTTP 相比，网络负载可能会变慢 2 到 100 倍。除去和 TCP 连接、发送 HTTP 请求 和响应以外，还必须进行 SSL 通信，因此整体上处理通信量不可避免会增加。
- 另一点是 SSL 必须进行加密处理。在服务器和客户端都需要进行加密和解密的运算处理。因此从结果上讲，比起 HTTP 会更多地消耗服务器和客户端的硬件资源，导致负载增强。

针对速度变慢这一问题，并没有根本性的解决方案，可以使用 SSL 加速器这种（专用服务器）硬件来改善该问题。该硬件为 SSL 通信专用硬件，相对软件来讲，能够提高数倍 SSL 的计算速度。仅在 SSL 处理时发挥 SSL加速器的功效，以分担负载。

#### 为什么不一直使用 HTTPS

- 其中一个原因是，因为与纯文本通信相比，加密通信会消耗更多的 CPU 及内存资源。如果每次通信都加密，会消耗相当多的资源，平摊到一台计算机上时，能够处理的请求数量必定也会随之减少；因此，如果是非敏感信息则使用 HTTP 通信，只有在包含个人信息等敏感数据时，才利用 HTTPS 加密通信，以节约资源。特别是每当那些访问量较多的 Web 网站在进行加密处理时，它们所承担着的负载不容小觑。在进行加密处理时，并非对所有内容都进行加密处理，而是仅在那些需要信息隐藏时才会加密。
- 除此之外，想要节约购买证书的开销也是原因之一：进行 HTTPS 通信，证书是必不可少的。而使用的证书必须向认证机构（CA）购买。证书价格可能会根据不同的认证机构略有不同。那些购买证书并不合算的服务以及一些个人网站，可能只会选择采用HTTP 的通信方式。

## webSocket

> 传统的协议无法服务端主动 push 数据，于是有了这些骚操作：
>
> - 轮询，在一个定时器中不停向服务端发送请求；
> - 长轮询，发送请求给服务端，直到服务端觉得可以返回数据了再返回响应，否则这个请求一直挂起；

为了解决实时通讯，数据同步的问题，出现了 webSocket：

1. webSockets 的目标是在一个单独的持久连接上提供全双工、双向通信。在Javascript创建了Web Socket之后，会有一个HTTP请求发送到浏览器以发起连接。在取得服务器响应后，建立的连接会将HTTP升级从HTTP协议交换为WebSocket协议。
2. webSocket 原理： 在TCP连接第一次握手的时候，升级为ws协议。后面的数据交互都复用这个TCP通道。

```javascript
const ws = new WebSocket('ws://localhost:8080');
ws.onopen = function () {
    ws.send('123')
    console.log('open')
}
ws.onmessage = function () {
    console.log('onmessage')
}
ws.onerror = function () {
    console.log('onerror')
}
ws.onclose = function () {
    console.log('onclose')
}
```

