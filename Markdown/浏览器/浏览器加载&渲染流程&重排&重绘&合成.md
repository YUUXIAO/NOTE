## 浏览器页面加载过程

### GUI 渲染 / JS 引擎线程

页面加载过程中会用到：

- **GUI 渲染线程：**负责渲染浏览器界面的 HTML 元素
- **JS引擎线程：**负责处理 js 脚本程序

由于在 JS 中可以修改 html 元素的结构和样式，所以此线程与 GUI 渲染线程是互斥的，当 JS 引擎执行时，GUI 会挂起保存在一个队列中，直到 JS 程序执行完成才会接着执行；

- 如果 JS 执行的时间过长，会造成页面的渲染不连贯,导致页面渲染加载阻塞的感觉；
- 如果 JS 文件中没有操作 DOM 相关代码，可以将该 JavaScript 脚本设置为异步加载，通过 async 或 defer 来标记代码；

### 页面加载过程

1. 打开网页，浏览器从服务器中获取到 HTML 内容
2. 获取到 HTML 内容，就开始**从上到下解析** HTML 的元素
3. **< head > 元素的内容会先被解析，此时浏览器还没有开始渲染页面**

   - < head >元素里有< meta>、< link> 和 < script> 等元素涉及外部资源（图片、CSS样式、js脚本等 ）此时浏览器会去获取这些外部资源（**会暂停解析并下载 JavaScript 脚本**）
   - JavaScript 脚本下载完成后，浏览器的控制权转交给 JS 引擎。当脚本执行完成后，控制权会交回给渲染引擎，渲染引擎继续往下解析 HTML 页面。
   - 此时`<body>`元素内容开始被解析，浏览器开始渲染页面


从上面的流程可以看出：

- `<head>`中放置的`<script>`元素会阻塞页面的渲染过程：把 JS放在`<head>`里，意味着必须把所有 JS 代码都下载、解析和解释完成后，才能开始渲染页面
- 如果外部脚本加载时间很长（比如一直无法完成下载），就会造成网页长时间失去响应，浏览器就会呈现“假死”状态，用户体验会变得很糟糕
- 对于对性能要求较高、需要快速将内容呈现给用户的网页，需要将 JS脚本放在`<body>`的最后面。这样可以避免资源阻塞，页面得以迅速展示。
- 还可以使用defer/async/preload等属性来标记`<script>`标签，来控制 js的加载顺序。

### defer 和 async

一般情况下，浏览器在渲染过程中遇到 script 标签时，会停止渲染去下载并执行 js 代码，等待 js 执行完毕后再继续渲染，这样会造成浏览器阻塞；

defer 和 async 设置脚本是脚本的加载过程和文档加载都是异步发生的，区别只是在于执行时机不同

#### defer（延迟执行）

defer 属性表示**延迟执行**引入的 JS 脚本；

带 defer 的脚本不会影响HTML文档的解析，会等 HTML 解析完成后才会执行， DOMContentLoaded 只有在 defer 脚本执行结束后才会被触发；

- HTML 还没解析完成时，defer 脚本已经加载完毕，那么 defer 脚本将等待 HTML 解析完成后再执行，defer 脚本执行完毕后触发DOMContentLoaded 事件；
- HTML 解析完成时，defer脚本还没加载完毕，那么 defer 脚本继续加载，加载完成后直接执行，执行完毕后触发 DOMContentLoaded事件；

#### async（脚本加载完成立即执行）

async 属性表示**异步加载**引入的 JS 脚本，等脚本加载完成后就会执行

带 async 的脚本一定会在 load 事件之前执行，可能会在 DOMContentLoaded 之前或之后执行；

- HTML 还没有被解析完时，async 脚本已经加载完了，那么HTML 停止解析，去执行脚本，脚本执行完毕后触发 DOMContentLoaded 事件；
- HTML 解析完了之后，async 脚本才加载完然后再执行脚本，那么在 HTML 解析完毕、async 脚本还没加载完的时候就触发DOMContentLoaded 事件；

#### 两者的区别

- 两者都是异步去加载外部JS文件，不会阻塞DOM解析；
- async 属性脚本一旦可用，就立即异步执行，不论 HMTL 是否解析完成；
- defer 属性是否延迟执行脚本，直到页面加载为止，会按照页面上 script 标签顺序；
- 如果同时有 async 和 defer 属性时，执行效果与 async 一致；

```html
// 浏览器会立即加载并执行相应的脚本
<script src="dadaqianduan.js"></script> 

// 后续文档的加载和渲染与js脚本的加载和执行是并行进行的
<script async src="dadaqianduan.js"></script> 

// 加载后续文档的过程和js脚本的加载是并行进行的，js脚本的执行需要等到文档所有元素解析完成之后，DOMContentLoaded事件触发执行之前
<script defer src="dadaqianduan.js"></script> 
```

### DOMContentLoaded和load

- DOMContentLoaded：仅当DOM解析完成后，不包括样式表、图片等资源触发，可以理解为是**访问这个网页从空白到出现内容**的时候就是 DOMContentLoaded 事件完成的时间
- load：页面上**所有的Dom、样式、脚本、图片等资源已经加载完毕**触发；

## CSS加载

- **CSS 加载不会阻塞DOM 树的解析**：DOM和CSSOM是并行构建的；

  - CSSOM 提供给 JS 操作样式表的能力；
  - CSSOM 为布局树的合成提供基础的样式信息；
  - CSSOM体现在DOM中就是 document.styleSheets；

- **CSS加载会阻塞DOM渲染**：由于render Tree 是依赖 DOM Tree 和 CSSOM Tree 的，所以它必须等到两者都加载完毕之后，完成相应的构建才开始渲染；
- **css 会阻塞后面 js 的执行**：JS文件下载和CSS文件下载是并行的，有时候CSS文件很大，JS需要等待，因此样式表会在后面的 js 执行前先加载执行完毕；

## 渲染机制

### 构建DOM树

这个过程主要工作就是将 HTML 内容转换为浏览器DOM树结构；

### 样式计算

1. **格式化样式表**：浏览器无法直接去识别0，1字节流数据，所以渲染引擎收到CSS文本数据后，会将其转换为浏览器可以理解的结构 --styleSheets；
2. **标准化样式表**：如em->px,red->rgba(255,0,0,0),bold->700等等；
3. **计算每个DOM节点的具体样式**：输出的内容是每个节点 DOM 的样式，被保存在 ComputedStyle 中，可以通过 JS 来获取计算后的样式；

### 生成布局树

1. **创建布局树**：在DOM上不可见的元素，head元素，meta元素，以及使用display：none属性的元素，最后都不会出现在布局树上，所以浏览器布局系统需要额外构建一棵只包含可见元素的布局树；

   - 遍历DOM树可见节点，并把这些节点加到布局树中；
   - 对于不可见的节点，head,meta 标签等都会被忽略，属性包含display:none,的元素没有被包含进布局树；

2. **布局计算**：计算布局树节点的坐标位置；

### 分层

浏览器在构建完布局树后，考虑到一些复杂的场景，比如 3D 变换、页面滚动，或者使用 z-indexing 做 z 轴排序等，还有含有层叠上下文如何控制显示和隐藏等情况；

- 生成图层树（Layer Tree）；
- 拥有层叠上下文属性的元素会被提升为单独的一层；
- 需要裁剪的地方也会创建图层；
- 图层绘制；

#### 显式合成

1. **拥有层叠上下文的节点**：一般是有一些特定的CSS属性创建的元素节点

   - HTML根元素本身就具有层叠上下文；
   - 普通元素设置 position 不为 static 并且设置了 z-index 属性；
   - 元素的 opacity 值不是1；
   - 元素的 transform 值不是 none；
   - 元素的 filter 值不是 none；
   - 元素的 isolation 值是 isolate；
   - will-change 指定的属性值为上面任意一个；

2. **需要剪裁的地方**：比如一个标签里面放了非常多的文字，超出的文字部分就需要被剪裁，如果出现了滚动条，那么滚动条也会被单独提升为一个图层；

#### 隐式合成

**层爆炸**：如果在一个大型的项目中，一个z-index比较低的节点被提升为单独的图层后，叠在它上面的元素统统都会提升为单独的图层，如果有上千个图层，会增大内存的压力，有时候会让页面崩溃

### 绘制

图层的绘制每次都会把一个复杂的图层拆分为很小的绘制指令，然后再按照这些指令的顺序组成一个绘制列表；

### 分块

1. 实际在渲染进程中绘制操作是由专门的线程来完成的，叫**合成线程**；
2. 绘制列表准备好了之后，渲染进程的主线程会给合成线程发送commit消息，把绘制列表提交给合成线程；
3. 合成线程会将图层划分为图块，这些块的大小一般不会特别大，这样可以大大加速页面的首屏展示；
4. **首屏渲染加速**可以这么理解：

后面图块（非视口内的图块）数据要进入 GPU 内存，考虑到浏览器内存上传到 GPU 内存的操作比较慢，即使是绘制一部分图块，也可能会耗费大量时间；

针对这个问题，Chrome 采用了一个策略:

在首次合成图块时只采用一个低分辨率的图片，在首屏展示的时候只是展示出低分辨率的图片，这个时候继续进行合成操作，当正常的图块内容绘制完毕后，会将当前低分辨率的图块内容替换，这也是 Chrome 底层优化首屏加载速度的一个手段。

### 光栅化

所谓栅格化，是指将图块转换为位图；

有了图块之后，合成线程会按照视口附近的图块来优先生成位图，实际生成位图的操作是由栅格化来执行的；

- 图块是栅格化执行的最小单位；
- 渲染进程专门维护了一个栅格化线程池，负责把图块转换为位图数据；
- 合成线程会选择视口附近的图块，把它交给栅格化线程池生成位图；
- 生成位图的过程实际上都会使用GPU进行加速，生成的位图最后发送给合成线程；

栅格化过程都会使用 GPU 来加速生成，使用 GPU 生成位图的过程叫快速栅格化，或者 GPU 栅格化，生成的位图被保存在 GPU 内存中；

### 合成和显示

栅格化操作完成 之后，合成线程会生成 一个绘制指令，并发送给浏览器进程，浏览器进程中的viz组件接收到这个命令，把页面内容绘制到内存，也就是生成了页面，然后把这部分内存发送给显卡；

对显示器显示图像的原理解释:

> 无论是 PC 显示器还是手机屏幕，都有一个固定的刷新频率，一般是 60 帧，也就是一秒更新 60 张图片，一张图片停留的时间约为 16.7 ms，而每次更新的图片都来自显卡的前缓冲区，而显卡接收到浏览器进程传来的页面后，会合成相应的图像，并将图像保存到后缓冲区，然后系统自动将前缓冲区和后缓冲区对换位置，如此循环更新；

### requestAnimationFrame

window.requestAnimationFrame() 方法告诉浏览器您希望执行动画，并请求**浏览器在下一次重绘之前调用**指定的函数来更新动画；

该方法使用一个回调函数作为参数，回调函数会在浏览器重绘之前调用；

- 如果 js 方法中需要绘制或者直接改变属性,选择 requestAnimationFrame，只要涉及到重新计算元素位置，就可以使用它；
- 传统的 js 动画是通过定时器 setTimeout 或者 setInterval 实现的；

  - **动画的循环时间间隔不好确定**：设置长了动画显得不够平滑流畅，设置短了浏览器的重绘频率会达到瓶颈，最佳循环间隔是 17ms ；
  - **时间控制不稳定**：定时器第二个时间参数只是指定了多久后将动画任务添加到浏览器的 UI 线程队列中，如果UI线程处于忙碌状态，动画不会立刻执行；


#### 优势

H5 中加入了 requestAnimationFrame 以及 requestIdleCallback；

- requestAnimationFrame 会把每一帧中的所有 DOM 操作集中起来，在一次重绘或回流中就完成，并且重绘或回流的时间间隔紧紧跟随浏览器的刷新频率；
- 在隐藏或不可见的元素中，requestAnimationFrame 将不会进行重绘或回流，这当然就意味着更少的 CPU、GPU 和内存使用量；
- requestAnimationFrame 是由浏览器专门为动画提供的 API，在运行时浏览器会自动优化方法的调用，并且如果页面不是激活状态下的话，动画会自动暂停，有效节省了 CPU 开销；

#### 比较setTimeout

- **动画的循时间环间隔：**rAF 最大的优势是由系统绘制频率来决定回调函数的执行；
- 定时器只是指定了多久后将动画任务添加到浏览器的UI线程队列中，如果 UI 线程处于忙碌状态，动画执行时间会有偏差；
- **rAF 可以自动调节频率：**如果 callback 工作内容太多无法在一帧内完成，就会自动降低为 30fps，不会掉帧；
- 当页面隐藏或最小化，setTimeout 仍会在后台执行，浪费CPU；
- **当页面处理未激活的状态时，rAF 也会停止渲染**，当页面激活，动画就从上次停留的地方继续执行，节省 CPU 开销；

#### 比较节流

1. 动画保持 60fps，浏览器内部决定渲染的最佳时机；
2. 简洁标准的 API，后期维护成本低；
3. 动画开始/结束需要开发都自己控制，不像节流由函数内部处理；
4. 浏览器标签未激活时，一切都不会执行；
5. 尽管所有的现代浏览器都支持rAF，IE9，Opera Mini 和 老的 Android 还是需要打补丁；
6. Node.js 不支持，无法在服务器端用于文件系统事件；
7. 如果 Javascript 方法需要绘制或者直接改变属性，选择 rAF ，只要涉及到重新计算元素位置，就使用它；
8. 如果涉及到 Ajax，添加/移除 class（触发CSS 动画），选择节流或防抖，可以设置更低的频率；

## 重排&重绘&合成

### 回流

> 回流就是对 DOM 结构的修改引发 DOM 几何尺寸变化的时候；

有以下的操作会触发回流：

1. **一个DOM元素的几何属性变化：**常见的几何属性有width、height、padding、margin、left、top、border 等；
2. **使DOM结点发生增减或者移动；**
3. **读写 offset 族、scroll 族和 client 族属性的时候，浏览器为了获取这些值，需要进行回流操作；**
4. **调用 window.getComputedStyle 方法；**

一些常用且会导致回流的属性和方法：

1. clientWidth、clientHeight、clientTop、clientLeft
2. offsetWidth、offsetHeight、offsetTop、offsetLeft
3. scrollWidth、scrollHeight、scrollTop、scrollLeft
4. scrollIntoView()、scrollIntoViewIfNeeded()
5. getComputedStyle()
6. getBoundingClientRect()
7. scrollTo()

触发回流的时候，如果 DOM 结构发生改变，则重新渲染 DOM 树，然后将后面的流程全部走一遍；

![img](https://user-gold-cdn.xitu.io/2020/7/8/1732ec388e85bd2d?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

### 重绘

> 当页面中元素样式的改变并不影响它在文档流中的位置时，浏览器会将新样式赋予给元素并重新绘制它，这个过程称为重绘；

由于没有导致 DOM 几何属性的变化，因此元素的位置信息不需要更新，从而省去布局的过程，流程如下：

![img](https://user-gold-cdn.xitu.io/2020/7/8/1732ec3b24ec43c9?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

1. 跳过了布局树和建图层树,直接去绘制列表，然后在去分块,生成位图等一系列操作；
2. 回流必定会发生重绘，重绘不一定会引发回流；
3. 回流所需的成本比重绘高的多，改变深层次的节点很可能导父节点的一系列回流；

### 合成

> 合成就是更改了一个既不要布局也不要绘制的属性，那么渲染引擎会跳过布局和绘制，直接执行后续的合成操作；

比如使用 CSS 的 tansform 来实现动画效果，避免了回流跟重绘，直接在非主线程中执行合成动画操作；

显然这样子的效率更高，毕竟这个是在非主线程上合成的，没有占用主线程资源，另外也避开了布局和绘制两个子阶段，所以相对于重绘和重排，合成能大大提升绘制效率；

利用这一点好处：

1. 合成层的位图，会交由 GPU 合成，比 CPU 处理要快；
2. 当需要 repaint 时，只需要 repaint 本身，不会影响到其他的层；
3. 对于 transform 和 opacity 效果，不会触发 layout 和 paint；

提升合成层的最好方式是使用 CSS 的 will-change 属性；

### GPU加速

硬件加速（GPU加速）就是把容易触发重排重绘的元素单独触发渲染层，与那些“静态”元素隔离，让 GPU 分担更多的渲染工作；

1. 把那些一直发生大量重排重绘的元素提取出来，单独触发一个渲染层，那样这个元素就不会连累其它元素一起重绘；
2. 在合成的情况下，直接跳过布局和绘制流程，进入非主线程处理部分，即直接交给线程处理；
3. 充分发挥 GPU 的优势， 合成线程生成位图的过程中会调用线程池，并在其中使用 GPU 进行加速生成，而 GPU 是擅长处理位图数据的；
4. 没有占用主线程的资源，即使主线程卡住了，效果依然流畅展示；

```css
/* 给某个元素加上下面的样式触发渲染层 */
transform: translateZ(0);
backface-visibility: hidden;
```

### Event loop

1. 当 Event loop 执行完 Microtasks  后，会判断 document 是否需要更新，因为浏览器是 60Hz 的刷新率，每 16ms 才会更新一次；
2. 然后判断是否有 resize 或者 scroll ，有的话会去触发事件，所以 resize 和 scroll 事件也是至少 16ms 才会触发一次，并且自带节流功能；
3. 判断是否触发了 media query；
4. 更新动画并且发送事件；
5. 判断是否有全屏操作事件；
6. 执行 requestAnimationFrame 回调；
7. 执行 IntersectionObserver 回调，该方法用于判断元素是否可见，可以用于懒加载上，但是兼容性不好；
8. 更新界面；
9. 以上就是一帧中可能会做的事情：如果在一帧中有空闲时间，就会去执行 requestIdleCallback 回调；

### 优化

1. 使用 createDocumentFragment 进行批量的 DOM 操作；
2. 对于 resize、scroll 等进行防抖/节流处理；
3. 动画使用 transform 或者opacity 实现 GPU 加速，渲染引擎会为其单独实现一个图层，当这些变换发生时，仅仅只是利用合成线程去处理这些变换，而不牵扯到主线程，大大提高渲染效率；
4. 对于不支持will-change 属性的浏览器，使用一个3D transform属性来强制提升为合成 transform: translateZ(0)；
5. 使用 translate 替代 top；
6. 使用 visibility 替换 display: none ，因为前者只会引起重绘，后者会引发回流；
7. **把 DOM 离线后修改：**比如：先把 DOM 给 display:none，然后你修改100次，然后再把它显示出来；
8. 不要把 DOM 结点的属性值放在一个循环里当成循环里的变量；
9. 不要使用 table 布局，很小的一个小改动会造成整个 table 的重新布局；
10. 动画实现的速度的选择，动画速度越快，回流次数越多，也可以选择使用 requestAnimationFrame；
11. CSS 选择符从右往左匹配查找，避免 DOM 深度过深；
12. 将频繁运行的动画变为图层，图层能够阻止该节点回流影响别的元素。比如对于 video 标签，浏览器会自动将该节点变为图层；

## 输入URL到页面呈现

1. 用户输入：在当前页面即将替换成新的页面的时候，浏览器给了当前页面一次执行 beforeunload 事件的机会，允许在页面退出之前执行行一些操作；
2. DNS 解析：

   - 网络进程查找本地缓存是否缓存了该资源，如果缓存直接使用；
   - 如果没有在缓存中查找到资源，进入网络请求流程：浏览器缓存，hosts文件，本地dns服务器、找根服务器：找了根服务器后，根服务器会根据请求的域名，开始递归+迭代解析，得到查询结果；本地dns服务器，把最终的解析结果，返回给客户端；

3. 建立TCP连接；通过三次握手建立客户端和服务器之前的连接，数据传输，通过四次挥手来断开连接；
4. 准备渲染进程：Chrome 会为每个页面分配一个渲染进程，每打开一个新页面就会配套创建一个新的渲染进程；
5. 渲染阶段：文件解码成功后会开始渲染流程；

   - 根据 HTML  构建 DOM树，有 CSS 就构建 CSSOM 树；
   - 如果遇到 script 标签，会判断是否存在 async 或者 defer，async 会并行下载并执行 js，defer 会先下载文件，然后等待 HTML 解析完成后顺序执行；如果以上都没有，就会阻塞渲染流程直到 JS 执行完毕；
   - CSSOM 和 DOM 树构建完成后会开始生成 Render 树，这一步是确定页面元素的布局、样式等；
   - 在生成 Render 树的过程中，浏览器就开始调用 GPU 绘制，合成图层，将内容显示在屏幕上；


## prefetch

> Prefetch 是一个低优先级的资源提示，允许浏览器在后台（空闲时）获取将来可能用得到的资源，并且将他们存储在浏览器的缓存中;

一旦一个页面加载完毕就会开始下载其他的资源，然后当用户点击了一个带有 prefetch 的连接，它将可以立刻从缓存中加载内容；

### Link Prefetching

> link prefetching 允许浏览器获取资源并将他们存储在缓存中；

浏览器会寻找 HTML `<link>` 元素中的 prefetch 或者 HTTP 头中如下的 Link：

```javascript
HTML: <link rel="prefetch" href="/uploads/images/pic.png">
HTTP Header: Link: </uploads/images/pic.png>; rel=prefetch
```

### DNS Prefetching

> DNS prefetching 允许浏览器在用户浏览页面时在后台运行 DNS 的解析；

这样DNS 的解析在用户点击一个链接时已经完成，所以可以减少延迟；

```javascript
 <link rel="dns-prefetch" href="//cdn.domain.com">
```

### prerendering

Prerendering 和 prefetching 非常相似，它们都优化了可能导航到的下一页上的资源的加载，区别是 prerendering 在后台渲染了整个页面，整个页面所有的资源；

```javascript
<link rel="prerender" href="https://www.keycdn.com">
```

## 渲染进程

渲染进程的渲染线程有五种：

1. **GUI线程：**负责渲染浏览器页面，解析html和css，构建dom树、cssom树，构建渲染树和绘制页面，当页面重绘或者回流的时候该线程就会执行
2. **JS引擎线程：**负责解析js脚本及运行代码，会一直等待任务队列的任务到来再处理
3. **事件触发线程：**js引擎执行鼠标点击或者其他事件时，会将对应任务添加到事件触发线程等待js殷引擎处理
4. **定时器触发线程：**setTimeout和setinterval事件时等待计时完毕会加入js引擎的等待队列里
5. **异步http请求线程：**

