## 浏览器的主要组成部分

1. 用户界面：地址栏、前进/后退按钮、书签菜单等
2. 浏览器引擎：在用户界面和呈现引擎之间传送指令
3. 呈现引擎：负责显现请求的内容，如果请求的内容是HTML，它就是负责解析HTML和CSS的内容，并将解析后的内容显示在屏幕上
4. 网络：用于网络调用，比如HTTP请求
5. 用户界面后端：用于绘制基本的窗口小部件，比如组合框和窗口
6. Javascript解释器：用于解析和执行Javascript代码 
7. 数据存储：这是持久层；浏览器需要在硬盘上保存各种数据，例如Cookie

## 输入URL到页面呈现发生了什么

1. 构建请求：浏览器构建请求行信息，构建好后，浏览器准备发起网络请求

   ```
   GET / HTTP1.1
   GET是请求方法，路径就是根路径，HTTP协议版本1.1
   ```

2. 查找缓存：在真正发起网络请求之前，浏览器会先在浏览器缓存中查询是否有要请求的文件；先检查强缓存，如果命中直接使用，否则进入下一步

3. DNS解析：输入的是域名的话，需要根据域名去获取对应的ip地址；这个过程依赖一个服务系统，叫做DNS域名解析，从查找到获取到具体IP的过程叫做DNS解析；

   浏览器提供了DNS数据缓存功能；

   1. 首先查看是否有对应的域名缓存，有的话直接用缓存的IP访问

   2. 如果缓存中没有，则去查找hosts文件

   3. 如果hosts文件里没有找到想解析的域名，则将域名发往自己配置的dns服务器，也叫本地dns服务器

   4. 如果本地dns服务器有相应域名的记录，则返回记录

      > 电脑的dns服务器一般是各大运营商如电信联通提供的，或者像180.76.76.76，223.5.5.5，4个114等知名dns服务商提供的，本身缓存了大量的常见域名的ip，所以常见的网站，都是有记录的。不需要找根服务器。

   5. 如果电脑自己的服务器没有记录，会去找根服务器。根服务器全球只有13组，会去找其中之一,找了根服务器后，根服务器会根据请求的域名，返回对应的“顶级域名服务器”

      1. 如果请求的域名是[xxx.com](https://link.zhihu.com/?target=http%3A//xxx.com)，则返回负责com域的服务器
      2. 如果是[xxx.cn](https://link.zhihu.com/?target=http%3A//xxx.cn)，则发给负责cn域的服务器
      3. 如果是[xxx.ca](https://link.zhihu.com/?target=http%3A//xxx.ca)，则发给负责ca域的服务器

   6. 顶级域服务器收到请求，会返回二级域服务器的地址：比如一个网址是`www.xxx.edu.cn`，则顶级域名服务器再转发给负责`.edu.cn`域的二级服务器

   7. 以此类推，最终会发到负责锁查询域名的，最精确的那台dns，可以得到查询结果

   8. 本地dns服务器，把最终的解析结果，返回给客户端

4. 建立TCP连接

   - 通过三次握手建立客户端和服务器之前的连接
   - 进行数据传输
   - 通过四次挥手来断开连接

5. 发送HTTP请求

6. 渲染阶段 

## CSS加载会造成阻塞吗

> CSS不会阻塞DOM解析，但是会阻塞DOM渲染
>
> CSS会阻塞JS执行，并不会阻塞JS文件下载

- DOM和CSSOM是并行构建的，所以**CSS 加载不会阻塞 DOM 的解析**
- 由于render Tree是依赖DOM Tree和 CSSOM Tree的，所以它必须等到两者都加载完毕之后，完成相应的构建才开始渲染，所以**CSS加载会阻塞DOM渲染**
- 由于JS是可操纵DOM和CSS样式的，如果在修改这些元素属性同时渲染界面，那么渲染后线程前后获得的元素数据就可能不一致的，因此为了防止渲染出现 不可预期的结果，浏览器设置**GUI 渲染线程与 JavaScript 引擎为互斥**的关系
- 有时候JS需要等到CSS的下载：如果脚本的内容是获取元素的样式，宽高等CSS的属性，浏览器是需要计算的，也就是依赖于CSS。浏览器也无法感知脚本内容到底是什么，为避免样式获取，因而只好等前面所有的样式下载完后，再执行JS。
- JS文件下载和CSS文件下载是并行的，有时候CSS文件很大，所以JS需要等待。因此,样式表会在后面的 js 执行前先加载执行完毕,所以**css 会阻塞后面 js 的执行**。

CSSOM作用：

1. 提供给javascript操作样式表的能力
2. 为布局树的合成提供基础的样式信息
3. CSSOM体现在DOM中就是document.styleSheets

## 为什么JS会阻塞页面加载

> 因为JS阻塞DOM解析，也就会阻塞页面；

- 由于 JavaScript 是可操纵 DOM 的,如果在修改这些元素属性同时渲染界面（即 JavaScript 线程和 UI 线程同时运行）,那么渲染线程前后获得的元素数据就可能不一致了
- 当 JavaScript 引擎执行时 GUI 线程会被挂起,GUI 更新会被保存在一个队列中等到引擎线程空闲时立即被执行
- 当浏览器在执行 JavaScript 程序的时候,GUI 渲染线程会被保存在一个队列中,直到 JS 程序执行完成,才会接着执行
- 因此如果 JS 执行的时间过长,这样就会造成页面的渲染不连贯,导致页面渲染加载阻塞的感觉
- 如果 JavaScript 文件中没有操作 DOM 相关代码，就可以将该 JavaScript 脚本设置为异步加载，通过 async 或 defer 来标记代码

## defer 和 async 的区别 

- 两者都是异步去加载外部JS文件，不会阻塞DOM解析
- Async是在外部JS加载完成后，浏览器空闲时，Load事件触发前执行，标记为async的脚本并不保证按照指定他们的先后顺序执行，该属性对于内联脚本无作用 (即没有src属性的脚本）
- defer是在JS加载完成后，整个文档解析完成后，触发 DOMContentLoaded事件前执行，该属性对于内联脚本无作用 (即没有src属性的脚本）

## DOMContentLoaded 与 load

- DOMContentLoaded事件触发时：仅当DOM解析完成后，不包括样式表、图片等资源
- onload事件触发时，页面上所有的Dom,样式，脚本，图片等资源已经加载完毕

> 在Jquery中，（document）.read（callback）监听的就是DOMContentLoaded事件
>
> （document）.load（callback）监听的就是load事件

#### 与async和defer区别

> 带async的脚本一定会在load事件之前执行，可能会在DOMContentLoaded事件之前或之后执行；

- 情况1：HTML还没有被解析完时，async脚本已经加载完了，那么HTML停止解析，去执行脚本，脚本执行完毕后触发DOMContentLoaded事件
- 情况2： HTML 解析完了之后，async脚本才加载完，然后再执行脚本，那么在HTML解析完毕、async脚本还没加载完的时候就触发DOMContentLoaded事件

> 如果script标签中包含defer，那么这一块脚本不会影响HTML文档的解析，而是等到HTML解析完成后才会执行；而DOMContentLoaded只有在defer脚本执行结束后才会被触发。

- 情况1：HTML还没解析完成时，defer脚本已经加载完毕，那么defer脚本将等待HTML解析完成后再执行。defer脚本执行完毕后触发DOMContentLoaded事件
- 情况2：HTML解析完成时，defer脚本还没加载完毕，那么defer脚本继续加载，加载完成后直接执行，执行完毕后触发DOMContentLoaded事件

## 为什么CSS动画比JavaScript高效

如果非要去操作JS实现动画的话，有哪些优化的手段呢：

- 使用`createDocumentFragment`进行批量的 DOM 操作
- 对于 resize、scroll 等进行防抖/节流处理。
- rAF优化等等

## requestAnimationFrame（rAF）

> window.requestAnimationFrame() 方法告诉浏览器您希望执行动画并请求浏览器在下一次重绘之前调用指定的函数来更新动画。该方法使用一个回调函数作为参数，这个回调函数会在浏览器重绘之前调用。

如果 JavaScript 方法需要绘制或者直接改变属性,选择 requestAnimationFrame，只要涉及到重新计算元素位置，就可以使用它。

传统的 javascript 动画是通过定时器 setTimeout 或者 setInterval 实现的。但是定时器动画一直存在两个问题：

1. 动画的循环时间间隔不好确定: 设置长了动画显得不够平滑流畅，设置短了浏览器的重绘频率会达到瓶颈，推荐的最佳循环间隔是 17ms 大多数电脑的显示器刷新频率是 60Hz，1000ms/60）；
2. 定时器第二个时间参数只是指定了多久后将动画任务添加到浏览器的UI线程队列中，如果UI线程处于忙碌状态，那么动画不会立刻执行;

为了解决这些问题，H5 中加入了 requestAnimationFrame 以及 requestIdleCallback

- requestAnimationFrame 会把每一帧中的所有 DOM 操作集中起来，在一次重绘或回流中就完成，并且重绘或回流的时间间隔紧紧跟随浏览器的刷新频率；
- 在隐藏或不可见的元素中，requestAnimationFrame 将不会进行重绘或回流，这当然就意味着更少的 CPU、GPU 和内存使用量
- requestAnimationFrame 是由浏览器专门为动画提供的 API，在运行时浏览器会自动优化方法的调用，并且如果页面不是激活状态下的话，动画会自动暂停，有效节省了 CPU 开销

#### 优点

- rAF(requestAnimationFrame) 最大的优势是由系统来决定回调函数的执行时机：系统每次绘制之前会主动调用 rAF 中的回调函数，如果系统绘制率是 60Hz，那么回调函数就每16.7ms 被执行一次，如果绘制频率是75Hz，那么这个间隔时间就变成了 1000/75=13.3ms
- 当页面处理未激活的状态时，该页面的屏幕绘制任务也会被系统暂停，因此跟着系统步伐走的rAF也会停止渲染，当页面被激活时，动画就从上次停留的地方继续执行，有效节省了 CPU 开销。
- 动画保持 60fps（每一帧 16 ms），浏览器内部决定渲染的最佳时机
- 简洁标准的 API，后期维护成本低

#### 缺点

- 浏览器标签未激活时，一切都不会执行
- 尽管所有的现代浏览器都支持rAF，IE9，Opera Mini 和 老的 Android 还是需要打补丁
- Node.js 不支持，无法在服务器端用于文件系统事件


## V8垃圾回收机制

JS 的垃圾回收机制的基本原理是：

- 找出那些不再继续使用的变量，然后释放其占用的内存，垃圾收集器会按照固定的时间间隔周期性地执行这一操作。
- V8 的垃圾回收策略主要基于分代式垃圾回收机制，在 V8 中，将内存分为新生代和老生代，新生代的对象为存活时间较短的对象，老生代的对象为存活事件较长或常驻内存的对象。
- V8 堆的整体大小等于新生代所用内存空间加上老生代的内存空间，而只能在启动时指定，意味着运行时无法自动扩充，如果超过了极限值，就会引起进程出错。

#### Scavenge 算法

- 在分代的基础上，新生代的对象主要通过 Scavenge 算法进行垃圾回收，在 Scavenge 具体实现中，主要采用了一种复制的方式的方法—— Cheney 算法。
- Cheney 算法将堆内存一分为二，一个处于使用状态的空间叫 From 空间，一个处于闲置状态的空间称为 To 空间。分配对象时，先是在 From 空间中进行分配。
- 当开始进行垃圾回收时，会检查 From 空间中的存活对象，将其复制到 To 空间中，而非存活对象占用的空间将会被释放。完成复制后，From 空间和 To 空间的角色发生对换。
- 当一个对象经过多次复制后依然存活，他将会被认为是生命周期较长的对象，随后会被移动到老生代中，采用新的算法进行管理。
- 还有一种情况是，如果复制一个对象到 To 空间时，To 空间占用超过了 25%，则这个对象会被直接晋升到老生代空间中。

#### 标记-清除 / 标记-整理算法

- 对于老生代中的对象，主要采用标记-清除和标记-整理算法。标记-清除 和前文提到的标记一样，与 Scavenge 算法相比，标记清除不会将内存空间划为两半，标记清除在标记阶段会标记活着的对象，而在内存回收阶段，它会清除没有被标记的对象。
- 而标记整理是为了解决标记清除后留下的内存碎片问题。

#### 增量标记（Incremental Marking）算法

- 前面的三种算法，都需要将正在执行的 JavaScript 应用逻辑暂停下来，待垃圾回收完毕后再恢复。这种行为叫作“全停顿”（stop-the-world）。
- 在 V8 新生代的分代回收中，只收集新生代，而新生代通常配置较小，且存活对象较少，所以全停顿的影响不大，而老生代就相反了。
- 为了降低全部老生代全堆垃圾回收带来的停顿时间，V8将标记过程分为一个个的子标记过程，同时让垃圾回收标记和JS应用逻辑交替进行，直到标记阶段完成。
- 过增量标记改进后，垃圾回收的最大停顿时间可以减少到原来的 1/6 左右。

#### 内存泄露

> 内存泄漏（Memory Leak）是指程序中己动态分配的堆内存由于某种原因程序未释放或无法释放，造成系统内存的浪费，导致程序运行速度减慢甚至系统崩溃等严重后果。

内存泄漏的常见场景：

1. 缓存:存在内存中数据一直没有被清掉；
2. 作用域未释放（闭包）；
3. 无效的 DOM 引用；
4. 没必要的全局变量；
5. 定时器未清除(React 中的合成事件，还有原生事件的绑定区别)
6. 事件监听为清空；

## 浏览器的缓存实现

### preload、prefetch、dns-prefetch

> 能显著提升页面性能的方法 ——资源提示与指令
>
> 它们带来的好处包括允许前端开发人员来优化资源的加载，减少往返路径并且在浏览页面时可以更快的加载到资源。

#### preload

> Preload 是一个新的控制特定资源如何被加载的新的 Web 标准，这个指令可以在 `<link>` 中使用，比如 `<link rel="preload">`。一般来说，最好使用 preload 来加载你最重要的资源，比如图像，CSS，JavaScript 和字体文件；
>
> 不要与浏览器预加载混淆，浏览器预加载只预先加载在HTML中声明的资源。preload 指令事实上克服了这个限制并且允许预加载在 CSS 和JavaScript 中定义的资源，并允许决定何时应用每个资源；
>
>  preload 并不会阻塞 window 的 onload 事件；

使用 Preload 的好处：

1. 允许浏览器来设定资源加载的优先级因此可以允许前端开发者来优化指定资源的加载；

2. 赋予浏览器决定资源类型的能力，因此它能分辨这个资源在以后是否可以重复利用；

3. 浏览器可以通过指定 as 属性来决定这个请求是否符合 content security policy；

   ```javascript
   <link rel="preload" href="/css/mystyles.css" as="style">
   ```

4. 浏览器可以基于资源的类型（比如 image/webp）来发送适当的 accept 头；

5. 如果预加载需要 CORS 的跨域请求，那么也要加上 crossorigin 的属性。

   ```javascript
   <link rel="preload" href="https://example.com/fonts/font.woff" as="font" crossorigin>
   ```

#### prefetch

> Prefetch 是一个低优先级的资源提示，允许浏览器在后台（空闲时）获取将来可能用得到的资源，并且将他们存储在浏览器的缓存中;
>
> 一旦一个页面加载完毕就会开始下载其他的资源，然后当用户点击了一个带有 prefetched 的连接，它将可以立刻从缓存中加载内容；

有三种不同的 prefetch 的类型，link，DNS 和 prerendering：

1. Link Prefetching

   link prefetching 假设用户将请求它们，所以允许浏览器获取资源并将他们存储在缓存中。浏览器会寻找 HTML `<link>` 元素中的 prefetch 或者 HTTP 头中如下的 Link：

   ```javascript
   HTML: <link rel="prefetch" href="/uploads/images/pic.png">
   HTTP Header: Link: </uploads/images/pic.png>; rel=prefetch
   ```

2. DNS Prefetching

   DNS prefetching 允许浏览器在用户浏览页面时在后台运行 DNS 的解析。这样DNS 的解析在用户点击一个链接时已经完成，所以可以减少延迟。

   ```javascript
    <link rel="dns-prefetch" href="//cdn.domain.com">
   ```

3. prerendering

   Prerendering 和 prefetching 非常相似，它们都优化了可能导航到的下一页上的资源的加载，区别是 prerendering 在后台渲染了整个页面，整个页面所有的资源;

   ```javascript
   <link rel="prerender" href="https://www.keycdn.com">
   ```

### servece-worker, PWA 渐进式web应用

### localstorage、sessionstorage、cookie、session

### 浏览器缓存的实现机制的实现

![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/595c27f811fc4e14bacee79d929a45ce~tplv-k3u1fbpfcp-zoom-1.image?imageslim)