## 渲染机制

### 构建DOM树

> 这个过程主要工作就是将HTML内容转换为浏览器DOM树结构
>
> 字节 -> 字符 -> 令牌 -> 节点 -> 对象模型（DOM）

数据转换流程：

![img](https://user-gold-cdn.xitu.io/2020/7/8/1732ebfbe591dab1?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

### 样式计算​

- 格式化样式表：我们拿到的也就是0，1字节流数据，浏览器无法直接去识别的，所以渲染引擎收到CSS文本数据后，会执行一个操作，转换为浏览器可以理解的结构--styleSheets
- 标准化样式表：有些时候，我们写CSS 样式的时候，会写 font-size:2em;color:red;font-weight:bold,像这些数值并不容易被渲染引擎所理解，因此需要在计算样式之前将它们标准化，如em->px,red->rgba(255,0,0,0),bold->700等等。
- 计算每个DOM节点的具体样式：这个阶段，完成了DOM节点中每个元素的具体样式，计算过程中要遵循CSS的继承和层叠两条规则，最终输出的内容是每个节点DOM的样式，被保存在ComputedStyle中,也就是可以通过JS来获取计算后的样式

##### 计算规则

- 继承：每个子节点会默认去继承父节点的样式，如果父节点中找不到，就会采用浏览器默认的样式，也叫UserAgent样式。
- 层叠：样式层叠，是CSS一个基本特征，它定义如何合并来自多个源的属性值的算法。

### 生成布局树

1. 创建布局树：在DOM上不可见的元素，head元素，meta元素，以及使用display：none属性的元素，最后都不会出现在布局树上，所以浏览器布局系统需要额外构建一棵只包含可见元素的布局树
2. 布局构建过程：
   1. 遍历DOM树可见节点，并把这些节点加到布局树中
   2. 对于不可见的节点，head,meta标签等都会被忽略。对于body.p.span 这个元素，它的属性包含display:none,所以这个元素没有被包含进布局树。

![img](https://user-gold-cdn.xitu.io/2020/7/8/1732ec0e12a95ce8?imageslim)

3. 布局计算：就是要计算布局树节点的坐标位置

一图概括上面三个阶段：

![img](https://user-gold-cdn.xitu.io/2020/7/8/1732ec5b58492217?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

### 分层

浏览器在构建完布局树后，还需要进行一系列操作，考虑到一些复杂的场景，比如一些些复杂的 3D 变换、页面滚动，或者使用 z-indexing 做 z 轴排序等，还有比如是含有层叠上下文如何控制显示和隐藏等情况。

- 生成图层树（Layer Tree）
- 拥有层叠上下文属性的元素会被提升为单独的一层
- 需要裁剪的地方也会创建图层
- 图层绘制

什么情况下，渲染引擎会为特定的节点创建新图层呢？

##### 显式合成

1. 拥有层叠上下文的节点：是有一些特定的CSS属性创建的：
   1. HTML根元素本身就具有层叠上下文
   2. 普通元素设置position不为static并且设置了z-index属性，会产生层叠上下文
   3. 元素的opacity值不是1
   4. 元素的transform值不是none
   5. 元素的filter值不是none
   6. 元素的isolation值是isolate
   7. will-change指定的属性值为上面任意一个
2. 需要剪裁的地方：比如一个标签很小，50*50像素，你在里面放了非常多的文字，那么超出的文字部分就需要被剪裁。当然如果出现了滚动条，那么滚动条也会被单独提升为一个图层

##### 隐式合成

就是z-index比较低的节点会提升为一个单独的图层，那么层叠等级比它高的节点都会成为一个独立的图层

缺点：如果在一个大型的项目中，一个z-index比较低的节点被提升为单独的图层后，叠在它上面的元素统统都会提升为单独的图层，我们知道，上千个图层，会增大内存的压力，有时候会让页面崩溃。这就是层爆炸

### 绘制

> 图层的绘制每次都会把一个复杂的图层拆分为很小的绘制指令，然后再按照这些指令的顺序组成一个绘制列表；

类似于下图：

### ![img](https://user-gold-cdn.xitu.io/2020/7/8/1732ec5057d218c2?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)分块

- 接下来就要开始绘制了，实际上在渲染进程中绘制操作是由专门的线程来完成的，叫合成线程

- 绘制列表准备好了之后，渲染进程的主线程会给合成线程发送commit消息，把绘制列表提交给合成线程

- 合成线程会将图层划分为图块，这些块的大小一般不会特别大，通常是 256 * 256 或者 512 * 512 这个规格。这样可以大大加速页面的首屏展示

- 首屏渲染加速可以这么理解：

  > 因为后面图块（非视口内的图块）数据要进入 GPU 内存，考虑到浏览器内存上传到 GPU 内存的操作比较慢，即使是绘制一部分图块，也可能会耗费大量时间。针对这个问题，Chrome 采用了一个策略: 在首次合成图块时只采用一个低分辨率的图片，这样首屏展示的时候只是展示出低分辨率的图片，这个时候继续进行合成操作，当正常的图块内容绘制完毕后，会将当前低分辨率的图块内容替换。这也是 Chrome 底层优化首屏加载速度的一个手段。

### 光栅化

接着上面的步骤，有了图块之后，合成线程会按照视口附近的图块来优先生成位图，实际生成位图的操作是由栅格化来执行的。所谓栅格化，是指将图块转换为位图

- 图块是栅格化执行的最小单位
- 渲染进程专门维护了一个栅格化线程池，专门负责把图块转换为位图数据
- 合成线程会选择视口附近的图块，把它交给栅格化线程池生成位图
- 生成位图的过程实际上都会使用GPU进行加速，生成的位图最后发送给合成线程

通常，栅格化过程都会使用 GPU 来加速生成，使用 GPU 生成位图的过程叫快速栅格化，或者 GPU 栅格化，生成的位图被保存在 GPU 内存中。

### 合成和显示

栅格化操作完成 之后，合成线程会生成 一个绘制指令，并发送给浏览器进程，浏览器进程中的viz组件接收到这个命令，把页面内容绘制到内存，也就是生成了页面，然后把这部分内存发送给显卡

对显示器显示图像的原理解释:

> 无论是 PC 显示器还是手机屏幕，都有一个固定的刷新频率，一般是 60 HZ，即 60 帧，也就是一秒更新 60 张图片，一张图片停留的时间约为 16.7 ms。而每次更新的图片都来自显卡的前缓冲区。而显卡接收到浏览器进程传来的页面后，会合成相应的图像，并将图像保存到后缓冲区，然后系统自动将前缓冲区和后缓冲区对换位置，如此循环更新。

![img](https://user-gold-cdn.xitu.io/2020/7/8/1732ec3159bd120b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

我们把上面整个的渲染流水线，用一张图片更直观的表示

![img](https://user-gold-cdn.xitu.io/2020/7/8/1732ec3500972dcc?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

## 重排-重绘-合成

#### 回流

> 回流触发的条件就是：对 DOM结构的修改引发DOM几何尺寸变化的时候，另外一个叫法是重排；

有以下的操作会触发回流：

有以下的操作会触发回流：

1. 一个DOM元素的几何属性变化：常见的几何属性有width、height、padding、margin、left、top、border等
2. 使DOM结点发生增减或者移动
3. 读写 offset族、scroll族和client族属性的时候，浏览器为了获取这些值，需要进行回流操作
4. 调用 window.getComputedStyle 方法

一些常用且会导致回流的属性和方法：

- clientWidth、clientHeight、clientTop、clientLeft
- offsetWidth、offsetHeight、offsetTop、offsetLeft
- scrollWidth、scrollHeight、scrollTop、scrollLeft
- scrollIntoView()、scrollIntoViewIfNeeded()
- getComputedStyle()
- getBoundingClientRect()
- scrollTo()

依照上面的渲染流水线，触发回流的时候，如果 DOM 结构发生改变，则重新渲染 DOM 树，然后将后面的流程(包括主线程之外的任务)全部走一遍。

![img](https://user-gold-cdn.xitu.io/2020/7/8/1732ec388e85bd2d?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

#### 重绘

> 当页面中元素样式的改变并不影响它在文档流中的位置时，例如color等，浏览器会将新样式赋予给元素并重新绘制它，这个过程称为重绘

由于没有导致 DOM 几何属性的变化，因此元素的位置信息不需要更新，从而省去布局的过程，流程如下：

![img](https://user-gold-cdn.xitu.io/2020/7/8/1732ec3b24ec43c9?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

跳过了布局树和建图层树,直接去绘制列表，然后在去分块,生成位图等一系列操作。

回流必定会发生重绘，重绘不一定会引发回流；

回流所需的成本比重绘高的多，改变深层次的节点很可能导父节点的一系列回流

#### 合成

> 就是更改了一个既不要布局也不要绘制的属性，那么渲染引擎会跳过布局和绘制，直接执行后续的合成操作，这个过程就叫合成

举个例子：比如使用CSS的transform来实现动画效果，避免了回流跟重绘，直接在非主线程中执行合成动画操作。显然这样子的效率更高，毕竟这个是在非主线程上合成的，没有占用主线程资源，另外也避开了布局和绘制两个子阶段，所以相对于重绘和重排，合成能大大提升绘制效率

利用这一点好处：

- 合成层的位图，会交由 GPU 合成，比 CPU 处理要快
- 当需要 repaint 时，只需要 repaint 本身，不会影响到其他的层
- 对于 transform 和 opacity 效果，不会触发 layout 和 paint

提升合成层的最好方式是使用 CSS 的 will-change 属性

#### GPU加速原因

> 比如利用 CSS3 的transform、opacity、filter这些属性就可以实现合成的效果，这就是GPU加速

- 在合成的情况下，直接跳过布局和绘制流程，进入非主线程处理部分，即直接交给线程处理
- 充分发挥GPU的优势， 合成线程生成位图的过程中会调用线程池，并在其中使用GPU进行加速生成，而GPU 是擅长处理位图数据的。
- 没有占用主线程的资源，即使主线程卡住了，效果依然流畅展示

#### 重绘和回流和 Event loop有关

1. 当Event loop执行完Microtasks  后，会判断 document 是否需要更新。因为浏览器是 60Hz 的刷新率，每 16ms 才会更新一次。
2. 然后判断是否有 `resize` 或者 `scroll` ，有的话会去触发事件，所以 `resize` 和 `scroll` 事件也是至少 16ms 才会触发一次，并且自带节流功能。
3. 判断是否触发了 media query
4. 更新动画并且发送事件
5. 判断是否有全屏操作事件
6. 执行 `requestAnimationFrame` 回调
7. 执行 `IntersectionObserver` 回调，该方法用于判断元素是否可见，可以用于懒加载上，但是兼容性不好
8. 更新界面
9. 以上就是一帧中可能会做的事情。如果在一帧中有空闲时间，就会去执行 `requestIdleCallback` 回调。

#### 实践意义

- 使用`createDocumentFragment`进行批量的 DOM 操作
- 对于 resize、scroll 等进行防抖/节流处理
- 动画使用transform或者opacity实现【GPU加速】
- 将元素的will-change 设置为 opacity、transform、top、left、bottom、right 。这样子渲染引擎会为其单独实现一个图层，当这些变换发生时，仅仅只是利用合成线程去处理这些变换，而不牵扯到主线程，大大提高渲染效率。
- 对于不支持will-change 属性的浏览器，使用一个3D transform属性来强制提升为合成 `transform: translateZ(0);`


- 使用 `translate` 替代 `top`
- 使用 `visibility` 替换 `display: none` ，因为前者只会引起重绘，后者会引发回流（改变了布局）
- 把 DOM 离线后修改，比如：先把 DOM 给 `display:none` (有一次 Reflow)，然后你修改100次，然后再把它显示出来
- 不要把 DOM 结点的属性值放在一个循环里当成循环里的变量
- 不要使用 table 布局，可能很小的一个小改动会造成整个 table 的重新布局
- 动画实现的速度的选择，动画速度越快，回流次数越多，也可以选择使用 `requestAnimationFrame`
- CSS 选择符从右往左匹配查找，避免 DOM 深度过深
- 将频繁运行的动画变为图层，图层能够阻止该节点回流影响别的元素。比如对于 `video` 标签，浏览器会自动将该节点变为图层。