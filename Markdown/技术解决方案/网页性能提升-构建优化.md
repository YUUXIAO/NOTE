## 分析依赖关系

借助 webpack-bundle-analyzer 将打包后的内容展示为方便交互的树状图，可以直观的看到哪些比较大的模块，然后做针对性优化；

```javascript
npm install --save-dev webpack-bundle-analyzer

const BundleAnalyzerPlugin = require('webpack-bundle-analyzer').BundleAnalyzerPlugin;
module.exports = {
  plugins: [
    new BundleAnalyzerPlugin()
  ]
}
```

## CDN 引入

> CDN 的工作原理是将源站的资源缓存到位于全球各地的 CDN 节点上，用户请求资源时，就近返回节点上缓存的资源，而不需要每个用户的请求都回您的源站获取，避免网络拥塞、缓解源站压力，保证用户访问资源的速度和体验；

将体积较大的第三方依赖单独拆出来放到 CDN 上，这样这个依赖既不会占用打包资源，也不会影响最终包体积；

如果一个依赖有直接打包压缩好的单文件 CDN 资源，就可以直接使用；

### externals

> externals 配置选项提供了「从输出的 bundle 中排除依赖」的方法，相反，所创建的 bundle 依赖于那些存在于用户环境中的依赖；

如果我们想引用一个库，但是又不想让 webpack 打包，并且又不影响在程序中以 import、require 或者 window/global 全局等方式进行使用，那就可以通过配置 externals；

首先将 CDN 引入的依赖加入到 externals 中；

![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/693f0a72f383455baed6949136e90287~tplv-k3u1fbpfcp-zoom-1.image)

然后借助 html-webpack-plugin 将 CDN 文件打入 html；

![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/73291870db304dcc80cd49c7d434fa9d~tplv-k3u1fbpfcp-zoom-1.image)

## 拆vendor

某些场景下， 一个第三方依赖可能拆成了多个子依赖，或者没有提供可直接通过 CDN 引入的文件，就无法通过配置一个 CDN 文件来引入它了；

需要自己去 webpack 设置一些规则，将想拆出来的依赖单独打包一个 vendor；

![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/42584ebdea5b4a4faa4ea3e1b9c29a01~tplv-k3u1fbpfcp-zoom-1.image)

## Dynamic import

ES Module 目前也支持了 Dynamic import 的用法，动态的 import 会返回一个 promise ，可以等待模块加载完成后再去做一些事情，而不用在页面初始化就加载它；

```javascript
<script type="module">
  const moduleSpecifier = './utils.js';
  import(moduleSpecifier)
    .then((module) => {
      module.default();
      // → logs 'Hi from the default export!'
      module.doStuff();
      // → logs 'Doing stuff…'
    });
</script>

<script type="module">
  (async () => {
    const moduleSpecifier = './utils.js';
    const module = await import(moduleSpecifier)
    module.default();
    // → logs 'Hi from the default export!'
    module.doStuff();
    // → logs 'Doing stuff…'
  })();
</script>
```

将 vendor 拆分后，依赖仍然会在首屏被加载，如果依赖不在首屏使用，仍然会造成网络资源的浪费，并阻塞页面渲染，对于没必要在首屏进行加载的依赖，可以采用动态 import 的方式；

首先在 vendor 中将其拆出来；

![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b9e7e12062ab4eb186cef1ed069e13e9~tplv-k3u1fbpfcp-zoom-1.image)

使用时，将 import 逻辑由首屏改到运行时异步加载；

![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1e23c9ac9d164a0abdb57c2239c3ffbb~tplv-k3u1fbpfcp-zoom-1.image)

## 路由懒加载

对于每个路由都使用懒加载的方式引入，则每个模块都会被单独打为一个 js，首屏只会加载当前模块引入的 js；

不过 路由懒加载 也有一个很明显的弊端，就是每个模块的资源是只有加载这个模块的时候才回去下载的，所以在切换模块的时候可能会有一小段白屏或 loading 效果，这个要结合业务自身的情况综合判断要不要使用；

## 语言包优化

在某些场景下，语言包会占用整个包体积的非常大一部分，实际上库本身的逻辑不会很大，比如 moment；

 ContextReplacementPlugin 会告诉 webpack 会使用到哪个本地文件；

```javascript
plugins: [
    new webpack.ContextReplacementPlugin(/moment[/\\]locale$/, /zh-cn/),
  ]
```

