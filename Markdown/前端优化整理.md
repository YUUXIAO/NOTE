## 图片优化

### 图片压缩工具

#### 压缩 png

- node-pngquant-native 插件
- 跨平台，压缩比高，压缩 png24 非常好
- 说明文档：<https://www.npmjs.com/package/node-pngquant-native>

#### 压缩 jpg

- jpegtran 插件
- 跨平台，有Linux、mac、windows 的解决方案
- 说明文档：<https://www.npmjs.com/package/jpegtran>

#### 压缩 gif

- Gifsicle ： 通过改变每帧比例，减少 gif 文件大小，同时可以使用透明来达到更小的文件大小，目前公认的解决方案
- 说明文档：<https://www.npmjs.com/package/gifsicle>
- 使用方式 ：
  1. 优化级别设置不小于2，1的话基本不压缩；gifsicle --optimize=3 -o out.gif in.gif
  2. 将透明部分截去；gifsicle --optimize=3 --crop-transparency -o out.gif in.gif

### 图片尺寸随网络环境变化

不同网络环境（wifi / 4G / 3G）下，加载不同尺寸和像素的图片，通过在图片URL后缀加不同的参数改变；

### 响应式图片

1. Javascript 绑定事件检测窗口大小

2. CSS 媒体查询

   ```javascript
   @media screen and(max-width:640px){
     .image{
        width: 640px;
     }
   }
   ```

3. img 标签属性

   ```javascript
   <img srcset="img-320w.jpg,img-640w.jpg 2x,img-960w.jpg 3x" src="img-960w.jpg">
   // x描述符：表示图像的设备像素比
   ```

### 逐步加载图像

1. 使用统一占位符
2. 使用 LQIP
   - 低质量图像占位符（Low Quality Image Placeholders）
   - 安装：npm install lqip
   - 源码文档：<https://github.com/zouhir/lqip-loader>
3. 使用 SQIP
   - 基于 SVG 的图像占位符（SVG Quality Image Placeholders）
   - 安装：npm install sqip
   - 使用文档：<https://www.npmjs.com/package/sqip-loader/v/1.0.0>

## HTML 优化

### 精简 HTML 代码

1. 减少 HTML 的嵌套
2. 减少 DOM 节点数
3. 减少无语义代码（比如：<div class="clear"></div> 消除浮动）
4. 删除 http 或者 https ，如果URL的协议头和当前页面协议头一致，或者此URL在多个协议头都是可用的，可以考虑删除协议头
5. 删除多余的空格、换行符、缩进和不必要的注释
6. 省略冗余标签和属性
7. 使用相对路径的URL

### 文件放在合适的位置

1. CSS 样式文件链接尽量放在页面头部

   - CSS 加载不会阻塞 DOM tree 解析，但是会阻塞 DOM tree渲染，也会阻塞后面 JS 执行；


   - 任何 body 元素之前，可以确保在文档部分中解析了解析了所有 CSS 样式（内联和外联），从而减少了浏览器必须重排文档的次数；


   - 如果放置页面底部，就要等待最后 一个CSS文件下载完成，此时会出现“白屏”，影响用户体验；

2. JS 引用放在 HTML 底部

   - 防止 JS 的加载、解析、执行对阻塞页面后续元素的正常渲染；

### 增强用户体验

1. 设置 favicon.ico
2. 增加首屏必要的 CSS 和 JS
   - 页面如果需要等待所依赖的 JS 和 CSS 加载完成才显示，刚在渲染过程中页面一直显示空白，建议增加首屏必要的 CSS 和 JS ，比如页面框架背景图片或者 Loading图标，内联在 HTML 页面中；

## CSS 优化

### 精简 CSS 代码

1. 使用缩写语句；
2. 删除不必要的零；
3. 删除不必要的单位，如 0px；
4. 删除过多的分号；
5. 删除空格和注释；

### 提升 CSS 渲染性能

1. 谨慎使用 expensive 属性：如 :nth-child；position；box-shadow；filter 等；
2. 尽量减少样式层级数：如 div ul li span i｛color：red｝；
3. 尽量避免使用占用过多 CPU 和内存的属性：如 text-indent：-99999px；
4. 尽量避免使用消耗电量大的属性：如  3d transform、transitions、opacity；

### 合理使用 CSS 选择器

1. 尽量避免使用 CSS 表达式；
2. 尽量避免使用通配选择器，如：body > a｛color：red｝;
3. 尽量避免类正则的属性选择器；

### 提升 CSS 文件加载性能

1. 尽量减少@import 方式的引用 ：因为@import 是将其放置在页面底部渲染；
2. 使用外链的 CSS ，会采用缓存机制

### 合理使用 Web Fonts

1. 将字体部署在 CDN 上；
2. 将字段以 base64 形式保存在 CSS 中并通过 localStorage 进行缓存；

### CSS 动画优化

1. 尽量避免同时动画；
2. 延迟动画初始化；
3. 结合 SVG；

## JS 优化

### 原则

1. 当需要时才优化；
2. 考虑可维护性；

### 提升 JS 文件加载性能

1. 加载元素的顺序 CSS 文件放在 <head> 里，JS 文件放在  <body> 里；

### JS 变量和函数优化

1. 尽量使用 ID 选择器；
2. 尽量避免使用 eval；
3. JS 函数尽可能保持简洁；
4. 使用事件节流函数；
5. 使用事件委托；

### JS 动画优化

1. 避免添加大量的 JS 动画；
2. 尽量使用 CSS3 动画；
3. 尽量使用 Canvas 动画；
4. 合理使用 requestAnimationFrame 动画代替 setTimeout、setInterval： requestAnimationFrame 可以在正确的时间进行渲染，setTimeout（callback）和 setInterval（callback）无法保证 callback回调函数的执行时机；

### 合理使用缓存

1. 合理缓存 DOM 对象；
2. 缓存列表长度；
3. 使用可缓存的 Ajax；

### JS 缓存优化

1. Cookie；
2. sessionStorage；
3. IndexDB；
4. LocalStorage；

### JS模块化加载方案

1. CommonJS
   - 旨在web浏览器之外为Javascript建立模块生态系统；
   - Node.js模块化方案受CommonJS
2. AMD（Asynchronous Module Definition）（异步模块定义）规范
   - RequireJS模块化加载器：基于AMD API实现；
3. CMD（Common Module Definition）（通用模块定义）规范
   - SeaJS模块化加载器：遵循CMD API编写；
4. ES6 Import

