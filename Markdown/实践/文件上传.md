## 方式

### 普通表单上传

首先构建文件上传的表单，并指定表单的提交内容类型为 enctype="multipart/form-data"，表明表单需要上传二进制数据；

```html
<form action="/index.php" method="POST" enctype="multipart/form-data">
  <input type="file" name="myfile">
  <input type="submit">
</form>
```

### 文件编码上传

将文件进行编码，然后在服务端进行解码，主要实现原理就是将图片转换成base64进行传递；

```javascript
var canvas=document.getElementById("myCanvas");
var ctx=canvas.getContext("2d");
var imgURL = URL.createObjectURL(file);
ctx.drawImage(imgURL, 0, 0);
// 获取图片的编码，然后将图片当做是一个很长的字符串进行传递
var data = canvas.toDataURL("image/jpeg", 0.5); 
```

### formData异步上传

FormData 对象主要用来组装一组用 XMLHttpRequest发送请求的键/值对，可以更加灵活地发送Ajax请求；

```javascript
let files = e.target.files // 获取input的file对象
let formData = new FormData();
formData.append('file', file);
axios.post(url, formData);
```

### iframe无刷新页面

在低版本的浏览器（如IE）上，xhr是不支持直接上传formdata的，只能用form来上传文件，而form提交会因为 target 属性进行页面跳转；

通过 framename 指定 iframe 实现：把 form 的 target 属性设置为一个看不见的iframe，返回的数据会被这个iframe接受，只有该iframe会被刷新，返回结果也可以通过解析这个 iframe 内的文本来获取；

```javascript
function upload(){
    var now = +new Date()
    var id = 'frame' + now
    $("body").append(`<iframe style="display:none;" name="${id}" id="${id}" />`);

    var $form = $("#myForm")
    $form.attr({
        "action": '/index.php',
        "method": "post",
        "enctype": "multipart/form-data",
        "encoding": "multipart/form-data",
        "target": id
    }).submit()

    $("#"+id).on("load", function(){
        var content = $(this).contents().find("body").text()
        try{
            var data = JSON.parse(content)
        }catch(e){
            console.log(e)
        }
    })
}
```

## 大文件上传

大文件上传主要实现以下几个需求：

1. 支持拆分上传即切片；
2. 支持断点续传；
3. 支持显示上传进度和暂停上传；

### 文件切片

> 文件切片就是先获取文件的二进制内容，然后对内容进行拆分，再将每个切片上传到服务端即可；

在 JS 中，文件 File 对象是 Blob 对象的子类，Blob 对象有一个 slice 方法，这个方法可以对二进制文件进行拆分；

```javascript
let file =  document.querySelector("[name=file]").files[0];

const LENGTH = 1024 * 1024 * 0.1;
let chunks = slice(file, LENGTH); // 首先拆分切片

chunks.forEach(chunk=>{
  let fd = new FormData();
  fd.append("file", chunk);
  post('/mkblk.php', fd)
})

function slice(file, piece = 1024 * 1024 * 5) {
  let totalSize = file.size; // 文件总大小
  let start = 0; // 每次上传的开始字节
  let end = start + piece; // 每次上传的结尾字节
  let chunks = []
  while (start < totalSize) {
    // 根据长度截取每次需要上传的数据
    let blob = file.slice(start, end); 
    chunks.push(blob)

    start = end;
    end = start + piece;
  }
  return chunks
}
```

### 还原切片

在后端需要将多个相同文件的切片还原成一个文件，上面的切片处理方法存在以下问题：

1. 如何识别多个切片来源同一文件；
   - 在每个切片请求上传递一个相同文件的 context 参数；
2. 如何将多个切片还原成一个文件；
   - 客户端在切片全部上传后调用接口通知服务端进行拼接；
   - 找到同一个 context 下的所有切片，确认每个切片的顺序（前端可以在每个切片上标记一个位置索引值）；
   - 按顺序拼接碎片，还原成文件；
3. 文件的 context 参数作为文件的唯一标识，可以通过两种方式获取：
   - 根据文件名、文件长度等基本信息进行拼接，为了避免多个用户上传相同的文件，可以再额外拼接用户信息保证唯一性；

### 断点切片

### 上传进度和暂停