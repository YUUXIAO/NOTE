## 技术选型

一般可根据下面的特点来选择：

- 选择团队最熟的：保证在遇到棘手的问题有人能填坑；
- 选择市场占有率高的：好招人；
- UI组件库选择 github 上 star 多的：说明用的人多，有人踩坑；

## 统一规范

### 代码规范

代码规范的好处：

1. 可以促进团队合作；
2. 可以降低维护成本；
3. 有助于 Code review（代码审查）；
4. 养成代码规范的习惯，有助于程序员自身的成长；

#### 如何制订代码规范

1. Js 代码规范
   - [airbnb (101k star 英文版)](https://github.com/airbnb/javascript)，[airbnb-中文版](https://github.com/lin-123/javascript)
   - [standard (24.5k star) 中文版](https://github.com/standard/standard/blob/master/docs/README-zhcn.md)
   - [百度前端编码规范 3.9k](https://github.com/ecomfe/spec)
2. CSS 代码规范
   - [styleguide 2.3k](https://github.com/fex-team/styleguide/blob/master/css.md)
   - [spec 3.9k](https://github.com/ecomfe/spec/blob/master/css-style-guide.md)

#### 如何检查代码规范

使用 eslint 可以检查代码符不符合团队制订的规范；

1. 下载依赖

```javascript
// eslint-config-airbnb-base 使用 airbnb 代码规范
npm i -D babel-eslint eslint eslint-config-airbnb-base eslint-plugin-import
```

2. 在 package.json 的 script 配置代码

```javascript
"lint": "eslint --ext .js test/ src/ bin/"
```

### git 规范

### 分支管理规范

1. 一般项目分主分支（master）和其他分支；
2. 当要开发新功能或改 BUG 时，就从 master 分支开一个新的分支，开发完了再合并回 master 分支；
3. 如果改一个 BUG，也可以从 master 分支开一个新分支，并用 BUG 号命名（看 bug 情况）；

### git commit 规范

大致分为三个部分（使用空行分割）：

1. 标题行：必填，描述主要修改类型和内容；
2. 主题内容： 描述为什么修改, 做了什么样的修改, 以及开发的思路等等；
3. 页脚注释: 可以写注释，BUG 号链接；

```javascript
<type>(<scope>): <subject>
<BLANK LINE>
<body>
<BLANK LINE>
<footer>
```

#### type: commit 的类型

- feat: 新功能、新特性
- fix: 修改 bug
- perf: 更改代码，以提高性能
- refactor: 代码重构（重构，在不影响代码内部行为、功能下的代码修改）
- docs: 文档修改
- style: 代码格式修改, 注意不是 css 修改（例如分号修改）
- test: 测试用例新增、修改
- build: 影响项目构建或依赖项修改
- revert: 恢复上一次提交
- ci: 持续集成相关文件修改
- chore: 其他修改（不在上述类型中的修改）
- release: 发布新版本
- workflow: 工作流相关文件修改

1. scope: commit 影响的范围, 比如: route, component, utils, build...
2. subject: commit 的概述
3. body: commit 具体修改内容, 可以分为多行.
4. footer: 一些备注, 通常是 BREAKING CHANGE 或修复的 bug 的链接.

示例：

```javascript
// fix（修复BUG）
// 示例1:这次 BUG 修复影响到全局，可以加个 globa
fix(global):修复checkbox不能复选的问题
// 示例2:下面圆括号里的 common 为通用管理的名称
fix(common): 修复字体过小的BUG，将通用管理下所有页面的默认字体大小修改为 14px

// feat（添加新功能或新页面）
feat: 添加网站主页静态页面

这是一个示例，假设对点检任务静态页面进行了一些描述。
 
这里是备注，可以是放BUG链接或者一些重要性的东西。
```

#### 验证 git commit 规范

验证 git commit 规范，主要通过 git 的 pre-commit 钩子函数来进行，还需要下载一个辅助工具来帮助验证；

1. 下载辅助工具

```javascript
npm i -D husky
```

2. 在 package.json 加上代码

```javascript
"husky": {
  "hooks": {
  	// 在 git commit 前执行 npm run lint 检查代码格式
    "pre-commit": "npm run lint",
    // 在 git commit 时执行脚本 verify-commit.js 验证 commit 消息,如果不符合脚本中定义的格式，将会报错
    "commit-msg": "node script/verify-commit.js",
    // 在执行 git push 将代码推送到远程仓库前，执行 npm test 进行测试。如果测试失败，将不会执行这次推送
    "pre-push": "npm test"
  }
}
```

3. 在项目根目录新建一个文件夹 script，并在下面新建一个文件 verify-commit.js ,输入以下代码

```javascript
const msgPath = process.env.HUSKY_GIT_PARAMS
const msg = require('fs')
.readFileSync(msgPath, 'utf-8')
.trim()

const commitRE = /^(feat|fix|docs|style|refactor|perf|test|workflow|build|ci|chore|release|workflow)(\(.+\))?: .{1,50}/

if (!commitRE.test(msg)) {
    console.error(`
        不合法的 commit 消息格式。
        请查看 git commit 提交规范：https://github.com/woai3c/Front-end-articles/blob/master/git%20commit%20style.md
    `)

    process.exit(1)
}
```

### 项目规范

主要是项目文件的组织方式和命名方式，例如：

```javascript
// 文件名称如果过长则用 - 隔开;

├─api （接口）
├─assets （静态资源）
├─components （公共组件）
├─styles （公共样式）
├─router （路由）
├─store （vuex 全局数据）
├─utils （工具函数）
└─views （页面）
```

### UI 规范

UI 规范需要前端、UI、产品沟通，互相商量，最后制定下来，建议使用统一的 UI 组件库；

1. 统一页面 UI 标准，节省 UI 设计时间；
2. 提高前端开发效率；

## 测试

### 单元测试 

> 单元测试就是对一个函数、一个组件、一个类做测试，它针对的颗粒度比较小；

它应该怎样写呢？

1. 根据正确性写测试，即正确的输入应该有正常的结果；
2. 根据异常写测试，即错误的输入应该是错误的结果；

#### 对一个函数做测试

例如一个取绝对值的函数 abs()，输入 1,2，结果应该与输入相同；

输入 -1,-2，结果应该与输入相反；

如果输入非数字，例如 abc，应该抛出一个类型错误；

#### 对一个类做测试

假设有这样一个类：

```javascript
class Math {
    abs() {

    }

    sqrt() {

    }

    pow() {

    }
    ...
}
```

单元测试，必须把这个类的所有方法都测一遍；

#### 对一个组件做测试 

> 一般测试是跑在 node 环境下的，而 node 环境没有 DOM 对象；

以一个上传图片组件，它有一个将图片转成 base64 码的方法测试为例；

使用情况：

```javascript
document.querySelector('input').onchange = function fileChangeHandler(e) {
    const file = e.target.files[0]
    tobase64(file)
}

function tobase64(file) {
    return new Promise((resolve, reject) => {
        const reader = new FileReader()
        reader.onload = (res) => {
            const fileResult = res.target.result
            resolve(fileResult) // 输出 base64 码
        }

        reader.readAsDataURL(file)
    })
}
```

可以在测试环境加上 window 的事件对象 event、FileReader；

```javascript
// 重写 File
window.File = function () {}

// 重写 FileReader
window.FileReader = function () {
    this.readAsDataURL = function () {
        this.onload
            && this.onload({
                target: {
                    result: fileData,
                },
            })
    }
}
```

测试可以这样写：

```javascript
// 提前写好文件内容
const fileData = 'data:image/test'

// 提供一个假的 file 对象给 tobase64() 函数
function test() {
    const file = new File()
    const event = { target: { files: [file] } }
    file.type = 'image/png'
    file.name = 'test.png'
    file.size = 1024

    it('file content', (done) => {
        tobase64(file).then(base64 => {
            expect(base64).toEqual(fileData) // 'data:image/test'
            done()
        })
    })
}

// 执行测试
test()
```

### TDD 测试驱动开发

> TDD 就是根据需求提前把测试代码写好，然后根据测试代码实现功能；

但是 TDD 的缺陷在于 如果你的需求是经常变更的，那就不是一件好事了；

### 测试框架推荐

推荐 jest：有中文文档，API  清晰明了；

## 部署

> 自动部署（又叫持续部署 Continueous Deployment，英文缩写 CD）;

传统部署项目流程：

1. 执行测试：npm run test；
2. 推送代码：git push；
3. 构建项目：npm run build；
4. 将打包好的文件放到静态服务器；

自动部署一般有两种触发方式：

1. 轮询；
2. 监听 webhook 事件；

### 轮询

> 轮询，就是构建软件每隔一段时间自动 执行打包、部署操作；

缺点：

1. 可能软件刚部署完就改代码，要等到下一次构建结束才能看到效果；
2. 假如长时间没有更改代码，还是会执行打包、部署操作，浪费资源；

### 监听 webhook 事件 

## 监控

### 性能监控

### 错误监控

### 数据上报

### SPA

### 用户信息收集

### 前端部署教程



