> TCP是因特网中的传输层协议，使用三次握手协议建立连接，当主动方发出SYN连接请求后，等待对方回答；

TCP 是通过序列号、确认应答、重发控制、连接管理以及窗口控制等机制实现可靠性传输的；

## TCP

> TCP全名传输控制协议，在OSI模型中属于传输层协议；

许多应用层协议基于TCP协议构建，典型的是HTTP、SMTP、IMAP等协议；

## 重传机制

> TCP 实现可靠传输的方式之一：是通过序列号与确认应答；

在 TCP 中，当发送端的数据到达接收主机时，接收端主机会返回一个确认应答消息，表示已收到消息， TCP 针对数据包丢失的情况，会用重传机制；

### 超时重传

> 就是在发送数据时，设定一个定时器，当超过指定的时间后，没有收到对方的 ACK 确认应答报文，就会重发该数据；

1. 每当遇到一次超时重传的时候，都会将下一次超时时间间隔设为先前值的两倍，两次超时，就说明网络环境差，不宜频繁反复发送；
2. 超时触发重传存在的问题是，超时周期可能相对较长；

### 快速重传

> 快速重传机制，它不以时间为驱动，而是以数据驱动重传；

1. 快速重传的工作方式是当收到N个相同的 ACK 报文时，会在定时器过期之前，重传丢失的报文段；
2. 快速重传机制只解决了一个问题，就是超时时间；
3. 它依然面临着另外一个问题，就是重传的时候，是重传之前的一个，还是重传所有的问题；

在下图，发送方发出了 1，2，3，4，5 份数据：

1. 第一份 Seq1 先送到了，于是就 Ack 回 2；
2. 结果 Seq2 因为某些原因没收到，Seq3 到达了，于是还是 Ack 回 2；
3. 后面的 Seq4 和 Seq5 都到了，但还是 Ack 回 2，因为 Seq2 还是没有收到；
4. 发送端收到了三个 Ack = 2 的确认，知道了 Seq2 还没有收到，就会在定时器过期之前，重传丢失的 Seq2；
5. 最后，接收到收到了 Seq2，此时因为 Seq3，Seq4，Seq5 都收到了，于是 Ack 回 6 ；

![img](https://user-gold-cdn.xitu.io/2020/7/25/17384f116656218a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

### SACK

这种方式需要在 TCP 头部「选项」字段里加一个 SACK 的东西，它可以将缓存的地图发送给发送方，这样发送方就可以知道哪些数据收到了，哪些数据没收到，知道了这些信息，就可以只重传丢失的数据；

![img](https://user-gold-cdn.xitu.io/2020/7/25/17384f117128506f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

### Duplicate  SACK

> Duplicate SACK 又称 D-SACK，使用了 SACK 来告诉「发送方」有哪些数据被重复接收了；

#### ACK丢包

1. 「接收方」发给「发送方」的两个 ACK 确认应答都丢失了，所以发送方超时后，重传第一个数据包（3000 ~ 3499）；
2. 于是「接收方」发现数据是重复收到的，于是回了一个 SACK = 3000~3500，告诉「发送方」 3000~3500 的数据早已被接收了，因为 ACK 都到了 4000 了，已经意味着 4000 之前的所有数据都已收到，所以这个 SACK 就代表着 D-SACK；
3. 「发送方」就知道数据没有丢，是「接收方」的 ACK 确认报文丢了；

![img](https://user-gold-cdn.xitu.io/2020/7/25/17384f11748d020f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

#### 网络延时

1. 数据包（1000~1499） 被网络延迟了，导致「发送方」没有收到 Ack 1500 的确认报文；
2. 后面报文到达的三个相同的 ACK 确认报文，就触发了快速重传机制，但是在重传后，被延迟的数据包（1000~1499）又到了「接收方」；
3. 「接收方」回了一个 SACK=1000~1500，因为 ACK 已经到了 3000，所以这个 SACK 是 D-SACK，表示收到了重复的包；
4. 发送方就知道快速重传触发的原因不是发出去的包丢了，也不是因为回应的 ACK 包丢了，而是因为网络延迟了；

![img](https://user-gold-cdn.xitu.io/2020/7/25/17384f118232614c?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

#### 优势

1. 可以让「发送方」知道，是发出去的包丢了，还是接收方回应的 ACK 包丢了；
2. 可以知道是不是「发送方」的数据包被网络延迟了；
3. 可以知道网络中是不是把「发送方」的数据包给复制了；

## 滑动窗口协议

> 滑动窗口就是一种流量控制技术；

1. 本质上是描述接收方的 TCP 数据报缓冲区大小的数据，发送方根据这个数据来计算自己最多能发送多长的数据；
   - 如果发送方收到接收方的窗口大小为 0 的TCP数据报，那么将停止发送数据；
   - 等到接收方发送窗口大小不为 0 的数据报的到来；
2. 主要为了解决在网络传输数据的过程中，发送方和接收方传输数据速率不一致的问题，从而保证数据传输的可靠性，达到流量控制的效果；

### 窗口

> 窗口大小就是指无需等待确认应答，而可以继续发送数据的最大值；

1. 窗口的实现实际上是操作系统开辟的一个缓存空间，发送方主机在等到确认应答返回之前，必须在缓冲区中保留已发送的数据，如果按期收到确认应答，此时数据就可以从缓存区清除；

假设窗口大小为 3 个 TCP 段，那么发送方就可以「连续发送」 3 个 TCP 段，并且中途若有 ACK 丢失，可以通过「下一个确认应答进行确认」；

![img](https://user-gold-cdn.xitu.io/2020/7/25/17384f118863234b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

### 窗口大小

1. 通常窗口的大小是由接收方的决定的；
2. TCP 头里有一个字段叫 Window，也就是窗口大小；
3. Window 字段是接收端告诉发送端自己还有多少缓冲区可以接收数据，于是发送端就可以根据这个接收端的处理能力来发送数据，而不会导致接收端处理不过来；
4. 发送方发送的数据大小不能超过接收方的窗口大小，否则接收方就无法正常接收到数据；

### 发送方的滑动窗口

1. \#1 是已发送并收到 ACK 确认的数据：1~31 字节；
2. \#2 是已发送但未收到 ACK 确认的数据：32~45 字节；
3. \#3 是未发送但总大小在接收方处理范围内（接收方还有空间）：46~51 字；
4. \#4 是未发送但总大小超过接收方处理范围（接收方没有空间）：52 字节以后；

![img](https://user-gold-cdn.xitu.io/2020/7/25/17384f11a6572ab5?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

当发送方把数据「全部」都一下发送出去后，可用窗口的大小就为 0 了，表明可用窗口耗尽，在没收到 ACK 确认之前是无法继续发送数据了；

![img](https://user-gold-cdn.xitu.io/2020/7/25/17384f119ca2a493?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

当收到之前发送的数据 32~36 字节的 ACK 确认应答后，如果发送窗口的大小没有变化，则滑动窗口往右边移动 5 个字节，因为有 5 个字节的数据被应答确认，接下来 52~56 字节又变成了可用窗口，那么后续也就可以发送 52~56这 5 个字节的数据了；

![img](https://user-gold-cdn.xitu.io/2020/7/25/17384f11a9324c17?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

### 接收方的滑动窗口

1. \#1 + #2 是已成功接收并确认的数据（等待应用进程读取）；
2. \#3 是未收到数据但可以接收的数据；
3. \#4 未收到数据并不可以接收的数据；

![img](https://user-gold-cdn.xitu.io/2020/7/25/17384f11b680af2c?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

其中三个接收部分，使用两个指针进行划分:

1. RCV.WND：表示接收窗口的大小，它会通告给发送方；
2. RCV.NXT：是一个指针，它指向期望从发送方发送来的下一个数据字节的序列号；
3. 指向 #4 的第一个字节是个相对指针，它需要 RCV.NXT 指针加上RCV.WND 大小的偏移量，就可以指向 #4 的第一个字节了；

## 流量控制

TCP 提供一种机制可以让「发送方」根据「接收方」的实际接收能力控制发送的数据量；

### 死锁

1. 当接收方向发送方发送零窗口报文段后不久，接收端的接收缓存又有了一些存储空间；
2. 于是接收端向发送端发送了 Windows size = 2 的报文段；
3. 然而这个报文段在传输过程中丢失了；
4. 发送端一直等待收到接收端发送的非零窗口的通知，而接收端一直等待发送端发送数据，这样就死锁了；

解决方法：

TCP 为每个连接设有一个持续计时器，只要 TCP 连接的一方收到对方的零窗口通知，就启动持续计时器，若持续计时器设置的时间到期，就发送一个零窗口探测报文段，而对方就在确认这个探测报文段时给出了现在的窗口值；

### Negle算法

> Negle 算法主要为了解决TCP的传输效率问题；

1. 若要把发送的数据逐个字节缓存起来，则发送方需要把第一个字节发送出去，然后缓存后面的字节；
2. 在收到接收方第一个字节的确认，再将现有缓存中所有字节组成一个报文段发送出去，继续缓存后续数据；
3. 只有在收到前一个报文的确认之后发送后面的数据，这是为了减少所用带宽；
4. 当发送数据到达TCP发送窗口的一半或已达到报文段的最大长度也会立即发送报文段，而不是等待接收方确认，这是为了提高网络吞吐量；

### 糊涂窗口综合征

TCP接收方的缓存已满，若上层一次从缓存中读取一个字节，这样接收方就可以继续接纳一个字节的窗口，然后向发送方发送确认，把窗口设为1个字节，这样持续下去，网络效率会非常低；

有效的解决方法，就是让接收方等待一定时间，让缓存空间能够接纳一个最长的报文段，或者等待接收缓存已有一半的空闲空间，再发出确认报文和通知当前窗口大小；