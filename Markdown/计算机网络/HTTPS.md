> 超文本传输协议（HTTPS）是一种通过计算机网络进行安全通信的传输协议；

Https 是经 Http 进行通信，但利用 SSL/STS进行的数据加密（比http通信多一个环节）；主要的目的**是提供对服务器的身份认证，保护数据隐私和完整性**；

## 功能

- **内容加密：**对数据进行加密，并建立一个信息安全通道，来保证传输过程中的数据安全;
- **身份认证：**对网站服务器进行真实的身份认证；
- **数据的完整性：**防止内容被第三方冒充或者篡改；

## 缺点

HTTPS 也存在一些问题，那就是当使用 SSL 时，它的处理速度会变慢；

1. **通信慢：**除去和 TCP 连接、发送 HTTP 请求 和响应以外，还必须进行 SSL 通信，整体上处理通信量不可避免会增加；
2. **大量消耗 CPU 及内存等资源，导致处理速度变慢：**在服务器和客户端都需要进行加密和解密的运算处理，会更多地消耗服务器和客户端的硬件资源，导致负载增强；

   可以使用 SSL 加速器硬件来改善该问题：该硬件为 SSL 通信专用硬件，相对软件来讲，能够提高数倍 SSL 的计算速度，仅在 SSL 处理时发挥 SSL加速器的功效，以分担负载；


## CA 证书

> CA 证书其实就是数字证书，由 CA 机构颁发；

### 内容

1. 证书的颁发机构、版本；
2. 证书的使用者；
3. 证书的公钥（**证书的私钥不在CA证书里**）；
4. 证书的有效时间；
5. 证书的数字签名 Hash 值和签名 Hash 算法；
6. ......

### 校验 CA 证书

简单来说就是客户端用公钥解密的值对比用算法生成的值比较相等：

1. CA 证书中的 Hash 值，就是用证书的私钥进行加密后的值；
2. 客户端得到证书后，利用证书中的公钥去解密该 Hash 值得到 Hash-a；
3. 客户端再利用证书内的签名 Hash 算法去生成一个 Hash-b；
4. 比较 Hash-a 和hash-b两个值；
5. 如果相等表示该证书是对的，否则该证书是错误的，浏览器给出相关提示，无法建立 HTTPS 连接；

## SSL 协议

> SSL （Secure Soket Layer）安全套接层，位于应用层和传输层之间，是一种为网络通信提供安全及完整性验证的一种网络协议；

### 握手过程

SSL 协议是建立在 TCP 协议之上的，所以在使用 SSL 传输数据之前需要先进行[三次握手](%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.md)和服务器建立连接；

1. 客户端先给服务端发送一个消息，消息内容包括：客户端支持的加密方式，支持的压缩方法、SSL 的版本号、客户端生成的**随机数1**、文本内容等；
2. 服务端接收到消息后回发一个消息，并携带从客户端支持的加密方式中选择的加密方式，服务端生成的**随机数2**，服务器的 SSL 版本号等信息；
3. 服务器给客户端发送一个 Certificate 报文，报文中包含服务端的公钥证书；
4. 服务器给客户端发送 Server Hello Done，表示最初的协商握手过程线束；
5. 客户端接收到服务端发送的握手结束的消息后，以 Client Key Exchange 作为回应，此报文中包含通信加密中过程中使用的一种被称为 Pre-master secret 的**随机密码串3**，并使用第三步接收到的**公钥证书进行加密**；
6. 服务端使用自己的私钥获取客户端发来的**随机数3**；
7. 接着客户端发送 Change Cipher Spec 报文，该报文告知服务端，此步骤之后的所有数据将使用第五步中生成的 master secret（双方约定的加密方法） 进行加密；
8. 随后客户端发送 Finish 报文，此报文包含连接至今所有报文的整体校验值，用于完整性验证；
9. 服务端接收到客户端发送的 Change Clipher Spec 报文后，同样以 Change Clipher Spec 报文作为回应；
10. 接着服务端发送 Finish 报文给客户端，表示服务端已正确解析客户端发送的整体校验值，至此，SSL 握手过程结束；
11. 随后开始使用 HTTP 协议传输使用 master secret 加密过的数据；

#### 说明

1. 前两步是协商加密算法以及传输各自生成的随机数（为后续生成 master secret 做准备）的过程；
2. 第三步服务端将自己的证书发送给客户端，这个证书包含一个数字签名（CA签名）和服务端 CA 证书的公钥，客户端可验证证书的有效性（完整性&真实性）；
3. 服务端收到客户端发送的 Change Clipher Spec （第五步），会使用自己的私钥进行解密，获取报文中的 Pre-master secret，这时通信双方都拥有对方的 Random （前两步生成的），Pre-master secret，以及自身的 Random，将三个数作为种子通过算法生成 master secret，用来加密后续 http 请求过程中的数据；

#### 简洁版

1. **（第一步-第四步）:** 客户端和服务端建立 SSL 握手，客户端通过 CA 证书来确认服务端的身份；
2.  **互相传递三个随机数** ，之后通过这个随机数来生成一个密钥；
3.  **（第五步-第六步）：** 互相确认密钥，然后握手结束；
4. 数据通讯开始，都使用同一个对话密钥来加解密；

### 加密方式

#### 对称加密

通信双方都有一个共同的密钥，然后通过这个密钥完成加密和解密，这种加密方式速度快，但是安全性不如非对称加密好；

#### 非对称加密

数据传输之前，服务端只需要将自己的公钥传输给客户端，客户端在传输数据时，使用接收到的公钥进行加密，服务端接收到数据后使用私钥进行解密即可；

但是非对称加密需要大量的计算，会占用很多硬件资源，效率太低；

#### 对称加密和非对称加密组合

SSL 使用非对称加密的方式传输对称加密中生成密钥的种子（Pre master secret）对应上面第五步，然后使用对称加密的方式对通信数据进行加密（对应第十步），既保障了密钥的安全，也提高了加密速度；

### 连接断开后恢复

#### 通过 session ID

使用 session ID 的方式，每一次的会话都有一个编号，当会话中断后，下一次重新连接时，只要客户端给出这个编号，服务器如果有这个编号的记录，那么双方就可以使用之前的秘钥；

但是这个方法有一个缺点， session ID 只能够存在一台服务器上，如果我们请求通过负载平衡被转移到了其他的服务器上，那么就无法恢复对话；

#### 通过 session ticket

session ticket 是服务器在上一次对话中发送给客户的，这个 tikcet 是加密的，只有服务器能够解密，里面包含了本次会话的信息，比如对话密钥和加密方法等，这样不管我们的请求是否转移到了其他的服务器上，当服务器将 ticket 解密以后，就能够获取上次对话的信息，就不用生成新的对话密钥；

## Https抓包

1. 当客户端请求数据时，抓包工具对请求进行拦截，然后构造数据（冒充客户端）向服务端发送请求；
2. 服务端会返回自己的公钥证书；
3. 然后抓包工具将服务端的公钥证书替换成自己的公钥证书，随后将数据返回客户端（充当服务端角色）；
4. 客户端拿到公钥证书之后，使用公钥证书的公钥对 Pre-master secret 进行加密，并发送给服务端；
5. 被抓包工具拦截，由于客户端使用的是抓包工具生成的证书公钥，所以抓包工具使用自己私钥进行解密拿到真实的 Pre-master secret （因为抓包工具在之前的过程中已经拿到了双方的随机码，所以这一步相当于已经拿到了后续通信使用的密钥）；
6. 抓包工具使用从服务端接收到的公证书中的公钥对 Pre-master secret 进行加密，发送给服务端；
7. 随后的通信虽然进行了加密，但抓包工具已经生成了密钥，所以可以查看 Https 的通信内容；