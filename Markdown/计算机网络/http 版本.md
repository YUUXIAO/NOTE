## http 0.9

1. http 0.9 只是一个简单的协议，只有一个 GET 方法，没有首部，目标用来获取 HTML；

### 流程

1. 客户端构建请求，通过 DNS 查询 IP 地址；
2. 三次握手建立 TCP 连接；
3. 客户端发起请求，服务器响应；
4. 四次挥手断开 TCP 连接；

## http 1.0

### 流程

1. 客户端构建请求，通过 DNS 查询 IP 地址；
2. 三次握手建立 TCP 连接；

## http 1.0 

### http1.1

1. 改进持久连接和 CDN 域名的分片机制；
2. 不成熟的 http 管道化；
3. 提供虚拟主机支持；
4. 对动态生成的内容完美支持；
5. 引入 cookie 以及安全机制；

### http1.x 存在的问题

1. 协议规定客户端对同一域的并发连接最多只能2个；
2. 队头阻塞：同一个连接中的请求，需要一个接一个串行发送和接收；
3. 基于文本协议，请求和响应头信息非常大，并且无法压缩；
4. 不能控制响应的优先级，必须按照请求顺序响应；
5. 只能单向请求，也就是客户端请求什么，服务器只能返回什么；

## http 2.0

> http2 是超文本传输协议的第二版，相比 http1 协议的文本传输格式，http2 是以二进制的格式进行数据传输的，具有更小的体积以及负载；

### 基础概念

- 流：已建立的连接上的双向字节流；
- 消息：与逻辑消息对应的完整的一系列数据帧；
- 帧：http2 通信的最小单位，每个帧包含首部，至少也会标识出当前帧所属的流；

### 使用二进制协议

在 http1.x ，无论是传输内容或头信息，都是文本/ ASCII 编码的，虽然有利于从请求中直接观察内容，但是使得想要实现并发传输异常困难（存在空格或其他字符，很难判断消息的起始和结束），使用二进制传输可以避免这个问题，因为传输内容只有1和0，通过帧规范规定格式，可以识别出不同类型的内容，同时有更小的传输体积意味着更低的负载；

### 多路复用

客户端和服务器可以把 http 消息分解为互不依赖的帧，然后乱序发送，最后再在另一端把它们重新组合，同一链路上有多个不同方向的帧，客户端可以一边乱序发送 stream，也可以一边接收服务器的响应，服务器也如此；

http2 通信都在一个连接上完成，这个连接可以承载任意数量的双向数据流，这样只需要建立一个 TCP 连接就可以传送网页上所有资源，不仅可以减少消息交互往返的时间还可以避免创建新连接造成的延迟，使 TCP 的效率更高；

### 优先级和依赖关系 

每个流都包含一个优先级，它用来告诉对端哪个流更重要，当资源有限的时候，服务器会根据优先级来选择应该先发送哪些流；

借助 PRIORITY 帧，客户端可以告知服务器当前流依赖于其它哪个流，该功能能让客户端建立一个优先级“树”，所有“子流”会依赖于“父流”的传输完成情况；

优先级和依赖关系可以在传输过程中被动态的改变。这样当用户滚动一个全是图片的页面的时候，浏览器就能够指定哪个图片拥有更高的优先级。或者是在你切换标签页的时候，浏览器可以提升新切换到页面所包含流的优先级。

### 压缩头部

因为 http 协议本身是无状态的，所以每个请求之前互不关联，每个请求都需要携带服务器所需要的信息；

在 http2 之前一般使用 Cookie 头，服务器 session 等方式模拟出状态，但是这样的缺点就是每个请求都要携带大量的重复信息并且无法压缩，这是一个巨大的带宽浪费；

http2 增加了两个特性解决上面的问题：

- HPACK：专门为头部压缩设计的算法，还被指定成单独的草案中；

- 首部表：

  1. http2 在客户端和服务器端使用“首部表”来跟踪和存储之前发送的键值对，对于相同的数据，不再通过每次请求和响应再次发送；
  2. 通信期间几乎不会改变的通用键值对（用户代理、可接受的媒体类型等）只需要发送一次；
  3. 如果首部发生变化，那么只需要发送变化数据在 Headers 帧里面，新增或者修改的首部帧会被追加到“首部表”；

  ![header-table](https://user-gold-cdn.xitu.io/2018/4/10/162b00acb5991f30?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

### 服务器推送

也被称作 “缓存推送”：当一个客户端请求资源 X，而服务器知道它可能也需要资源 Z 的情况下，服务器可以在客户端发送请求 Z 之前，主动将资源 Z 推送给客户端，这个功能帮助客户端将 Z 放进缓存以备将来之需；

服务器推送需要客户端显示的允许服务器提供该功能，客户端能自主选择是否需要中断该推送的流，如果不需要的话，客户端可以发送一个 RST_STREAM 帧来中止推送；

主动推送的资源是能被浏览器缓存的；

### 可重置消息

在 http1.x 中有一个问题：当一个含有确切值的 Content-lengt 的 http 消息被送出之后，就很难中断它了，通常可以断开整个TCP 连接，但是这样导致的代价就是需要通过三次握手来重新建立一个新的 TCP 连接；

在 http2 里，可以通过发送 RST_STRWAM 帧来实现这个需求，从而避免浪费带宽和中断已有的连接；

### 流量控制

每个 http2 流都拥有自己的公示的流量窗口，它可以限制另一端发送数据；
对于每个流来说，两端都必须告诉对方自己还有足够的空间来处理新的数据，而在窗口被放大前，另一端只被允许发送这么多数据；
只有数据帧会受到流量控制；

### 优势

1. 更小的传输体积，更小或者省略重复的头消息；
2. 突破原有的 TCP 连接并发限制，使用一个 TCP 连接即可实现多请求并发，单连接也能减轻服务端的压力（更少的内存和CPU使用）；
3. 解决 HOLB 线头问题，慢的请求或者先发送的请求不会阻塞其它的请求返回；
4. 结合 CDN 提供实时性更高，延迟更低的内容分发代理服务，大大减少白屏时间；
5. 数据传输优先级可控，使网站可以实现更灵活和强大的页面控制；
6. 能在不中断 TCP 连接的情况下停止（重置）数据的发送；

## https

> https 协议是承载在 TCP 协议上的，在 http 和 tcp 之间添加一个安全层协议，SSL 或者 TSL （ssl/tls 协议传输，包含证书，卸载，流量转发，负载均衡，页面适配，浏览器适配，refer传递等）；

### 与 http 的对比

1. 传输方式：
   - http：明文传输，网站或者相关服务与用户之间的数据交互无加密，容易被监听、篡改；
   - https：在 http 加入了 ssl 层，用于数据加密传输；
2. 身份认证：
   - http：无任何身份认证，用户无法通过 http 辨认出网站的真实身份；
   - https：经过 CA 多重认证，包含域名管理权限认证等；
3. 成本：
   - http：无任何使用成本，所有网站默认是 http 模式；
   - https：需要成本，需要申请 SSL 证书来实现 https；
4. 连接端口：
   - http：80 端口；
   - https：443 端口；

## Http 的请求方法

1.  GET 方法：发送一个请求来获取服务器上的某些资源；
2.  POST 方法：向 URL 指定的资源提交数据或者附加新的数据；
3.  PUT 方法：和 POST 方法一样，可以向服务器提交数据，但是也有不同， PUT 指定了资源在服务器的位置，POST 没有；
4.  HEAD 方法：请求页面的首部；
5.  DELETE 方法：删除服务器上的某些资源；
6.  OPTIONS 方法：它用于获取当前 URL 所支持的方法，如果请求成功，在 Allow 的头包含类似 GET , POST 等信息；
7.  TRACE 方法：用于激发一个远程的，应用层的请求消息回路；
8.  CONNECT 方法：把请求连接转换到 TCP / IP 通道；



