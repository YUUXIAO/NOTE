![](images/%E6%8F%A1%E6%89%8B&%E6%8C%A5%E6%89%8B.jpg)

## 三次握手

> 三次握手其实就是在创建一个TCP连接时，需要客户端和服务器总共发送3个包；

握手的主要作用就是为了确认双方的接收能力和发送能力是否正常、指定自己的初始化序列号为后面的可靠性传送做准备；

实质上就是连接服务器指定端口，建立TCP连接，并同步双方的序列号和确认号，交换 TCP 窗口大小信息；

### 流程

刚开始客户端处于 Closed 的状态，服务端处于 Listen 状态；

1. 第一次握手（客户端发送状态）

   - 客户端发送连接请求报文给服务端，其中同步序列编号 SYN=1，初始序号 seq=x；
   - 发送完毕后进入 SYN_END 状态；

2. 第二次握手（服务端接收状态）

   - 服务端接收到报文后，发回确认报文，其中确认报文段 ACK=1，确认号 ack=x+1；
   - 因为需要客户端确认，所以报文中也有 SYN=1，初始序号 seq=y ；
   - 发送完后进入 SYN_RCVD 状态；

3. 第三次握手（客户端&服务端确认成功）

   - 客户端接收到报文后,发送确认报文，其中 ACK=1，确认号 ack=y+1；
   - 发送完客户端进入 ESTABLISHED 状态；
   - 服务端接收到报文后，进入ESTABLISHED 状态；
   - 到此，连接建立完成；


### 目的

> 三次握手的目的就是判断客户端和服务端的发送数据能力和接受能力是没问题的，可以保证资源不会被浪费掉；

1. 第一次握手：客户端发送网络包，服务端收到了，得出结论：**客户端的发送能力、服务端的接收能力是正常的；**
2. 第二次握手：服务端发包，客户端收到了，得出结论：**服务端的接收、发送能力，客户端的接收能力是正常的，此时服务器并不能确认客户端的接收能力是否正常；**
3. 第三次握手：客户端发包，服务端收到了，得出结论：**客户端的接收、发送能力正常，服务器的发送、接收能力也正常；**

### 半/全连接队列

**半连接队列：**服务器第一次收到客户端的 SYN 之后，就会处于 SYN_RCVD 状态，此时双方还没有完全建立其连接，服务器会把此种状态下请求连接放在一个队列里

**全连接队列：**表示已经完成三次握手，建立起连接的就会放在全连接队列中，如果队列满了就有可能会出现丢包现象；

**SYN-ACK 重传次数**的问题：

1. 服务器发送完 SYN-ACK 包，如果未收到客户确认包，服务器进行首次重传；
2. 等待一段时间仍未收到客户确认包，进行第二次重传；
3. 如果重传次数超过系统规定的最大重传次数，系统将该连接信息从半连接队列中删除；
4. 每次重传等待的时间不一定相同，一般会是指数增长，例如间隔时间为 1s，2s，4s，8s…；

### ISN

当一端为建立连接而发送它的 SYN 时，它为连接选择一个初始序号；

ISN 随时间而变化，因此每个连接都将具有不同的ISN。ISN可以看作是一个32比特的计数器，每4ms加1 。这样选择序号的目的在于防止在网络中被延迟的分组在以后又被传送，而导致某个连接的一方对它做错误的解释。

三次握手的其中一个重要功能是客户端和服务端交换 ISN，以便让对方知道接下来接收数据的时候如何按序列号组装数据。如果 ISN 是固定的，攻击者很容易猜出后续的确认号，因此 ISN 是动态生成的。

### 携带数据

> 第三次握手是可以携带数据的，第一、二次握手不可以携带数据；

假如第一次握手可以携带数据的话，当有人要恶意攻击服务器，每次都在第一次握手中的 SYN 报文中放入大量的数据。因为攻击者根本就不理服务器的接收、发送能力是否正常，这会让服务器花费很多时间、内存空间来接收这些报文；

对于第三次的话，此时客户端已经处于 ESTABLISHED 状态，对于客户端来说，他已经建立起连接了，并且也已经知道服务器的接收、发送能力是正常的了，所以能携带数据；

### SYN攻击

SYN 攻击就是客户端在短时间内伪造大量不存在的IP地址，并向Server不断地发送SYN包，Server则回复确认包，并等待客户端确认，由于源地址不存在，因此 Server 需要不断重发直至超时，这些伪造的 SYN 包将长时间占用半连接队列，导致正常的SYN请求因为队列满而被丢弃，引起网络拥塞甚至系统瘫痪；

SYN 攻击是一种典型的 DoS/DDoS 攻击；

常见的防御 SYN 攻击的方法有如下几种：

1. 缩短超时（SYN Timeout）时间；
2. 增加最大半连接数；
3. 过滤网关防护；
4. SYN cookies技术；

## 四次挥手

> 四次挥手(Four-way handshake) 表示断开 TCP 的连接需要发送四个包，客户端或服务器均可主动发起挥手动作；

终止一个连接要经过四次挥手，这是由TCP的半关闭造成的，其实就是TCP提供了连接的一端在结束它的发送后还能接收来自另一端数据的能力；

刚开始双方都处于 ESTABLISHED 状态，假如是客户端先发起关闭请求，四次挥手的过程如下，其中ACK报文是用来应答的，SYN报文是用来同步的：

1. 第一次挥手

   - 客户端发送 FIN=1，初始序号 seq=x 的包给服务端，表示自己没有数据要进行传输，单面连接传输要关闭；
   - 发送完后，客户端进入FIN_WAIT_1状态，停止再发送数据；

2. 第二次挥手

   - 服务端收到请求包后，发回ACK=1，ack=x+1的确认包，表示确认断开连接；
   - 服务端进入CLOSE_WAIT 状态；
   - 客户端收到该包后，进入FIN_WAIT_2 状态，此时客户端到服务端的数据连接已断开，此时的TCP处于半关闭状态**（此时只是关闭了客户端到服务端的链接，但是服务端到客户端是还没关闭的，因为可能服务器还有数据没有发送）**；

3. 第三次挥手

   - 服务端发送 FIN=1,seq=y 的包给客户端，表示自己没有数据要给客户端了，发送完后进入 LAST_ACK 状态，等待客户端的确认包；

4. 第四次挥手

   - 客户端收到请求包后，发送 ACK=1,ack=y+1 的确认包给服务端；
   - 进入 TIME_WAIT 状态，有可能要重传确认包；
   - 服务端收到确认包后，进入CLOSED状态，服务端到客户端的连接已断开；
   - 客户端等到一段时间后也会进入CLOSED状态；


![img](https://pic3.zhimg.com/80/v2-c7d4b5aca66560365593f57385ce9fa9_720w.jpg)

### 目的

由于TCP的连接是全双工，双方都可以主动传输数据，一方的断开需要告知对方，让对方可以相关操作，负责任的表现；

但是关闭连接时，当服务端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉客户端，“你发的FIN报文我收到了”；

但是只有等到我服务端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送；

### 2MSL等待状态

MSL 为“最长报文段寿命”，它是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃；

对一个具体实现所给定的MSL值，处理的原则是：当TCP执行一个主动关闭，并发回最后一个ACK，该连接必须在 TIME_WAIT 状态停留的时间为2倍的MSL，这样可让TCP再次发送最后的 ACK 以防这个 ACK 丢失（另一端超时并重发最后的FIN）；

这种 2MSL 等待的另一个结果是这个 TCP 连接在 2MSL 等待期间，定义这个连接的插口（客户的IP地址和端口号，服务器的IP地址和端口号）不能再被使用，这个连接只能在2MSL结束后才能再被使用；

### 2MSL的意义

1. 保证客户端发送的最后一个ACK报文段能够到达服务端；

   - 因为这个ACK有可能丢失，从而导致处在LAST-ACK状态的服务器收不到对FIN-ACK的确认报文；
   - 服务器会超时重传这个FIN-ACK，接着客户端再重传一次确认，重新启动时间等待计时器；
   - 最后客户端和服务器都能正常的关闭，假设客户端不等待2MSL，而是在发送完ACK之后直接释放关闭，一但这个ACK丢失的话，服务器就无法正常的进入关闭连接状态。

2. 防止“已失效的连接请求报文段”出现在本连接中；

   - 客户端在发送完最后一个ACK报文段后，再经过2MSL，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失，使下一个新的连接中不会出现这种旧的连接请求报文段；
