> HTTP 是一个在计算机世界里专门在两点之前传输文字、图片、音频、视频等超文本数据的约定和规范；

## 特点

1. **灵活可扩展：**

   - 在语法上只规定了基本格式，空格分隔单词，换行分隔字段等；
   - 传输形式上不仅可以传输文本，还可以传输图片、视频等任意数据；

2. **请求-应答模式：**一方发送消息，一方接受消息，或者做出响应等；
3. **可靠传输：**HTTP 是基于 TCP / IP，因此把这一特性继承了下来；
4. **无状态：**可以减少网络开销，也算是一个缺点：比如需要保存用户信息时
5. **明文传输：**即协议里的报文不使用二进制数据，而是文本形式，让 http 报文信息暴露给外部；

## http 0.9

- **只支持 GET 请求方式：**由于不支持其他请求方式，因此客户端是没办法向服务端传输太多的信息；
- **没有请求头概念：**所以不能在请求中指定版本号，服务端也只具有返回 HTML字符串的能力；
- 服务端相响应之后，立即关闭TCP连接；

## http 1.0

- 任何格式的内容都可以发送，这使得互联网不仅可以传输文字，还能传输图像、视频、二进制等文件；
- 除了 GET 命令，还引入了 POST 和 HEAD 命令；
- 使用 **header 的 If-Modified-Since 和 Expires 作为缓存失效的标准**；

  - 但是客户端本地时间被修改会导致响应头 expires 的缓存机制失效的问题；

- http 请求和回应的格式改变，除了数据部分，每次**通信都必须包括头信息（HTTP header**），用来描述一些元数据 (比如: 状态码、权限、缓存、内容编码)；
- 不支持断点续传，每次都会传送全部的页面和数据；
- 通常每台计算机只能绑定一个 IP ,所以请求消息中的 URL 没有传递主机名（hostname）;
- **无法复用连接：**每次发送请求，都需要进行一次tcp连接，网络的利用率非常低；
- **队头阻塞：**

  - HTTP 1.0 规定在前一个请求响应到达之后下一个请求才能发送，如果前一个阻塞，后面的请求也会阻塞的；

  ```javascript
  请求1 > 响应1 --> 请求2 > 响应2 --> 请求3 > 响应3
  ```


## http1.1

1. 新增方法：PUT、PATCH 、OPTIONS、DELETE；
2. 引入了**持久连接**

   - TCP 连接默认不关闭，可以被多个请求复用；
   - 不用声明 Connection：keep-alive，长连接的**时长**可以通过请求头中的 keep-alive 来设置；

3. 新增了 **E-tag、If-Unmodified-Since、If-Match、If-None-Match 等缓存控制标头来控制缓存失效**；
4. 引入管道机制

   - 基于长连接的基础，管道化可以不等第一个请求响应继续发送后面的请求，但响应的顺序还是按照请求的顺序返回；
   - 造成服务端的队头阻塞；

   ```javascript
   请求1 --> 请求2 --> 请求3 > 响应1 --> 响应2 --> 响应3
   ```

5. 支持断点续传

   - 通过使用请求头中的 Range 来实现；

6. 使用了虚拟网络，在一台物理服务器上可以存在多个虚拟主机，并且它们共享一个 IP 地址；

## http1.x 存在的问题

- **无状态：**在传输数据过程中，所有内容都是明文，客户端和服务器端都无法验证对方的身份，无法保证数据的安全性；
- **队头阻塞：**

  - 对于同一个tcp连接，http1.1允许一次发送多个http1.1请求，不必等前一个响应收到，就可以发送下一个请求；
  - **不能控制响应的优先级，必须按照请求顺序响应：**http1.1规定，**服务器端的响应的发送要根据请求被接收的顺序排队**，如果最先收到的请求的处理时间长的话，响应生成也慢，就会阻塞已经生成了的响应的发送；

- 协议规定客户端对同一域的并发连接最多只能2个；
- http/1.x 版本支持 Keep-alive，用此方案来弥补创建多次连接产生的延迟，但是同样会给服务器带来压力，对于单文件被不断请求的服务，Keep-alive会极大影响性能，因为它在文件被请求之后还保持了不必要的连接很长时间；
- **基于文本协议**，请求和响应头信息非常大，并且无法压缩；
- 只能**单向请求，**也就是客户端请求什么，服务器只能返回什么；

## http 2.0

> http2 是超文本传输协议的第二版，相比 http1 协议的文本传输格式，http2 是以二进制的格式进行数据传输的，具有更小的体积以及负载；

- 流：已建立的连接上的双向字节流；
- 消息：与逻辑消息对应的完整的一系列数据帧；
- 帧：http2 通信的最小单位，每个帧包含首部，至少也会标识出当前帧所属的流；

### 二进制分帧

> HTTP 2 采用二进制格式对所有传输的信息分割为更小的消息和帧，并对它们采用二进制格式的编码，提高传输效率；

区别于之前的纯文本明文传输，不方便计算机解析，存在空格或其他字符，很难判断消息的起始和结束；

这时报文的头信息和数据体都是二进制，并且统称为帧（frame），区分为**头信息帧（Headers Frame）和数据帧（Data Frame）**。

在传输的过程中，就是一堆乱序的二进制帧，不存在先后关系，也不需要排队，解决了 HTTP 队头阻塞的问题；

对于乱序的二进制帧，是如何组装成对应的报文的：

1. 乱序指的是不同 ID 的 Stream 是乱序的，对于同一个 Stream ID 的帧是按顺序传输的；
2. 接收方收到二进制帧后，将相同的 Stream ID（帧首部的流标识）—— 按顺序组装成完整的请求/响应报文；
3. 二进制帧中有一些字段，控制着优先级和流量控制等功能，就可以设置数据帧的优先级，让服务器处理重要资源，优化用户体验；

### 多路复用

> 复用TCP连接，在一个连接里，客户端和浏览器都可以同时发送多个请求或回应，且不用按顺序一一对应；

1. 同域名下所有通信都在单个连接上完成；
2. 单个连接可以承载任意数量的双向数据流；
3. 数据流以消息的形式发送【参考二进制分帧】

### 优先级和依赖关系

每个流都包含一个优先级，它用来告诉对端哪个流更重要，当资源有限的时候，服务器会根据优先级来选择应该先发送哪些流；

借助 PRIORITY 帧，客户端可以告知服务器当前流依赖于其它哪个流，该功能能让客户端建立一个优先级“树”，所有“子流”会依赖于“父流”的传输完成情况；

优先级和依赖关系可以在传输过程中被动态的改变。这样当用户滚动一个全是图片的页面的时候，浏览器就能够指定哪个图片拥有更高的优先级。或者是在你切换标签页的时候，浏览器可以提升新切换到页面所包含流的优先级。

### 头部压缩

因为 http 协议本身是无状态的，所以每个请求之前互不关联，每个请求都需要携带服务器所需要的信息；

在 http2 之前一般使用 Set-Cookie，服务器 session 等方式模拟出状态，但是这样的缺点就是每个请求都要携带大量的重复信息并且无法压缩，这是一个巨大的带宽浪费；

http2 增加了两个特性解决上面的问题：

- **HPACK算法**：专门为头部压缩设计的算法，就是在客户端和服务器同时维护一张头信息表，所有字段都会在入这个表，并且生成一个索引表，这样以后就不发送同样字段了，只发送索引号，所以就提高了速度
- **首部表：**

  1. http2 在客户端和服务器端使用“首部表”来跟踪和存储之前发送的键值对，对于相同的数据，不再通过每次请求和响应再次发送；
  2. 通信期间几乎不会改变的通用键值对（用户代理、可接受的媒体类型等）只需要发送一次；
  3. 对于之前出现过的头部信息，在传输的时候，不再是传输对应的头部信息了，而是传递索引，对方拿到索引查表就可以了；
  4. 如果首部发生变化，那么只需要发送变化数据在 Headers 帧里面，新增或者修改的首部帧会被追加到“首部表”；


### 服务器推送

> 浏览器发送一个请求，服务器主动向浏览器推送与这个请求相关的资源，这样浏览器就不用发起后续请求；

1. 推送资源可以由不同页面共享；
2. 服务器可以按照优先级推送资源；
3. 客户端可以缓存推送的资源；
4. 客户端可以拒收推送过来的资源，如果不需要的话，客户端可以发送一个 RST_STREAM 帧来中止推送；

### 可重置消息

在 http1.x 中有一个问题：当一个含有确切值的 Content-lengt 的 http 消息被送出之后，就很难中断它了，通常可以断开整个TCP 连接，但是这样导致的代价就是需要通过三次握手来重新建立一个新的 TCP 连接；

在 http2 里，可以通过发送 RST_STRWAM 帧来实现这个需求，从而避免浪费带宽和中断已有的连接；

### 流量控制

每个 http2 流都拥有自己的公示的流量窗口，它可以限制另一端发送数据；  
对于每个流来说，两端都必须告诉对方自己还有足够的空间来处理新的数据，而在窗口被放大前，另一端只被允许发送这么多数据；  
只有数据帧会受到流量控制；

### 优势

1. **头部压缩**：更小的传输体积，更小或者省略重复的头消息；
2. **并发传输**：突破原有的 TCP 连接并发限制，使用一个 TCP 连接即可实现多请求并发，单连接也能减轻服务端的压力（更少的内存和CPU使用）；
3. 解决 HOLB 线头问题，慢的请求或者先发送的请求不会阻塞其它的请求返回；
4. 结合 CDN 提供实时性更高，延迟更低的内容分发代理服务，大大减少白屏时间；
5. 数据传输优先级可控，使网站可以实现更灵活和强大的页面控制；
6. 能在不中断 TCP 连接的情况下停止（重置）数据的发送；

## 请求方法

- HTTP1.0 定义了三种请求方法：GET、POST 和 HEAD 方法；
- HTTP1.1 新增了五种请求方法：OPTIONS、PUT、DELETE、TRACE 和 CONNECT；

1. GET 方法：发送一个请求来获取服务器上的某些资源；
2. POST 方法：向 URL 指定的资源提交数据或者附加新的数据；
3. PUT 方法：和 POST 方法一样，可以向服务器提交数据，但是也有不同， PUT 指定了资源在服务器的位置，POST 没有；
4. HEAD 方法：请求获取由Request-URI所标识的资源的响应消息报头；
5. DELETE 方法：删除服务器上的某些资源；
6. OPTIONS 方法：用在跨域请求，它用于获取当前 URL 所支持的方法，如果请求成功，在 Allow 的头包含类似 GET , POST 等信息；
7. TRACE 方法：请求服务器回送收到的请求信息，主要用于测试或诊断；
8. CONNECT 方法：建立连接隧道，用于代理服务器；

### GET&POST

1. 本质上，GET 用于获取资源，POST 用于提交资源；
2. 从缓存角度，GET 请求后浏览器会主动缓存，POST 默认情况下不能；
3. 从参数角度，GET 请求一般放在 URL 中，POST 请求放在请求体中，相对 安全，对于抓包情况下一样；
4. 从编码角度，GET 请求只能经行 URL 编码，只能接受 ASCII 码，而 POST 支持更多的编码类型且不对数据类型限值；
5. GET 请求幂等，POST 请求不幂等（幂等指发送 M 和 N 次请求，服务器上的资源状态一致）；
6. GET 请求会一次性发送请求报文，POST 请求通常分为两个TCP 数据包，首先发送 header 部分，如果服务器响应 100 ，然后发送 body 部分；

### OPTIONS 方法

1. OPTIONS 请求与 HEAD 类似，一般也是用于客户端查看服务器的性能；
2. 这个方法会请求服务器返回该资源所支持的所有 HTTP 请求方法，该方法会用 ” *“来代替资源名称，向服务器发送 OPTIONS 请求，可以测试服务器功能是否正常；
3. JS 的 XMLHttpRequest 对象进行 CORS 跨域资源共享时，对于复杂请求，就是使用 OPTIONS 方法发送嗅探请求，以判断是否有对指定资源的访问权限；

## HTTP常见状态码

### 1xx 信息类

1xx 指提示信息，表示目前是协议处理的中间状态（临时响应），还需要后续的操作

| 100（继续）     | 请求者应当继续提出请求。服务器返回此代码表示已收到请求的第一部分，正在等待其余部分。 |
| --------------- | ------------------------------------------------------------------------------------ |
| 101（切换协议） | 请求者已要求服务器切换协议，服务器已确认并准备切换。                                 |

### 2xx 成功

表示成功处理了请求的状态码。

| 200（成功）            | 服务器已成功处理了请求。通常，这表示服务器提供了请求的网页。                                                                |
| ---------------------- | --------------------------------------------------------------------------------------------------------------------------- |
| 201（OK）              | 请求成功并且服务器创建了新的资源                                                                                            |
| 202（已接受）          | 服务器已接受请求，但尚未处理                                                                                                |
| 203（非授权信息）      | 服务器已成功处理了请求，但返回的信息可能来自另一来源                                                                        |
| 204 （No content）     | 请求成功，但没有资源返回，options请求会返回这个                                                                             |
| 205（重置内容）        | 服务器成功处理了请求，但没有返回任何内容。与 204 响应不同，此响应要求请求者重置文档视图（例如，清除表单内容以输入新内容）。 |
| 206（Parital Content） | 表示客户端进行了范围请求，而服务器成功执行了这部分的 GET 请求，响应报文中包含由 [ Content-Range ] 指定范围的实体内容        |

### 3xx 重定向

3xx：重定向，这类状态码表示客户端请求的资源发生了变动，需要客户端用新的 URL 重新发送请求获取资源

| 300（多种选择）           | 针对请求，服务器可执行多种操作。服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择。                                                                                  |
| ------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 301 （Moved permanently） | **永久性重定向**。 请求的网页已永久移动到新位置<br />服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。                                                            |
| 302（Found）              | **临时重定向**，表示资源临时分配了新的 URL                                                                                                                                                  |
| 303（See other）          | 表示服务器要将浏览器重定向到另一个资源，这个资源的 URI 会被写在响应 Header 的 Location 字段；                                                                                               |
| 304 （Not modified）      | **缓存重定向**，表示资源未修改（不具有重定向的意义）， 重定向已存在的缓冲文件，告诉客户端可以继续使用缓存资。<br />当协商缓存命中时， 自从上次请求后，请求的网页未修改过                    |
| 305（使用代理）           | 请求者只能使用代理访问请求的网页                                                                                                                                                            |
| 307（Temporary redirect） | 临时重定向，定义实际上和 302 是一致的，区别在于 307 状态码不允许浏览器将原本为 POST 的请求重定向到 GET 请求上 应继续使用原有位置来响应以后的请求， 以后应继续使用原有位置来响应以后的请求。 |

```javascript
当 301、302、303 响应状态码返回时，几乎所有的浏览器都会把 POST 改成 GET，并删除请求报文内的主体，之后请求会自动再次发送,301、302 标准是禁止将 POST 方法改变成 GET 方法的，但实际使用时大家都会这么做
```

**注意：**

- 301 和 302 都会在响应头里使用字段 `Location`，指明后续要跳转的 URL，浏览器会自动重定向新的 URL。

### 4xx 客户端错误类

4xx 表示客户端错误，请求的报文有误，服务器无法处理

| 状态码                         | 描述                                                                                                                                                    |
| ------------------------------ | ------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 400 （Bad request）            | 笼统错误码，表示请求报文存在语法错误                                                                                                                    |
| 401（Unauthorized）            | 表示发送的请求需要有通过 HTTP 认证的认证信息， 请求要求身份验证。对于登录后请求的网页，服务器可能返回此响应                                             |
| 403（禁止）                    | 表示用户通过了身份验证，但服务器拒绝请求（客户端请求没有出错）                                                                                          |
| 404 （Not found）              | 表示在服务器上没有找到请求的资源或不可用；                                                                                                              |
| 405 （Method Not Allowed）     | 服务器禁止使用该方法，客户端可以通过options方法来查看服务器允许的访问方法；                                                                             |
| 406（不接受）                  | 无法使用请求的内容特性响应请求的网页                                                                                                                    |
| 407（需要代理授权）            | 如果服务器返回此响应，还表示请求者应当使用代理                                                                                                          |
| 408（请求超时）                | 服务器等候请求时发生超时                                                                                                                                |
| 409（冲突）                    | 服务器在完成请求时发生冲突。服务器必须在响应中包含有关冲突的信息。服务器在响应与前一个请求相冲突的 PUT 请求时可能会返回此代码，以及两个请求的差异列表。 |
| 410 （Gone）                   | 表示所请求的资源已经永久删除【 如果资源已永久移动，您应使用 301 指定资源的新位置】                                                                      |
| 411（需要有效长度）            | 服务器不接受不含有效内容长度标头字段的请求                                                                                                              |
| 412（未满足前提条件）          | 服务器未满足请求者在请求中设置的其中一个前提条件                                                                                                        |
| 413（请求实体过大）            | 服务器无法处理请求，因为请求实体过大，超出服务器的处理能力                                                                                              |
| 414（请求的 URI 过长）         | 请求的 URI（通常为网址）过长，服务器无法处理                                                                                                            |
| 415 （Unsupported Media Type） | 表示客户端要求的返回格式不支持，比如API 只能返回 JSON 格式，但是客户端要求返回 XML 格式；                                                               |
| 422 （Unprocessable Entity）   | 表示客户端上传的附件无法处理，导致请求失败                                                                                                              |
| 429 （Too Many Requests）      | 表示客户端的请求次数超过限额                                                                                                                            |

### 5xx 服务器错误

5xx 表示服务器在处理请求时发生内部错误。这些错误可能是服务器本身的错误，而不是请求出错。

| 状态                         | 描述                                                                                                                                           |
| ---------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------- |
| 500 （Internal sever error） | 笼统错误码，表示客户端请求有效，服务器端在执行请求时发生了错误；                                                                               |
| 501（尚未实施）              | 服务器不具备完成请求的功能。例如，服务器无法识别请求方法时可能会返回此代码，有点类似“即将开通”的意思                                           |
| 502 （Bad Gateway）          | 通常是服务器作为网关或代理，从上游服务器收到无效响应，表示服务器自身工作正常，访问后端服务器发生了错误，比如ngix代理的服务挂了                 |
| 503 （Service unavailable）  | 表示服务器暂时**处于超负载或正在停机维护**，无法处理请求，只是暂时状态（类似“当前网络正忙，请稍后再试”，比如服务器在启动中或者端口暂时被占用了 |
| 504（网关超时）              | 服务器作为网关或代理，但是没有及时从上游服务器收到请求                                                                                         |
| 505（HTTP 版本不受支持）     | 服务器不支持请求中所用的 HTTP 协议版本                                                                                                         |

## HTTP 数据传输

### 定长数据

对于定长的数据包而言，发送端在发送数据的过程中，需要设置 Content-length 来指明发送数据的长度；

如果采用了 Gzip 压缩的话， Content-length 设置的就是压缩后的长度；

- Content-length 如果存在并有效的话，则必须和消息内容的传输长度一致，如果过短会截断，过长就会超时；
- 在 HTTP1.0 之前的版本， Content-length 字段可有可无，因为一旦服务器关闭连接，就可以获取到传输数据的长度了；
- 在 HTTP1.1 版本中，如果是 keep-alive 的话， chunked 优先级高于  Content-length ,若是非 keep-alive，和前面情况一样，  Content-length 可有可无；

### 不定长数据

现在采用最多的就是HTTP/1.1版本，来完成传输数据，在保存Keep-alive状态下，当数据是不定长的时候，我们需要设置新的头部字段：

```javascript
Transfer-Encoding: chunked
```

- 如果头部信息中有 Transfer-Encoding: chunked，优先采用  Transfer-Encoding 里面的方法来找到对应的长度；
- 如果设置了 Transfer-Encoding，那么 Content-length 将被忽略；
- 使用长连接的话，会持续的推送动态内容；

## keep-alive

> Keep-Alive 能在多次 HTTP 之前重用同一个 TCP 连接，从而减少创建/关闭多个 TCP 连接的开销；

1. HTTP 协议采用 “请求-应答” 模式，当非 KeepAlive 模式时，每个请求/应答客户端和服务器都要新建一个连接，完成之后立即断开连接；
2. 当使用 KeepAlive 模式（持久连接、连接复用）时，Keep-Alive 功能使客户端到服务端连接持续有效，当出现对服务器的后继请求时，Keep-Alive 功能避免了建立或者重新建立连接；

### 客户端开启

在 HTTP1.0 协议中默认是关闭的，需要在 http 头部加入：

```javascript
Connection: keep-alive
```

HTTP1.1 中默认启用，如果要关闭，需要加入：

````
Connection: close
````

