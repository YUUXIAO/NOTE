## HTTP

> HTTP 是一个在计算机世界里专门在两点之前传输文字、图片、音频、视频等超文本数据的约定和规范；

### 特点

1. 灵活可扩展：
   - 在语法上只规定了基本格式，空格分隔单词，换行分隔字段等；
   - 传输形式上不仅可以传输文本，还可以传输图片、视频等任意数据；
2. 请求-应答模式：一方发送消息，一方接受消息，或者做出响应等；
3. 可靠传输：HTTP 是基于 TCP / IP，因此把这一特性继承了下来；
4. 无状态；

### 缺点

1. 无状态：有时需要保存信息，比如需要保留用户信息等，另外一方面，无状态也会减少网络开销，比如直播等；
2. 明文传输：即协议里的报文（主要指头部）不使用二进制数据，而是文本形式，让 http 报文信息暴露给外部；
3. 队头阻塞：当 http 开启长连接时，共用一个 TCP 连接，当某个请求时间过长的时候，其他请求只能处于阻塞状态；

## http 0.9

1. 只支持 GET 请求方式：由于不支持其他请求方式，因此客户端是没办法向服务端传输太多的信息；
2. 没有请求头概念：所以不能在请求中指定版本号，服务端也只具有返回 HTML字符串的能力；
3. 服务端相响应之后，立即关闭TCP连接；

## http 1.0

1. 扩充了传输内容格式，图片、音视频资源、二进制等都可以进行传输；

2. 除了 GET 命令，还引入了 POST 和 HEAD 命令；

3. 增添了请求头和响应头的概念，在通信中指定了 HTTP 协议版本号，以及其他的一些元信息 (比如: 状态码、权限、缓存、内容编码)；

   ```html
   // 请求头
   GET / HTTP/1.0
   User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_5)
   Accept: */*;

   // 响应头
   HTTP/1.0 200 OK
   Content-Type: text/plain
   Content-Length: 137582
   Expires: Thu, 05 Dec 1997 16:00:00 GMT
   Last-Modified: Wed, 5 August 1996 15:55:28 GMT
   // 这是一个空行
   ...数据内容
   ```

4. 只使用 header 的 If-Modified-Since 和 Expires 作为缓存失效的标准；

5. 不支持断点续传，每次都会传送全部的页面和数据；

6. 通常每台计算机只能绑定一个 IP ,所以请求消息中的 URL 没有传递主机名（hostname）;

7. 无法复用连接：每次发送请求，都需要进行一次tcp连接，网络的利用率非常低；

8. 队头阻塞：HTTP 1.0 规定在前一个请求响应到达之后下一个请求才能发送，如果前一个阻塞，后面的请求也会阻塞的；

   ```
   请求1 > 响应1 --> 请求2 > 响应2 --> 请求3 > 响应3
   ```

## http1.1

1. 长连接

   - TCP 连接默认不关闭，可以被多个请求复用；
   - 不用声明 Connection：keep-alive，长连接的时长可以通过请求头中的 keep-alive 来设置；

2. 引入管道机制

   - 基于长连接的基础，管道化可以不等第一个请求响应继续发送后面的请求，但响应的顺序还是按照请求的顺序返回；

   ```
   请求1 --> 请求2 --> 请求3 > 响应1 --> 响应2 --> 响应3
   ```

3. 支持断点续传

   - 通过使用请求头中的 Range 来实现；

4. 使用了虚拟网络，在一台物理服务器上可以存在多个虚拟主机，并且它们共享一个 IP 地址；

5. 新增了 E-tag、If-Unmodified-Since、If-Match、If-None-Match 等缓存控制标头来控制缓存失效；

6. 新增方法：PUT、PATCH 、OPTIONS、DELETE；

## http1.x 存在的问题

1. 在传输数据过程中，所有内容都是明文，客户端和服务器端都无法验证对方的身份，无法保证数据的安全性；
2. 队头阻塞：HTTP/1.1 版本默认允许复用 TCP 连接，但是在同一个 TCP 连接中，所以通信是串行执行的；
3. 协议规定客户端对同一域的并发连接最多只能2个；
4. http/1.x 版本支持Keep-alive，用此方案来弥补创建多次连接产生的延迟，但是同样会给服务器带来压力，对于单文件被不断请求的服务，Keep-alive会极大影响性能，因为它在文件被请求之后还保持了不必要的连接很长时间；
5. 基于文本协议，请求和响应头信息非常大，并且无法压缩；
6. 不能控制响应的优先级，必须按照请求顺序响应；
7. 只能单向请求，也就是客户端请求什么，服务器只能返回什么；

## http 2.0

> http2 是超文本传输协议的第二版，相比 http1 协议的文本传输格式，http2 是以二进制的格式进行数据传输的，具有更小的体积以及负载；

- 流：已建立的连接上的双向字节流；
- 消息：与逻辑消息对应的完整的一系列数据帧；
- 帧：http2 通信的最小单位，每个帧包含首部，至少也会标识出当前帧所属的流；

### 二进制分帧

>  HTTP 2 采用二进制格式对所有传输的信息分割为更小的消息和帧，并对它们采用二进制格式的编码，提高传输效率；

之前是明文传输，不方便计算机解析，存在空格或其他字符，很难判断消息的起始和结束；

一个报文格式就被拆分一个个二进制帧，用 Headers 帧存放头部， Data 帧存放请求数据；这样就是一堆乱序的二进制帧，它们不存在先后关系，不需要排队，解决了 HTTP 队头阻塞的问题；

对于乱序的二进制帧，是如何组装成对应的报文：

1. 乱序指的是不同 ID 的 Stream 是乱序的，对于同一个 Stream ID 的帧是按顺序传输的；
2. 接收方收到二进制帧后，将相同的 Stream ID 组装成完整的请求报文和响应报文；
3. 二进制帧中有一些字段，控制着优先级和流量控制等功能，就可以设置数据帧的优先级，让服务器处理重要资源，优化用户体验；

### 多路复用

在共享TCP链接的基础上同时发送请求和响应，基于二进制分帧，在同一域名下所有访问都是从同一个tcp连接中走，http消息被分解为独立的帧，乱序发送，服务端根据标识符和首部将消息重新组装起来；

1. 同域名下所有通信都在单个连接上完成；
2. 单个连接可以承载任意数量的双向数据流；
3. 数据流以消息的形式发送，消息由一个或多个帧组成，多个帧之间可以乱序发送，因为根据帧首部的流标识可以重新组装，也就是 Stream ID，这样接收方就能从乱序的二进制帧中选择 ID 相同的帧，按照顺序组装成请求/响应报文；

### 优先级和依赖关系 

每个流都包含一个优先级，它用来告诉对端哪个流更重要，当资源有限的时候，服务器会根据优先级来选择应该先发送哪些流；

借助 PRIORITY 帧，客户端可以告知服务器当前流依赖于其它哪个流，该功能能让客户端建立一个优先级“树”，所有“子流”会依赖于“父流”的传输完成情况；

优先级和依赖关系可以在传输过程中被动态的改变。这样当用户滚动一个全是图片的页面的时候，浏览器就能够指定哪个图片拥有更高的优先级。或者是在你切换标签页的时候，浏览器可以提升新切换到页面所包含流的优先级。

### 头部压缩

因为 http 协议本身是无状态的，所以每个请求之前互不关联，每个请求都需要携带服务器所需要的信息；

在 http2 之前一般使用 Cookie 头，服务器 session 等方式模拟出状态，但是这样的缺点就是每个请求都要携带大量的重复信息并且无法压缩，这是一个巨大的带宽浪费；

http2 增加了两个特性解决上面的问题：

- HPACK：专门为头部压缩设计的算法，还被指定成单独的草案中；

- 首部表：

  1. http2 在客户端和服务器端使用“首部表”来跟踪和存储之前发送的键值对，对于相同的数据，不再通过每次请求和响应再次发送；
  2. 通信期间几乎不会改变的通用键值对（用户代理、可接受的媒体类型等）只需要发送一次；
  3. 对于之前出现过的头部信息，在传输的时候，不再是传输对应的头部信息了，而是传递索引，对方拿到索引查表就可以了；
  4. 如果首部发生变化，那么只需要发送变化数据在 Headers 帧里面，新增或者修改的首部帧会被追加到“首部表”；

  ![header-table](https://user-gold-cdn.xitu.io/2018/4/10/162b00acb5991f30?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

### 服务器推送

> 浏览器发送一个请求，服务器主动向浏览器推送与这个请求相关的资源，这样浏览器就不用发起后续请求；

相较 http1.1 的优势：

1. 推送资源可以由不同页面共享；
2. 服务器可以按照优先级推送资源；
3. 客户端可以缓存推送的资源；
4. 客户端可以拒收推送过来的资源，如果不需要的话，客户端可以发送一个 RST_STREAM 帧来中止推送；

### 可重置消息

在 http1.x 中有一个问题：当一个含有确切值的 Content-lengt 的 http 消息被送出之后，就很难中断它了，通常可以断开整个TCP 连接，但是这样导致的代价就是需要通过三次握手来重新建立一个新的 TCP 连接；

在 http2 里，可以通过发送 RST_STRWAM 帧来实现这个需求，从而避免浪费带宽和中断已有的连接；

### 流量控制

每个 http2 流都拥有自己的公示的流量窗口，它可以限制另一端发送数据；
对于每个流来说，两端都必须告诉对方自己还有足够的空间来处理新的数据，而在窗口被放大前，另一端只被允许发送这么多数据；
只有数据帧会受到流量控制；

### 优势

1. 更小的传输体积，更小或者省略重复的头消息；
2. 突破原有的 TCP 连接并发限制，使用一个 TCP 连接即可实现多请求并发，单连接也能减轻服务端的压力（更少的内存和CPU使用）；
3. 解决 HOLB 线头问题，慢的请求或者先发送的请求不会阻塞其它的请求返回；
4. 结合 CDN 提供实时性更高，延迟更低的内容分发代理服务，大大减少白屏时间；
5. 数据传输优先级可控，使网站可以实现更灵活和强大的页面控制；
6. 能在不中断 TCP 连接的情况下停止（重置）数据的发送；

## 请求方法

- HTTP1.0 定义了三种请求方法：GET、POST 和 HEAD 方法；
- HTTP1.1 新增了五种请求方法：OPTIONS、PUT、DELETE、TRACE 和 CONNECT；

1.  GET 方法：发送一个请求来获取服务器上的某些资源；
2.  POST 方法：向 URL 指定的资源提交数据或者附加新的数据；
3.  PUT 方法：和 POST 方法一样，可以向服务器提交数据，但是也有不同， PUT 指定了资源在服务器的位置，POST 没有；
4.  HEAD 方法：请求获取由Request-URI所标识的资源的响应消息报头；
5.  DELETE 方法：删除服务器上的某些资源；
6.  OPTIONS 方法：它用于获取当前 URL 所支持的方法，如果请求成功，在 Allow 的头包含类似 GET , POST 等信息，用来跨域请求；
7.  TRACE 方法：请求服务器回送收到的请求信息，主要用于测试或诊断；
8.  CONNECT 方法：建立连接隧道，用于代理服务器；


### GET&POST 

1. 本质上，GET 用于获取资源，POST 用于提交资源；
2. 从缓存角度，GET 请求后浏览器会主动缓存，POST 默认情况下不能；
3. 从参数角度，GET 请求一般放在 URL 中，POST 请求放在请求体中，相对 安全，对于抓包情况下一样；
4. 从编码角度，GET 请求只能经行 URL 编码，只能接受 ASCII 码，而 POST 支持更多的编码类型且不对数据类型限值；
5. GET 请求幂等，POST 请求不幂等（幂等指发送 M 和 N 次请求，服务器上的资源状态一致）；
6. GET 请求会一次性发送请求报文，POST 请求通常分为两个  TCP 数据包，首先发送 header 部分，如果服务器响应 100 ，然后发送 body 部分；

### OPTIONS 方法

1. OPTIONS 请求与 HEAD 类似，一般也是用于客户端查看服务器的性能；
2. 这个方法会请求服务器返回该资源所支持的所有 HTTP 请求方法，该方法会用 ” *“来代替资源名称，向服务器发送 OPTIONS 请求，可以测试服务器功能是否正常；
3. JS 的 XMLHttpRequest 对象进行 CORS 跨域资源共享时，对于复杂请求，就是使用 OPTIONS 方法发送嗅探请求，以判断是否有对指定资源的访问权限；

## HTTP 常见状态码

### 1xx 信息类

> [ 1xx ] 表示接受的请求正在处理，信息类状态码；

### 2xx 成功

- 200 OK：表示从客户端发来的请求在服务器端被正确请求；
- 204 No content：表示请求成功，但没有资源返回；
- 206 Parital Content：表示客户端进行了范围请求，而服务器成功执行了这部分的 GET 请求，响应报文中包含由 [ Content-Range ] 指定范围的实体内容；

### 3xx 重定向

- 301 Moved permanently：永久性重定向，表示资源已经被分配了新的 URL ，此时应该按 Location 首部字段提示的 URI 重新保存；
- 302 Found：临时重定向，表示资源临时分配了新的 URL；
- 303 See other：表示资源存在另一个 URL，应使用 GET 方法获取资源；
- 304 Not modified：当协商缓存命中时会返回这个状态码；
- 307 Temporary redirect：临时重定向，不会改变 method；

```javascript
当 301、302、303 响应状态码返回时，几乎所有的浏览器都会把 POST 改成 GET，并删除请求报文内的主体，之后请求会自动再次发送,301、302 标准是禁止将 POST 方法改变成 GET 方法的，但实际使用时大家都会这么做
```

### 4xx 客户端错误 

- 400 Bad request：表示请求报文存在语法错误；
- 401 Unauthorized：表示发送的请求需要有通过 HTTP 认证的认证信息；
- 403 Not found：表示用户通过了身份验证，但不具有访问资源所需的权限；
- 404 Not found：表示在服务器上没有找到请求的资源或不可用；
- 405 Method Not Allowed：表示用户已经通过身份验证，但是所用的 HTTP 方法不在他的权限之内，客户端可以通过 options 方法来查看服务器允许的方法；
- 410 Gone：表示所请求的资源已经从这个地址转移，不再可用；
- 415 Unsupported Media Type：表示客户端要求的返回格式不支持，比如API 只能返回 JSON 格式，但是客户端要求返回 XML 格式；
- 422 Unprocessable Entity：表示客户端上传的附件无法处理，导致请求失败；
- 429 Too Many Requests：表示客户端的请求次数超过限额；

### 5xx 服务器错误

- 500 Internal sever error：表示客户端请求有效，服务器端在执行请求时发生了错误；
- 502 Bad Gateway：服务器是正常的，访问的时候出了问题，具体啥错误也不知道；
- 503 Service unavailable：表示服务器暂时处于超负载或正在停机维护，无法处理请求；

## HTTP 数据传输

### 定长数据

对于定长的数据包而言，发送端在发送数据的过程中，需要设置 Content-length 来指明发送数据的长度；

如果采用了 Gzip 压缩的话， Content-length 设置的就是压缩后的长度；

-  Content-length 如果存在并有效的话，则必须和消息内容的传输长度一致，如果过短会截断，过长就会超时；
-  如果采用短链接的话，直接可以通过服务器关闭连接来确定消息的传输长度；
-  在 HTTP1.0 之前的版本， Content-length 字段可有可无，因为一旦服务器关闭连接，就可以获取到传输数据的长度了；
-  在 HTTP1.1 版本中，如果是 keep-alive 的话， chunked 优先级高于  Content-length ,若是非 keep-alive，和前面情况一样，  Content-length 可有可无；

### 不定长数据

现在采用最多的就是HTTP/1.1版本，来完成传输数据，在保存Keep-alive状态下，当数据是不定长的时候，我们需要设置新的头部字段：

```javascript
Transfer-Encoding: chunked
```

- 如果头部信息中有 Transfer-Encoding: chunked，优先采用  Transfer-Encoding 里面的方法来找到对应的长度；
- 如果设置了 Transfer-Encoding，那么 Content-length 将被忽略；
- 使用长连接的话，会持续的推送动态内容；


## 队头阻塞

> 对于每一个 HTTP 而言，这些任务是放入一个任务队列中串行执行的，一旦队首的任务请求太慢时，就会阻塞后面的请求处理；

### 并发连接

对于一个域名而言，是允许分配多个长连接的，可以理解成增加了任务队列，不会导致一个任务阻塞了该任务队列中的其它任务，Chrome 一般最多并发6个连接；

### 域名分片

我们可以在一个域名下分出多个二级域名出来，它们最终指向同一个服务器，这样子可以并发处理的任务队列更多；

```
例如 TianTian.com，可以分出很多二级域名：Day1.TianTian.com，Day2.TianTian.com , Day3.TianTian.com 
```

## keep-alive

> Keep-Alive 能在多次 HTTP 之前重用同一个 TCP 连接，从而减少创建/关闭多个 TCP 连接的开销；

1. HTTP 协议采用 “请求-应答” 模式，当非 KeepAlive 模式时，每个请求/应答客户端和服务器都要新建一个连接，完成之后立即断开连接；
2. 当使用 KeepAlive 模式（持久连接、连接复用）时，Keep-Alive 功能使客户端到服务端连接持续有效，当出现对服务器的后继请求时，Keep-Alive 功能避免了建立或者重新建立连接；

### 客户端开启

在 HTTP1.0 协议中默认是关闭的，需要在 http 头部加入：

```javascript
Connection: keep-alive
```

HTTP1.1 中默认启用，如果要关闭，需要加入：

```
Connection: close
```

## 正向代理&反向代理

### 正向代理

正向代理的过程，它隐藏了真实的请求客户端，服务端不知道真实的客户端是谁，客户端请求的服务都被代理服务器代替来请求；

### 反向代理

反向代理的过程，它隐藏了真实的服务端，当我们向一个网站发起请求时，背后可能有成千上万台服务器为我们服务，我们不清楚具体是哪一台，但我们只需要知道反向代理服务器是谁就行，而且反向代理服务器会帮我们把请求转发到真实的服务器那里去，一般而言反向代理服务器用来实现负载均衡；

## 负载均衡的实现方式

### 反向代理

使用反向代理的方式，用户的请求都发送到反向代理服务器上，然后由反向代理服务器来转发请求到真实的服务器上，以此来实现集群的负载均衡；

### DNS

DNS 可以用在冗余的服务器上实现负载均衡，因为一般大型的网站使用多台服务器提供服务，因此一个域名可能会对应多个服务器地址，当用户向网站域名请求的时候，DNS 服务器会返回这个域名所对应的服务器 IP 地址的集合，在每个回答中，会循环这些 IP 地址的顺序，用户一般会选择排序在前面的地址发送请求，以此将用户的请求均衡的分配到各个不同的服务器上，这样来实现负载均衡；

这种方式有一个缺点，由于 DNS 服务器中存在缓存，所以有可能一个服务器出现 故障后，域名解析仍然返回的是那个 IP 地址，就会造成访问的问题；