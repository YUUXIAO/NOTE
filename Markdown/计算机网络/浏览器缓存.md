## 缓存机制

1. 首先检查 Cache-Control，看看强缓存是否可用；
2. 如果可用，直接使用；
3. 否则进入协商缓存，发送 HTTP 请求，服务器通过请求头中的 If-Modified-Since 或者 If-None-Match字段检查资源是否更新 ；
4. 资源更新，返回资源和 200 状态码；
5. 否则，返回304，直接告诉浏览器从缓存中取资源；

## 强缓存

1. 强缓存分为两种情况：发送 HTTP 请求 和 不需要发送；
2. 强缓存两个相关的字段：Expires 和 Cache-Control；
   - HTTP1.0版本，使用的是 Expires；
   - HTTP1.1使用的是Cache-Control；
   - 当 Expires 和 Cache-Control 同时存在时，优先考虑 Cache-Control；

### Expires

> Expires 即过期时间，时间是相对于服务器的时间而言的，存在于服务端返回的响应头中，在这个过期时间之前可以直接从缓存里面获取数据，无需再次请求；

```javascript
Expires:Mon, 29 Jun 2020 11:10:23 GMT
```

该资源在2020年7月29日11:10:23过期，过期就会重新向服务器发起请求；

这个方式有一个问题：服务器的时间和浏览器的时间可能并不一致，所以HTTP1.1 提出新的字段代替它；

### Cache-Control

> Cache-Control 是过期时长，对应的是 max-age；

```javascript
// 资源返回后6000秒，可以直接使用缓存
Cache-Control:max-age=6000
```

1. max-age：用来设置资源可以被缓存多长时间，单位为秒；
2. s-maxage：和max-age是一样的，不过它只针对代理服务器缓存而言；
3. no-cache：强制客户端直接向服务器发送请求，每次请求都必须向服务器发送，服务器接收到请求后判断资源是否变更，是则返回新内容，否则返回304；
4. no-store：禁止一切缓存；
5. private：只能针对个人用户，而不能被代理服务器缓存；
6. public：指示响应可被任何缓存区缓存；

## 协商缓存

强缓存失效后，浏览器在请求头中携带响应的缓存 Tag 向服务器发送请求，服务器根据对应的 Tag ，来决定是否使用缓存；

### Last-Modified

> Last-Modified 是响应头字段用来标识资源的有效性；

1. Last-Modified 表示的是最后修改时间，在浏览器第一次给服务器发送请求后，服务器会在响应头中加上这个字段；
2. 浏览器接收到后，如果再次请求，会在请求头中携带 If-Modified-Since字段，这个字段表示服务器传来的最后修改时间；
3. 服务器拿到请求头中的 If-Modified-Since 的字段后，和这个服务器中该资源的最后修改时间对比：
   - 如果请求头中的这个值小于最后修改时间，说明是时候更新了，返回新的资源；
   - 否则返回304，告诉浏览器直接使用缓存；

### Etag

> Etag 是响应头字段表示资源的版本；

Etag 是服务器根据当前文件的内容，对文件生成唯一的标识，比如MD5算法，只要里面的内容有改动，这个值就会修改；

1. 浏览器在发送请求时会带 If-None-Match 字段来询问服务器该版本是否可用；
2. 服务器接收到 If-None-Match 后，会跟服务器上该资源的 ETag 进行比对：
   - 如果两者一样的话，直接返回304，告诉浏览器直接使用缓存；
   - 如果不一样的话，说明内容更新了，返回新的资源；

### 两者对比

1. 性能上，Last-Modified 优于 ETag，Last-Modified 记录的是时间点，而Etag需要根据文件的 MD5 算法生成对应的 hash 值；
2. 精度上，ETag 优于 Last-Modified：ETag 按照内容给资源带上标识，能准确感知资源变化，Last-Modified 某些场景并不能准确感知变化：
  - 编辑了资源文件，但是文件内容并没有更改，也会造成缓存失效；
  - Last-Modified 能够感知的单位时间是秒，如果文件在 1 秒内改变了多次，那么这时候的 Last-Modified 并没有体现出修改了；
3. 如果两种方式都支持的话，服务器会优先考虑 ETag；

## 缓存位置

浏览器默认的缓存是放在内存中的，但是内存里的缓存会因为进程的结束或浏览器的关闭而被清除，存在硬盘里的缓存才能被长期保留下去；

浏览器缓存的位置的话，优先级从高到低排列分别：

### Service Worker

这个应用场景比如 PWA，它借鉴了Web Worker思路，由于它脱离了浏览器的窗体，因此无法直接访问DOM；

它能完成的功能比如：离线缓存、消息推送和网络代理，其中离线缓存就是 Service Worker Cache；

### Memory Cache

指的是内存缓存，从效率上讲它是最快的，从存活时间来讲又是最短的，当渲染进程结束后，内存缓存也就不存在了；

### Disk Cache

存储在磁盘中的缓存，从存取效率上讲是比内存缓存慢的，优势在于存储容量和存储时长；

在浏览器接收到服务器响应后，会检测响应头部，如果有 Etag 字段，那么浏览器就会将本次缓存写入硬盘；

### Push Cache

推送缓存，它是HTTP/2的内容；

### Disk Cache & Memory Cache

- 内容使用率高的话，文件优先进入磁盘；
- 比较大的JS，CSS文件会直接放入磁盘，反之放入内存；

