## 浏览器缓存

1. 首先检查Cache-Control，看看强缓存是否可用；
2. 如果可用，直接使用；
3. 否则进入协商缓存，发送HTTP请求，服务器通过请求头中的 If-Modified-Since 或者 If-None-Match字段检查资源是否更新 ；
4. 资源更新，返回资源和200状态码；
5. 否则，返回304，直接告诉浏览器从缓存中取资源；

### 强缓存

- 强缓存两个相关的字段：Expires 和 Cache-Control；
- 强缓存分为两种情况：发送HTTP请求 和 不需要发送；
- HTTP1.0版本，使用的是Expires，HTTP1.1使用的是Cache-Control；

首先检查强缓存，这个阶段不需要发送HTTP请求，通过查找不同的字段来进行，不同的HTTP版本所以不同；

#### Expires

> Expires即过期时间，时间是相对于服务器的时间而言的，存在于服务端返回的响应头中，在这个过期时间之前可以直接从缓存里面获取数据，无需再次请求

```javascript
Expires:Mon, 29 Jun 2020 11:10:23 GMT
```

该资源在2020年7月29日11:10:23过期，过期就会重新向服务器发起请求；

这个方式有一个问题：服务器的时间和浏览器的时间可能并不一致，所以HTTP1.1提出新的字段代替它；

#### Cache-Control

> Cache-Control是过期时长，对应的是max-age；

```javascript
Cache-Control:max-age=6000
```

上面代表该资源返回后6000秒，可以直接使用缓存；

**注意：**

1. 当Expires和Cache-Control同时存在时，优先考虑Cache-Control；
2. 当缓存资源失效了，也就是没有命中强缓存，就进入协商缓存；

### 协商缓存

强缓存失效后，浏览器在请求头中携带响应的缓存Tag来向服务器发送请求，服务器根据对应的tag，来决定是否使用缓存。

#### Last-Modified

1. Last-Modified表示的是最后修改时间，在浏览器第一次给服务器发送请求后，服务器会在响应头中加上这个字段；
2. 浏览器接收到后，如果再次请求，会在请求头中携带If-Modified-Since字段，这个字段的值也就是服务器传来的最后修改时间；
3. 服务器拿到请求头中的If-Modified-Since的字段后，其实会和这个服务器中该资源的最后修改时间对比：
   - 如果请求头中的这个值小于最后修改时间，说明是时候更新了。返回新的资源，跟常规的HTTP请求响应的流程一样；
   - 否则返回304，告诉浏览器直接使用缓存；

#### ETag

> ETag是服务器根据当前文件的内容，对文件生成唯一的标识，比如MD5算法，只要里面的内容有改动，这个值就会修改，服务器通过把响应头把该字段给浏览器。

1. 浏览器接受到 ETag 值，会在下次请求的时候，将这个值作为 If-None-Match 这个字段的内容，发给服务器。
2. 服务器接收到 If-None-Match 后，会跟服务器上该资源的 ETag 进行比对：
   - 如果两者一样的话，直接返回304，告诉浏览器直接使用缓存；
   - 如果不一样的话，说明内容更新了，返回新的资源，跟常规的HTTP请求响应的流程一样；

#### 两者对比

1. 性能上，Last-Modified 优于 ETag，Last-Modified 记录的是时间点，而Etag需要根据文件的MD5算法生成对应的hash值。
2. 精度上，ETag 优于 Last-Modified 。ETag 按照内容给资源带上标识，能准确感知资源变化，Last-Modified 某些场景并不能准确感知变化：
  - 编辑了资源文件，但是文件内容并没有更改，也会造成缓存失效；
  - Last-Modified 能够感知的单位时间是秒，如果文件在 1 秒内改变了多次，那么这时候的 Last-Modified 并没有体现出修改了；
3. 如果两种方式都支持的话，服务器会优先考虑 ETag；

### 缓存位置

浏览器默认的缓存是放在内存中的，但是内存里的缓存会因为进程的结束或浏览器的关闭而被清除，存在硬盘里的缓存才能被长期保留下去；

浏览器缓存的位置的话，可以分为四种,优先级从高到低排列分别：

#### Service Worker

这个应用场景比如 PWA，它借鉴了Web Worker思路，由于它脱离了浏览器的窗体，因此无法直接访问DOM；

它能完成的功能比如：离线缓存、消息推送和网络代理，其中离线缓存就是 Service Worker Cache；

#### Memory Cache

指的是内存缓存，从效率上讲它是最快的，从存活时间来讲又是最短的，当渲染进程结束后，内存缓存也就不存在了；

#### Disk Cache

存储在磁盘中的缓存，从存取效率上讲是比内存缓存慢的，优势在于存储容量和存储时长；

在浏览器接收到服务器响应后，会检测响应头部，如果有 Etag 字段，那么浏览器就会将本次缓存写入硬盘；

#### Push Cache

推送缓存，这算是浏览器中最后一道防线吧，它是HTTP/2的内容

#### Disk Cache VS Memory Cache

- 内容使用率高的话，文件优先进入磁盘
- 比较大的JS，CSS文件会直接放入磁盘，反之放入内存

