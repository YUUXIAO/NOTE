## 浏览器的主要组成部分

1. 用户界面：地址栏、前进/后退按钮、书签菜单等
2. 浏览器引擎：在用户界面和呈现引擎之间传送指令
3. 呈现引擎：负责显现请求的内容，如果请求的内容是HTML，它就是负责解析HTML和CSS的内容，并将解析后的内容显示在屏幕上
4. 网络：用于网络调用，比如HTTP请求
5. 用户界面后端：用于绘制基本的窗口小部件，比如组合框和窗口
6. Javascript解释器：用于解析和执行Javascript代码 
7. 数据存储：这是持久层；浏览器需要在硬盘上保存各种数据，例如Cookie

## 输入URL到页面呈现发生了什么

1. 构建请求：浏览器构建请求行信息，构建好后，浏览器准备发起网络请求

   ```
   GET / HTTP1.1
   GET是请求方法，路径就是根路径，HTTP协议版本1.1
   ```

2. 查找缓存：在真正发起网络请求之前，浏览器会先在浏览器缓存中查询是否有要请求的文件；先检查强缓存，如果命中直接使用，否则进入下一步

3. DNS解析：输入的是域名的话，需要根据域名去获取对应的ip地址；这个过程依赖一个服务系统，叫做DNS域名解析，从查找到获取到具体IP的过程叫做DNS解析；浏览器提供了DNS数据缓存功能；

   1. 首先查看是否有对应的域名缓存，有的话直接用缓存的IP访问

   2. 如果缓存中没有，则去查找hosts文件

   3. 如果hosts文件里没有找到想解析的域名，则将域名发往自己配置的dns服务器，也叫本地dns服务器

   4. 如果本地dns服务器有相应域名的记录，则返回记录

      > 电脑的dns服务器一般是各大运营商如电信联通提供的，或者像180.76.76.76，223.5.5.5，4个114等知名dns服务商提供的，本身缓存了大量的常见域名的ip，所以常见的网站，都是有记录的。不需要找根服务器。

   5. 如果电脑自己的服务器没有记录，会去找根服务器。根服务器全球只有13组，会去找其中之一,找了根服务器后，根服务器会根据请求的域名，返回对应的“顶级域名服务器”

      1. 如果请求的域名是[xxx.com](https://link.zhihu.com/?target=http%3A//xxx.com)，则返回负责com域的服务器
      2. 如果是[xxx.cn](https://link.zhihu.com/?target=http%3A//xxx.cn)，则发给负责cn域的服务器
      3. 如果是[xxx.ca](https://link.zhihu.com/?target=http%3A//xxx.ca)，则发给负责ca域的服务器

   6. 顶级域服务器收到请求，会返回二级域服务器的地址：比如一个网址是`www.xxx.edu.cn`，则顶级域名服务器再转发给负责`.edu.cn`域的二级服务器

   7. 以此类推，最终会发到负责锁查询域名的，最精确的那台dns，可以得到查询结果

   8. 本地dns服务器，把最终的解析结果，返回给客户端

4. 建立TCP连接

   - 通过三次握手建立客户端和服务器之前的连接
   - 进行数据传输
   - 通过四次挥手来断开连接

5. 发送HTTP请求

6. 渲染阶段 

## CSS加载会造成阻塞吗

> CSS不会阻塞DOM解析，但是会阻塞DOM渲染
>
> CSS会阻塞JS执行，并不会阻塞JS文件下载

- DOM和CSSOM是并行构建的，所以**CSS 加载不会阻塞 DOM 的解析**
- 由于render Tree是依赖DOM Tree和 CSSOM Tree的，所以它必须等到两者都加载完毕之后，完成相应的构建才开始渲染，所以**CSS加载会阻塞DOM渲染**
- 由于JS是可操纵DOM和CSS样式的，如果在修改这些元素属性同时渲染界面，那么渲染后线程前后获得的元素数据就可能不一致的，因此为了防止渲染出现 不可预期的结果，浏览器设置**GUI 渲染线程与 JavaScript 引擎为互斥**的关系
- 有时候JS需要等到CSS的下载：如果脚本的内容是获取元素的样式，宽高等CSS的属性，浏览器是需要计算的，也就是依赖于CSS。浏览器也无法感知脚本内容到底是什么，为避免样式获取，因而只好等前面所有的样式下载完后，再执行JS。
- JS文件下载和CSS文件下载是并行的，有时候CSS文件很大，所以JS需要等待。因此,样式表会在后面的 js 执行前先加载执行完毕,所以**css 会阻塞后面 js 的执行**。

CSSOM作用：

1. 提供给javascript操作样式表的能力
2. 为布局树的合成提供基础的样式信息
3. CSSOM体现在DOM中就是document.styleSheets

## 为什么JS会阻塞页面加载

> 因为JS阻塞DOM解析，也就会阻塞页面；

- 由于 JavaScript 是可操纵 DOM 的,如果在修改这些元素属性同时渲染界面（即 JavaScript 线程和 UI 线程同时运行）,那么渲染线程前后获得的元素数据就可能不一致了
- 当 JavaScript 引擎执行时 GUI 线程会被挂起,GUI 更新会被保存在一个队列中等到引擎线程空闲时立即被执行
- 当浏览器在执行 JavaScript 程序的时候,GUI 渲染线程会被保存在一个队列中,直到 JS 程序执行完成,才会接着执行
- 因此如果 JS 执行的时间过长,这样就会造成页面的渲染不连贯,导致页面渲染加载阻塞的感觉
- 如果 JavaScript 文件中没有操作 DOM 相关代码，就可以将该 JavaScript 脚本设置为异步加载，通过 async 或 defer 来标记代码

## defer 和 async 的区别 

- 两者都是异步去加载外部JS文件，不会阻塞DOM解析
- Async是在外部JS加载完成后，浏览器空闲时，Load事件触发前执行，标记为async的脚本并不保证按照指定他们的先后顺序执行，该属性对于内联脚本无作用 (即没有src属性的脚本）
- defer是在JS加载完成后，整个文档解析完成后，触发 DOMContentLoaded事件前执行，该属性对于内联脚本无作用 (即没有src属性的脚本）

## DOMContentLoaded 与 load

- DOMContentLoaded事件触发时：仅当DOM解析完成后，不包括样式表、图片等资源
- onload事件触发时，页面上所有的Dom,样式，脚本，图片等资源已经加载完毕

> 在Jquery中，（document）.read（callback）监听的就是DOMContentLoaded事件
>
> （document）.load（callback）监听的就是load事件

#### 与async和defer区别

> 带async的脚本一定会在load事件之前执行，可能会在DOMContentLoaded事件之前或之后执行；

- 情况1：HTML还没有被解析完时，async脚本已经加载完了，那么HTML停止解析，去执行脚本，脚本执行完毕后触发DOMContentLoaded事件
- 情况2： HTML 解析完了之后，async脚本才加载完，然后再执行脚本，那么在HTML解析完毕、async脚本还没加载完的时候就触发DOMContentLoaded事件

> 如果script标签中包含defer，那么这一块脚本不会影响HTML文档的解析，而是等到HTML解析完成后才会执行；而DOMContentLoaded只有在defer脚本执行结束后才会被触发。

- 情况1：HTML还没解析完成时，defer脚本已经加载完毕，那么defer脚本将等待HTML解析完成后再执行。defer脚本执行完毕后触发DOMContentLoaded事件
- 情况2：HTML解析完成时，defer脚本还没加载完毕，那么defer脚本继续加载，加载完成后直接执行，执行完毕后触发DOMContentLoaded事件

## 为什么CSS动画比JavaScript高效

如果非要去操作JS实现动画的话，有哪些优化的手段呢：

- 使用`createDocumentFragment`进行批量的 DOM 操作
- 对于 resize、scroll 等进行防抖/节流处理。
- rAF优化等等

## requestAnimationFrame（rAF）

> window.requestAnimationFrame() 方法告诉浏览器您希望执行动画并请求浏览器在下一次重绘之前调用指定的函数来更新动画。该方法使用一个回调函数作为参数，这个回调函数会在浏览器重绘之前调用。

如果 JavaScript 方法需要绘制或者直接改变属性,选择 `requestAnimationFrame`，只要涉及到重新计算元素位置，就可以使用它。

涉及到 AJAX 请求，添加/移除 class （可以触发 CSS 动画），我会选择 `_.debounce` 或者 `_.throttle` ，可以设置更低的执行频率（例子中的200ms 换成16ms）

#### 优点

- rAF(requestAnimationFrame) 最大的优势是由系统来决定回调函数的执行时机：系统每次绘制之前会主动调用 rAF 中的回调函数，如果系统绘制率是 60Hz，那么回调函数就每16.7ms 被执行一次，如果绘制频率是75Hz，那么这个间隔时间就变成了 1000/75=13.3ms
- 当页面处理未激活的状态时，该页面的屏幕绘制任务也会被系统暂停，因此跟着系统步伐走的rAF也会停止渲染，当页面被激活时，动画就从上次停留的地方继续执行，有效节省了 CPU 开销。
- 动画保持 60fps（每一帧 16 ms），浏览器内部决定渲染的最佳时机
- 简洁标准的 API，后期维护成本低

#### 缺点

- 浏览器标签未激活时，一切都不会执行
- 尽管所有的现代浏览器都支持rAF，IE9，Opera Mini 和 老的 Android 还是需要打补丁
- Node.js 不支持，无法在服务器端用于文件系统事件

## 跨域

