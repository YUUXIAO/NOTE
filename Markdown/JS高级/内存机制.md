## 内存模型

> JS 内存空间分为栈（stack）、堆（heap）、池（一般也会归类为栈中），其中栈存放变量，堆存放复杂对象，池存放常量；

### 基础数据类型与栈内存

JS 中的基础数据类型，这些值都有固定的大小，往往都保存在栈内存中（闭包除外），由系统自动分配空间；我们可以直接操作保存在栈内存空间的值，因此基础数据类型都是值访问；

数据在栈内存中的存储遵循后进先出的原则；

### 引用数据类型与堆内存

JS 的引用数据类型，它们的值的大小是不固定的，引用数据类型的值是保存在堆内存中的对象；

JS 不允许直接访问在堆内存中的位置，因此我们不能直接操作对象的堆内存空间；

在操作对象时，实际上是在操作对象的引用而不是实际的对象，所以引用类型的值都是按引用访问的，引用可以理解为保存在栈内存中的一个地址，该地址与堆内存的实际值相关联；

## 内存的生命周期

JS 环境中分配内存一般有如下的生命周期：

1. 内存分配：当我们申明变量、函数、对象的时候，系统会自动为他们分配内存；
2. 内存使用：即读写内存，也就是使用变量、函数等；
3. 内存回收：使用完毕，由垃圾回收机制自动回收不再使用的内存；

### 内存回收

Javascript 有自动垃圾收集机制，就是找出那些不再继续使用的值，然后释放其占用的内存；

垃圾收集器会每隔固定的时间段就执行一次释放操作；

### 垃圾回收算法

对于垃圾回收算法来说，核心思想就是如何判断内存已经不再使用了；

#### 引用计数算法

> 引用计数算法就是判断一个对象是否有指向它的引用，如果没有对象指向它了，说明该对象已经不再需要了；

```javascript
// 创建一个对象person，他有两个指向属性age和name的引用
var person = {
    age: 12,
    name: 'aaaa'
};

// 虽然设置为null，但person对象还有指向name的引用，因此name不会回收
person.name = null; 

var p = person; 
// 原来的person对象被赋值为1，但因为有新引用p指向原person对象，因此它不会被回收
person = 1;         

//原person对象已经没有引用，很快会被回收
p = null;           
```

引用计数算法虽然是一个简单有效的方法， 但是如果两个对象相互引用，尽管它们不再使用，垃圾回收器不会进行回收，导致内存泄露；

```javascript
function cycle() {
    var o1 = {};
    var o2 = {};
    o1.a = o2;
    o2.a = o1; 

    return "Cycle reference!"
}

cycle();
```

在调用函数结束后，对象o1和o2实际上已离开函数范围，因此不再需要了。但根据引用计数的原则，他们之间的相互引用依然存在，因此这部分内存不会被回收，内存泄露不可避免了；

#### 标记清除算法

标记清除算法就是从根部出发定时扫描内存中的对象，凡是能从根部（在JS中是全局对象）到达的对象都是需要使用的，那些无法从根部出发到达的对象被标记为不再使用，稍后进行回收；

## 内存泄露

> 对于持续运行的服务进程，必须及时释放不再用到的内存，否则内存占用越来越高，不再用到的内存，没有及时释放就是内存泄露；

### 常见的内存泄露

1. 意外的全局变量；
2. 没有及时清理的计时器或回调函数；
3. 闭包；

```javascript
// 内存溢出
var obj = {}
for (var i = 0; i < 100000; i++) {
  obj[i] = new Array(10000000)
}

// 内存泄露--意外的全局变量
function fn () {
  // 不小心没有var定义
  a = [] 
}

// 内存泄露--没有及时清理的计时器
setInterval(function  () {
  console.log('----')
}, 100

```

### 内存泄露的识别方法

> 一般如果连续五次垃圾回收之后，内存占用一次比一次大，就有内存泄露；

#### 浏览器方法

1. 打开开发者工具，选择 Timeline 面板；
2. 在顶部的 Capture 字段里勾选 Memory；
3. 点击左上角的录制按钮；
4. 在页面进行操作，模拟用户的使用情况；
5. 一段时间后，点击对话框的 stop 按钮，面板上就会显示这段时间的内存占用情况；
6. 如果内存占用基本平稳，接近水平就说明不存在内存泄露，反之就是内存泄露了；

#### 命令行方法

命令行可以使用 Node 提供的 process.memoryUsage 方法；

```javascript
console.log(process.memoryUsage());
// { 
//	rss: 27709440,   所有内存占用，包括指令区和堆栈
//  heapTotal: 5685248,		"堆"占用的内存，包括用到的和没用到的
//  heapUsed: 3449392,		用到的堆的部分
//  external: 8772 }		 V8 引擎内部的 C++ 对象占用的内存
```

判断内存泄漏，以 heapUsed 字段为准；

### WeakMap

> ES6 推出了两种新的数据结构：WeakSet 和 WeakMap，它们对于值的引用都是不计入垃圾回收机制的，表示这是弱引用；

```javascript
const wm = new WeakMap();

const element = document.getElementById('example');

wm.set(element, 'some information');
wm.get(element) // "some information"
```

在上面的代码中，DOM 节点对象的引用计数是1，而不是2。如果一旦消除对该节点的引用，它占用的内存就会被垃圾回收机制释放；Weakmap 保存的这个键值对，也会自动消失；

如果要往对象上添加数据，又不想干扰垃圾回收机制，就可以使用  WeakMap；

