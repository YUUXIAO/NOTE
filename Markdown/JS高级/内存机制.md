## 内存模型

> JS 内存空间分为栈（stack）、堆（heap）、池（一般也会归类为栈中），其中栈存放变量，堆存放复杂对象，池存放常量；

### 基础数据类型与栈内存

JS 中的基础数据类型，这些值都有固定的大小，往往都保存在栈内存中（闭包除外），由系统自动分配空间；我们可以直接操作保存在栈内存空间的值，因此基础数据类型都是值访问；

数据在栈内存中的存储遵循后进先出的原则；

### 引用数据类型与堆内存

JS 的引用数据类型，它们的值的大小是不固定的，引用数据类型的值是保存在堆内存中的对象；

JS 不允许直接访问在堆内存中的位置，因此我们不能直接操作对象的堆内存空间；

在操作对象时，实际上是在操作对象的引用而不是实际的对象，所以引用类型的值都是按引用访问的，引用可以理解为保存在栈内存中的一个地址，该地址与堆内存的实际值相关联；

## 内存的生命周期

JS 环境中分配内存一般有如下的生命周期：

1. 内存分配：当我们申明变量、函数、对象的时候，系统会自动为他们分配内存；
2. 内存使用：即读写内存，也就是使用变量、函数等；
3. 内存回收：使用完毕，由垃圾回收机制自动回收不再使用的内存；

### 内存回收

Javascript 有自动垃圾收集机制，就是找出那些不再继续使用的值，然后释放其占用的内存；

垃圾收集器会每隔固定的时间段就执行一次释放操作；

### 垃圾回收算法

对于垃圾回收算法来说，核心思想就是如何判断内存已经不再使用了；

#### 引用计数算法

> 引用计数算法就是判断一个对象是否有指向它的引用，如果没有对象指向它了，说明该对象已经不再需要了；

```javascript
// 创建一个对象person，他有两个指向属性age和name的引用
var person = {
    age: 12,
    name: 'aaaa'
};

// 虽然设置为null，但person对象还有指向name的引用，因此name不会回收
person.name = null; 

var p = person; 
// 原来的person对象被赋值为1，但因为有新引用p指向原person对象，因此它不会被回收
person = 1;         

//原person对象已经没有引用，很快会被回收
p = null;           
```

引用计数算法虽然是一个简单有效的方法， 但是如果两个对象相互引用，尽管它们不再使用，垃圾回收器不会进行回收，导致内存泄露；

```javascript
function cycle() {
    var o1 = {};
    var o2 = {};
    o1.a = o2;
    o2.a = o1; 

    return "Cycle reference!"
}

cycle();
```

在调用函数结束后，对象o1和o2实际上已离开函数范围，因此不再需要了。但根据引用计数的原则，他们之间的相互引用依然存在，因此这部分内存不会被回收，内存泄露不可避免了；

#### 标记清除算法

标记清除算法就是从根部出发定时扫描内存中的对象，凡是能从根部（在JS中是全局对象）到达的对象都是需要使用的，那些无法从根部出发到达的对象被标记为不再使用，稍后进行回收；

### V8垃圾回收机制

> V8 的垃圾回收策略主要是基于分代式垃圾回收机制，在 V8 中，将内存分为新生代和老生代，新生代的对象存活时间较短，老生代的对象存活时间较长或常驻内存；

V8 堆的整体大小等于新第生代所用内存空间加老生代的内存空间，而只能在启动时指定，运行时无法自动扩充，如果超出了极限值，就会引起进程出错；

#### Scavenge 算法

1. 在分代的基础上，新生代的对象主要通过 Scavenge 算法进行垃圾回收，在 Scavenge 算法的实现中，主要采用了一种复制的方式的方法：Cheney 算法；
2. Cheney 算法将堆内存一分为二，一个处于使用状态的空间叫 From 空间，一个处于闲置状态的空间称为 To 空间，分配对象时，先是在 From 空间中进行分配；
3. 当开始进行垃圾回收时，会检查 From 空间中的存活对象，将其复制到 To 空间中，而非存活对象占用的空间将会被释放，完成复制后，From 空间和 To 空间的角色发生对换；
4. 当一个对象经过多次复制后依然存活，它将会被认为是生命周期较长的对象，随后会被移动到老生代中，采用新的算法进行管理；
5. 另一种情况是：如果复制一个对象到 To 空间时，To 空间占用超过了 25%，则这个对象会被直接晋升到老生代空间中；

#### 标记-清除和标记-整理

1. 对于老生代中的对象，主要采用标记-清除和标记-整理算法，标记清除不会将内存空间划为两半，标记清除在标记阶段会标记活着的对象，而内存回收阶段，它会清除没有被标记的对象；
2. 标记整理是为了解决标记清除后留下的内存碎片问题；

#### 增量标记（Incremental Marking）

1. 前面的算法都需要将正在执行的 Javascript 应用逻辑暂停下来，待垃圾回收完毕再恢复，这种行为称做 ”全停顿“；
2. 在 V8 新生代的分代回收中，只收集新生代，而新生代通常配置较少，且存活对象较少，所以全停顿的影响不大，老生代则相反；
3. 为了降低全部老生代全堆垃圾回收带来的停顿时间，V8  将标记过程分为一个个的子标记过程，同时让垃圾回收标记和 JS 应用逻辑交替进行，直到标记阶段完成；
4. 经过增量标记改进后，垃圾回收的最大停顿时间可以减少到原来的 1/6 左右；

## 内存泄露

> 指的是程序中已动态分配的堆内存因为某种原因程序未释放或无法释放，造成系统内存的浪费，导致程序运行速度减慢甚至系统崩溃等后果；

### 常见的内存泄露

1. 意外的全局变量；
2. 没有及时清理的计时器或回调函数；
3. 无效的 DOM 引用；
4. 作用域未释放（闭包）；
5. 定时器未清除；

```javascript
// 内存溢出
var obj = {}
for (var i = 0; i < 100000; i++) {
  obj[i] = new Array(10000000)
}

// 内存泄露--意外的全局变量
function fn () {
  // 不小心没有var定义
  a = [] 
}

// 内存泄露--没有及时清理的计时器
setInterval(function  () {
  console.log('----')
}, 100

```

### 内存泄露的识别方法

> 一般如果连续五次垃圾回收之后，内存占用一次比一次大，就有内存泄露；

#### 浏览器方法

1. 打开开发者工具，选择 Timeline 面板；
2. 在顶部的 Capture 字段里勾选 Memory；
3. 点击左上角的录制按钮；
4. 在页面进行操作，模拟用户的使用情况；
5. 一段时间后，点击对话框的 stop 按钮，面板上就会显示这段时间的内存占用情况；
6. 如果内存占用基本平稳，接近水平就说明不存在内存泄露，反之就是内存泄露了；

#### 命令行方法

命令行可以使用 Node 提供的 process.memoryUsage 方法；

```javascript
console.log(process.memoryUsage());
// { 
//	rss: 27709440,   所有内存占用，包括指令区和堆栈
//  heapTotal: 5685248,		"堆"占用的内存，包括用到的和没用到的
//  heapUsed: 3449392,		用到的堆的部分
//  external: 8772 }		 V8 引擎内部的 C++ 对象占用的内存
```

判断内存泄漏，以 heapUsed 字段为准；

### WeakMap

> ES6 推出了两种新的数据结构：WeakSet 和 WeakMap，它们对于值的引用都是不计入垃圾回收机制的，表示这是弱引用；

```javascript
const wm = new WeakMap();

const element = document.getElementById('example');

wm.set(element, 'some information');
wm.get(element) // "some information"
```

在上面的代码中，DOM 节点对象的引用计数是1，而不是2。如果一旦消除对该节点的引用，它占用的内存就会被垃圾回收机制释放；Weakmap 保存的这个键值对，也会自动消失；

如果要往对象上添加数据，又不想干扰垃圾回收机制，就可以使用  WeakMap；

