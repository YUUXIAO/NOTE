---
typora-root-url: ..\..
---

## 原型链继承

### 流程

1. 定义父类型构造函数；
2. 给父类型的原型添加方法；
3. 定义子类型的构造函数；
4. 创建父类型的实例对象赋值给子类型的原型；
5. 将子类型原型的构造属性设置为子类型；
6. 给子类型原型添加方法；
7. 创建子类型的对象: 可以调用父类型的方法；

### 特点

1. 引用类型的属性被所有实例共享；
2. 在创建 Child 实例时，不能向 Parent 传参；

```javascript
// 定义父类型构造函数
function Supper(){
  this.superProp = 'The super prop';
}

// 给父类型的原型添加方法,原型的数据所有的实例对象都可见
Supper.prototype.showSupperProp = function () {
  console.log(this.superProp)
}

// 定义子类型的构造函数
function Sub() { 
  this.subProp = 'The sub prop'
}

// 子类的原型为父类的实例
Sub.prototype = new Supper()

// 修正子类型原型的构造属性为子类型
Sub.prototype.constructor = Sub

// 给子类型原型添加方法
Sub.prototype.showSubProp = function () {
  console.log(this.subProp)
}

// 创建子类型的实例
var sub = new Sub()
// 调用父类型的方法
sub.showSubProp()
// 调用子类型的方法
sub.showSupperProp()
```

![原型链继承](/images/原型/原型链继承.png)

## 借用构造函数继承

### 流程

1. 定义父类型构造函数；
2. 定义子类型构造函数；
3. 子类型构造函数中调用父类型构造；

### 特点

1. 避免了引用类型的属性被所有实例共享；
2. .可以在 Student 中向 Person 传参；
3. 方法都在构造函数中定义，每次创建实例都会创建一遍方法；

```javascript
function Person(name, age) {
  this.name = name
  this.age = age
}

function Student(name, age, price) {
  Person.call(this, name, age)   // this.Person(name, age)
  this.price = price
}

var s = new Student('Tom', 20, 12000)
```

## 组合继承

### 流程

1. 利用原型链实现对父类型对象的方法继承；
2. 利用 call( ) 借用父类型构建函数初始化相同属性；

### 特点

1. 融合原型链继承和构造函数的优点，是 JavaScript 中最常用的继承模式。

```javascript
function Person(name, age) {
  this.name = name
  this.age = age
}
Person.prototype.setName = function (name) {
  this.name = name
}

function Student(name, age, price) {
  Person.call(this, name, age) //得到父类型的属性
  this.price = price
}
Student.prototype = new Person()  //得到父类型的方法
Student.prototype.constructor = Student
Student.prototype.setPrice = function (price) {
  this.price = price
}

var s = new Student('Tom', 12, 10000)
s.setPrice(11000)
s.setName('Bob')
```





