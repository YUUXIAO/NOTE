## 数组的拷贝

### 浅拷贝

浅拷贝可以利用数组的一些方法比如：slice、concat 返回一个新数组的特性来实现拷贝；

```javascript
var arr = ['old', 1, true, null, undefined];
// contact 实现
var new_arr = arr.concat();
new_arr[0] = 'new';
console.log(arr) 		// ["old", 1, true, null, undefined]
console.log(new_arr) 	// ["new", 1, true, null, undefined]

// slice 实现
var new_arr = arr.slice();
new_arr[0] = 'new';
console.log(new_arr)	// ["new", 1, true, null, undefined]
console.log(arr)		// ["old", 1, true, null, undefined]
```

### 深拷贝

JSON.Stringify（）不仅适用于数组还适用于对象，但是不能拷贝函数；

```javascript
var arr = ['old', 1, true, ['old1', 'old2'], {old: 1}]
var new_arr = JSON.parse( JSON.stringify(arr) );
new_arr[3][0] = 'new';
console.log(new_arr);	// ['old', 1, true, ['new', 'old2'], {old: 1}]
console.log(arr);		// ['old', 1, true, ['old1', 'old2'], {old: 1}]
```

## 浅拷贝的实现

浅拷贝只要遍历对象，然后把属性和属性值都放在一个新的对象就好了；

```javascript
var shallowCopy = function(obj) {
  // 只拷贝对象
  if (typeof obj !== 'object') return;
  // 根据obj的类型判断是新建一个数组还是对象
  var newObj = obj instanceof Array ? [] : {};
  // 遍历obj，并且判断是obj的属性才拷贝
  for (var key in obj) {
      if (obj.hasOwnProperty(key)) {
          newObj[key] = obj[key];
      }
  }
  return newObj;
}
```

## 深拷贝的实现

深拷贝只要在拷贝的时候判断一下属性值的类型，如果是对象，我们递归调用深拷贝函数就好了；

```javascript
var deepCopy = function(obj) {
  if (obj === null || typeof obj !== 'object') return obj;
  var newObj = obj instanceof Array ? [] : {};
  for (var key in obj) {
      if (obj.hasOwnProperty(key)) {
          newObj[key] = typeof obj[key] === 'object' ? deepCopy(obj[key]) : obj[key];
      }
  }
  return newObj;
}
```

