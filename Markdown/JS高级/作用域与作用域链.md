---
typora-root-url: ..\..
---

## 作用域

> 我们将作用域定义为一套规则，这套规则用来管理引擎如何在当前作用域以及嵌套子作用域中根据标识符名称进行变量查找；

```
作用域是静态的(相对于上下文对象), 在编写代码时就确定了；
```

Javascript 代码的整个执行过程分为两个阶段：

1. 代码编译阶段
   - 由编译器完成，将代码翻译成可执行的代码，这个阶段进行词法分析、语法分析和作用域会确定；
2. 代码执行阶段
   - 由引擎完成，主要任务是执行可执行代码，执行上下文在这个阶段创建；

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c508a8bbade94a699d0baad47e5d43ed~tplv-k3u1fbpfcp-zoom-1.image)

### 分类

1. 全局作用域；
2. 函数作用域；
3. 没有块作用域（ES6 有了）；

### 作用

隔离变量，不同作用域下同名变量不会有冲突；

## 作用域与执行上下文

1. 全局作用域外，每个函数都会创建自己的作用域，作用域在函数定义时就已经确定了，而不是在函数调用时；
2. 全局执行上下文环境是在全局作用域确定之后，JS 代码马上执行前创建；
3. 函数执行上下文环境是在调用函数时，函数体代码执行之前创建；
4. 作用域是静态的，只要函数定义好了就一直存在，且不会再变化；
5. 上下文环境是动态的，调用函数时创建，函数调用结束时上下文环境就会被释放；
6. 上下文环境（对象）是从属于所在的作用域；
7. 全局上下文环境 ==》 全局作用域；
8. 函数上下文环境 ==》对应的函数作用域；

![作用域1](/images/原型/作用域1.jpg)

## 作用域链

> 作用域链就是由当前作用域与上层作用域的一系列变量对象组成，它保证了当前执行的作用域对符合访问权限的变量的函数的有序访问；

代码执行时，会先在当前的作用域查找，找不到再往上级作用域查找，查找不到的话直至全局环境；

作用域链与函数执行栈相对应，js 的运行环境分为分局、函数和 eval 三类，每当代码进入了一个新的运行环境就会将环境的执行上下文入栈，退出环境时将其出栈，从栈顶到栈底形成的从内层到外层的嵌套关系；

由执行上下文创建的词法环境持有外层执行上下文的词法环境的引用，当 JS 引擎在当前词法环境中找不到相应的变量时，会逐层向外查找，如此形成的链表即为作用域链；

1. 多个上下级的作用域形成的链，它的方向是从下向上的（从内到外）；
2. 查找变量时就是沿着作用域链来查找的；

### 查找一个变量的查找规则

1. 在当前作用域下的执行上下文中查找对应的属性，如果有直接返回；
2. 在上一级作用域的执行上下文中查找对应的属性，如果有直接返回；
3. 再次执行2的相同操作, 直到全局作用域, 如果还找不到就抛出找不到的异常；

![作用域2](/images/原型/作用域2.jpg)



```javascript
// 代码一
var x = 10;
function fn() {
  console.log(x);
}
function show(f) {
  var x = 20;
  f();
}
show(fn);			// 10

// 代码二
var fn = function () {
  console.log(fn)
}
fn()				// function () { console.log(fn) };	
var obj = {
  fn2: function () {
    console.log(fn2)
  }
}
obj.fn2()			// Uncaught ReferenceError: fn2 is not defined；
```

