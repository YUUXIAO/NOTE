---
typora-root-url: ..\..
---

## 作用域

> 作用域是静态的(相对于上下文对象), 在编写代码时就确定了；

### 分类

1. 全局作用域；
2. 函数作用域；
3. 没有块作用域（ES6 有了）；

### 作用

隔离变量，不同作用域下同名变量不会有冲突；

## 作用域与执行上下文

1. 全局作用域外，每个函数都会创建自己的作用域，作用域在函数定义时就已经确定了，而不是在函数调用时；
2. 全局执行上下文环境是在全局作用域确定之后，JS 代码马上执行前创建；
3. 函数执行上下文环境是在调用函数时，函数体代码执行之前创建；
4. 作用域是静态的，只要函数定义好了就一直存在，且不会再变化；
5. 上下文环境是动态的，调用函数时创建，函数调用结束时上下文环境就会被释放；
6. 上下文环境（对象）是从属于所在的作用域；
7. 全局上下文环境 ==》 全局作用域；
8. 函数上下文环境 ==》对应的函数作用域；

![作用域1](/images/原型/作用域1.jpg)

## 作用域链

1. 多个上下级的作用域形成的链，它的方向是从下向上的（从内到外）；
2. 查找变量时就是沿着作用域链来查找的；

### 查找一个变量的查找规则

1. 在当前作用域下的执行上下文中查找对应的属性，如果有直接返回；
2. 在上一级作用域的执行上下文中查找对应的属性，如果有直接返回；
3. 再次执行2的相同操作, 直到全局作用域, 如果还找不到就抛出找不到的异常；

![作用域2](/images/原型/作用域2.jpg)



```javascript
// 代码一
var x = 10;
function fn() {
  console.log(x);
}
function show(f) {
  var x = 20;
  f();
}
show(fn);			// 10

// 代码二
var fn = function () {
  console.log(fn)
}
fn()				// function () { console.log(fn) };	
var obj = {
  fn2: function () {
    console.log(fn2)
  }
}
obj.fn2()			// Uncaught ReferenceError: fn2 is not defined；
```

